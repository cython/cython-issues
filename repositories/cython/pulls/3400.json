{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/cython/cython/issues/3400/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/cython/cython/pulls/3400/commits"
        },
        "html": {
            "href": "https://github.com/cython/cython/pull/3400"
        },
        "issue": {
            "href": "https://api.github.com/repos/cython/cython/issues/3400"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/cython/cython/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/cython/cython/pulls/3400/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/cython/cython/pulls/3400"
        },
        "statuses": {
            "href": "https://api.github.com/repos/cython/cython/statuses/a25b746532149f254ca28b4ef1567ea230d967aa"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "COLLABORATOR",
    "auto_merge": null,
    "base": {
        "label": "cython:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/cython/cython/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/cython/cython/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/cython/cython/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/cython/cython/branches{/branch}",
            "clone_url": "https://github.com/cython/cython.git",
            "collaborators_url": "https://api.github.com/repos/cython/cython/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/cython/cython/comments{/number}",
            "commits_url": "https://api.github.com/repos/cython/cython/commits{/sha}",
            "compare_url": "https://api.github.com/repos/cython/cython/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/cython/cython/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/cython/cython/contributors",
            "created_at": "2010-11-21T07:44:20Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/cython/cython/deployments",
            "description": "The most widely used Python to C compiler",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/cython/cython/downloads",
            "events_url": "https://api.github.com/repos/cython/cython/events",
            "fork": false,
            "forks": 1227,
            "forks_count": 1227,
            "forks_url": "https://api.github.com/repos/cython/cython/forks",
            "full_name": "cython/cython",
            "git_commits_url": "https://api.github.com/repos/cython/cython/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/cython/cython/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/cython/cython/git/tags{/sha}",
            "git_url": "git://github.com/cython/cython.git",
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://cython.org",
            "hooks_url": "https://api.github.com/repos/cython/cython/hooks",
            "html_url": "https://github.com/cython/cython",
            "id": 1099265,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/cython/cython/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/cython/cython/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/cython/cython/issues{/number}",
            "keys_url": "https://api.github.com/repos/cython/cython/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/cython/cython/labels{/name}",
            "language": "Python",
            "languages_url": "https://api.github.com/repos/cython/cython/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/cython/cython/merges",
            "milestones_url": "https://api.github.com/repos/cython/cython/milestones{/number}",
            "mirror_url": null,
            "name": "cython",
            "node_id": "MDEwOlJlcG9zaXRvcnkxMDk5MjY1",
            "notifications_url": "https://api.github.com/repos/cython/cython/notifications{?since,all,participating}",
            "open_issues": 1009,
            "open_issues_count": 1009,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/486082?v=4",
                "events_url": "https://api.github.com/users/cython/events{/privacy}",
                "followers_url": "https://api.github.com/users/cython/followers",
                "following_url": "https://api.github.com/users/cython/following{/other_user}",
                "gists_url": "https://api.github.com/users/cython/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/cython",
                "id": 486082,
                "login": "cython",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjQ4NjA4Mg==",
                "organizations_url": "https://api.github.com/users/cython/orgs",
                "received_events_url": "https://api.github.com/users/cython/received_events",
                "repos_url": "https://api.github.com/users/cython/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/cython/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/cython/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/cython"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/cython/cython/pulls{/number}",
            "pushed_at": "2022-01-05T23:50:14Z",
            "releases_url": "https://api.github.com/repos/cython/cython/releases{/id}",
            "size": 63283,
            "ssh_url": "git@github.com:cython/cython.git",
            "stargazers_count": 6642,
            "stargazers_url": "https://api.github.com/repos/cython/cython/stargazers",
            "statuses_url": "https://api.github.com/repos/cython/cython/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/cython/cython/subscribers",
            "subscription_url": "https://api.github.com/repos/cython/cython/subscription",
            "svn_url": "https://github.com/cython/cython",
            "tags_url": "https://api.github.com/repos/cython/cython/tags",
            "teams_url": "https://api.github.com/repos/cython/cython/teams",
            "topics": [
                "big-data",
                "c",
                "cpp",
                "cpython",
                "cpython-extensions",
                "cython",
                "performance",
                "python"
            ],
            "trees_url": "https://api.github.com/repos/cython/cython/git/trees{/sha}",
            "updated_at": "2022-01-06T14:30:48Z",
            "url": "https://api.github.com/repos/cython/cython",
            "visibility": "public",
            "watchers": 6642,
            "watchers_count": 6642
        },
        "sha": "c25c87d71107e634162302f7f61a119eff539a48",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/486082?v=4",
            "events_url": "https://api.github.com/users/cython/events{/privacy}",
            "followers_url": "https://api.github.com/users/cython/followers",
            "following_url": "https://api.github.com/users/cython/following{/other_user}",
            "gists_url": "https://api.github.com/users/cython/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/cython",
            "id": 486082,
            "login": "cython",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjQ4NjA4Mg==",
            "organizations_url": "https://api.github.com/users/cython/orgs",
            "received_events_url": "https://api.github.com/users/cython/received_events",
            "repos_url": "https://api.github.com/users/cython/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/cython/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/cython/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/cython"
        }
    },
    "body": "Used cython.dataclasses.dataclass and cython.dataclasses.field to mark dataclasses and their fields.\r\n\r\nTries to match the interface provided by a regular dataclass as much as possible.\r\nThis means taking the types from the dataclasses module if available (so they\r\nmatch exactly) or a fallback Python version that just implements the core\r\nparts (obtained with PyRun_SimpleString in the C source).\r\n\r\nUse of placeholders in generated `__init__` code means the code in the C file\r\nisn't hugely readable. Probably not a huge issue, but don't really see a\r\nway round that.\r\n\r\nAs part of this I've also also implemented a Cython version of `typing.ClassVar`. Although really designed for use with dataclasses it behaves sensibly when used in types in a normal `cdef class`. Potentially this might be worth documenting more thoroughly?\r\n\r\nStatus\r\n--------\r\n\r\n- [x] Both annotated variables and cdef attributes included in dataclass - done (but assignment syntax for cdef attributes is a bit clunky because it needs to be on a separate line)\r\n- [x] visibility of the attributes decided to be visible by default for annotations, invisible for cdef attributes\r\n- [x] non-public attributes omitted from `__dataclass_fields__`\r\n- [x] moving \"directives\" into `cython.dataclasses` and `cython.typing` submodules\r\n  - [ ] I'd quite like these `cython.dataclasses` submodules and their attributes to be available at runtime and just forwarded to their standard library modules if available. This may be fiddly\r\n- [x] \"frozen\" option of dataclasses works. (Obviously hard to enforce at C level)\r\n\r\n----------------------------------\r\n\r\nOld commentary on design decisions (can now mostly be ignored)\r\n--------------------------------\r\n\r\nWhen finished closes https://github.com/cython/cython/issues/2903 -\r\nhowever, some design decisions pending before it's finished:\r\n\r\nWhat attributes should be included in the dataclass? Definitely annotated variables. Maybe regular `cdef` variables?\r\n\r\nWhat should the visibility of the attributes be? There's a few options:\r\n1. Default to invisible, like for a standard `cdef class`. This is obviously consistent. The issue with this is that there's a few functions in the `dataclasses` module like [`asdict`](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict) which assume that every attribute declared in `__dataclass_fields__` is readable. If they aren't then the classes won't be compatible with those interfaces.\r\n\r\n     If so, should non-public attributes be omitted from `__dataclass_fields__`? This seems inconsistent since they do appear in the destructor, the repr, and affect the comparisons.\r\n\r\n2. Default to visible. This is inconsistent with the standard `cdef class` behaviour, but would make them as compatible as possible with standard `dataclasses`. It would also make sense for most use-cases I think. One problem is that the syntax doesn't really exist of override that (only `public` and `readonly` are defined).\r\n\r\n3. Annotated variables default to visible, `cdef` variables to invisible? It kind of makes sense and gives a way to control visibility, but it'd be a little inconsistent with everything. (I'm leaning towards this as the answer)\r\n\r\nThe likely implementation deviates from the normal `cdef class` behaviour where\r\n```\r\ncdef class C:\r\n   a: `int` = 0\r\n```\r\nmakes a class-variable instead of an instance variable. I think this is unavoidable and makes sense in this case, but comments on this welcome too?\r\n\r\nIt dumps a number of names in the `cython` scope (`dataclass`, `field`, `InitVar`, `ClassVar`). Would some sort of subscoping be better? Especially given that it isn't 100% obvious that any of these but `dataclass` related to dataclasses?",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r389394947"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/389394947"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "This syntax (needing to put the assignment on a separate line) is a bit messy, however it's enforced at a pretty early stage (the PostParse transform) so it doesn't look easy to slacken it for dataclasses.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-03-08T18:46:22Z",
            "diff_hunk": "@@ -1032,5 +1032,38 @@ generated containing declarations for its object struct and type object. By\n including the ``.h`` file in external C code that you write, that code can\n access the attributes of the extension type.\n \n+Dataclass extension types\n+=========================\n+\n+Cython supports extension types that behave like the dataclasses defined in\n+the Python 3.7+ standard library. The main benefit of using a dataclasses is\n+that it can auto-generate simple `__init__`, `__repr__` and comparison\n+functions. The Cython implementation behaves as much like the Python\n+standard library implementation as possible and therefore the documentation\n+here only briefly outlines the differences - if you plan on using them\n+then please read the documentation for the standard library module.\n \n+Dataclasses can be declared using the `@cython.dataclass` decorator. If\n+you need to define special properties on a field then use `cython.field`::\n \n+    cimport cython\n+    \n+    @cython.dataclass\n+    cdef class MyDataclass:\n+        # fields can be declared using annotations\n+        a: int = 0\n+        b: double = cython.field(default_factory = lambda: 10, repr=False)\n+        \n+        # fields can also be declared using `cdef`:\n+        cdef str c\n+        c = \"hello\"  # assignment of default value on a separate line",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r389394947",
            "id": 389394947,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5NDk0Nw==",
            "original_commit_id": "153f18af041f9e21a094ff80a72b9fff363fd4aa",
            "original_line": 1059,
            "original_position": 28,
            "original_start_line": null,
            "path": "docs/src/userguide/extension_types.rst",
            "position": null,
            "pull_request_review_id": 370849988,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/389394947/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/389394947",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r392082755"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/392082755"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Just highlighting this because: I don't think this is awful but I'm not sure all the details are quite right. It's probably worth getting right because if done well you could implement chunks of PEP-484 largely using the same model (although much of the PEP-484 detail is too generic to be useful to Cython)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-03-13T08:14:48Z",
            "diff_hunk": "@@ -4118,6 +4124,72 @@ def same_as_resolved_type(self, other_type):\n     def error_condition(self, result_code):\n         return \"dummy\"\n \n+class InitOrClassVar: #(PyrexType):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r392082755",
            "id": 392082755,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4Mjc1NQ==",
            "original_commit_id": "491bd771ea752d64b385470f84b36c31d7259b8b",
            "original_line": 4127,
            "original_position": 37,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 374112543,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/392082755/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/392082755",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r485897978"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/485897978"
                }
            },
            "author_association": "MEMBER",
            "body": "But public fields already have property nodes, right? Isn't that enough to handle them?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-09T20:19:27Z",
            "diff_hunk": "@@ -0,0 +1,611 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode(pos, name):\n+    loader_utilitycode = UtilityCode.load_cached(\"%sModuleLoader\" % name, \"Dataclasses.c\")\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load%sModule\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+def make_dataclass_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Dataclass\")\n+def make_typing_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Typing\")\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(\n+        UtilityCode.load_cached(\"DataclassModuleLoader\", \"Dataclasses.c\"))\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:\n+        # store fields as nodes so they can be used in code construction\n+        # more readily; define class inside function so default arguments\n+        # have a useful pos",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r485897978",
            "id": 485897978,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5Nzk3OA==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 78,
            "original_position": 78,
            "original_start_line": 76,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 485373094,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/485897978/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/485897978",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r485900059"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/485900059"
                }
            },
            "author_association": "MEMBER",
            "body": "Lovely. ;-)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-09T20:23:29Z",
            "diff_hunk": "@@ -1,6 +1,6 @@\n /////////////// FetchCommonType.proto ///////////////\n \n-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);\n+static CYTHON_UNUSED PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r485900059",
            "id": 485900059,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkwMDA1OQ==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 3,
            "original_position": 4,
            "original_start_line": 1,
            "path": "Cython/Utility/CommonStructures.c",
            "position": null,
            "pull_request_review_id": 485373094,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/485900059/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/485900059",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r485903258"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/485903258"
                }
            },
            "author_association": "MEMBER",
            "body": "Can you imagine that some people on this planet would sense the word \"hack\" floating by when facing this code?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-09T20:29:44Z",
            "diff_hunk": "@@ -177,3 +178,18 @@\n \n def py_version_hex(major, minor=0, micro=0, release_level=0, release_serial=0):\n     return (major << 24) | (minor << 16) | (micro << 8) | (release_level << 4) | (release_serial)\n+\n+class _py_code:\n+    # This is in Naming.py to be able to abuse the UtilityCode \"subsitute naming\" mechanism.",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r485903258",
            "id": 485903258,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkwMzI1OA==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 183,
            "original_position": 14,
            "original_start_line": null,
            "path": "Cython/Compiler/Naming.py",
            "position": null,
            "pull_request_review_id": 485373094,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/485903258/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/485903258",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r485906541"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/485906541"
                }
            },
            "author_association": "MEMBER",
            "body": "Can't this be done at a later stage, where we already _have_ the type available? And, is this really all that different from `typeof()`?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-09T20:35:42Z",
            "diff_hunk": "@@ -0,0 +1,611 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode(pos, name):\n+    loader_utilitycode = UtilityCode.load_cached(\"%sModuleLoader\" % name, \"Dataclasses.c\")\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load%sModule\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+def make_dataclass_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Dataclass\")\n+def make_typing_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Typing\")\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(\n+        UtilityCode.load_cached(\"DataclassModuleLoader\", \"Dataclasses.c\"))\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:\n+        # store fields as nodes so they can be used in code construction\n+        # more readily; define class inside function so default arguments\n+        # have a useful pos\n+        default = MISSING\n+        default_factory = MISSING\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.field' must only consist of compile-time \"\n+                          \"keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead and see \"\n+                          \"'https://docs.python.org/library/dataclasses.html#mutable-default-values'\"\n+                          \"for more details\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+\n+    # https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    dataclass_scope = make_common_utilitycode(node.scope)\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclass_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _setup_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion done comes later\n+    # (for some reason this has to be on the class scope, so save and restore)\n+    annotation_typing = node.scope.directives['annotation_typing']\n+    node.scope.directives['annotation_typing'] = False\n+    stats.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(stats)\n+    analyse_decs_transform.exit_scope()\n+    node.scope.directives['annotation_typing'] = annotation_typing\n+\n+    RemoveDontAnalyseDeclarations()(stats)\n+\n+    node.body.stats.extend(stats.stats)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclass_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.pep563_annotation\n+        if annotation:\n+            annotation = u\": %s\" % annotation\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:\n+                            pass  # not convinced a failure means much\n+                    if nn.entry:\n+                        return nn.analyse_types(env)\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.pep563_annotation\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+class DontAnalyseDeclarationsNode(ExprNodes.ExprNode):\n+    # arg    ExprNode\n+    #\n+    # This is designed to wrap stuff that's already been analysed\n+    # so that lambdas aren't redeclared for example\n+    # and then immediately be replaced\n+\n+    subexprs = []\n+\n+    def analyse_declarations(self, env):\n+        return\n+\n+class RemoveDontAnalyseDeclarations(VisitorTransform):\n+    def visit_DontAnalyseDeclarationsNode(self, node):\n+        return node.arg\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string\n+    subexprs = ['arg']\n+\n+    def __init__(self, pos, arg):\n+        super(FieldsValueNode, self).__init__(pos, arg=arg)\n+\n+    def analyse_types(self, env):\n+        self.arg.analyse_types(env)\n+        self.type = self.arg.type\n+        return self\n+\n+    def coerce_to_pyobject(self, env):\n+        if self.arg.type.can_coerce_to_pyobject(env):\n+            return self.arg.coerce_to_pyobject(env)\n+        else:\n+            # A string representation of the code that gave the field seems like a reasonable\n+            # fallback. This'll mostly happen for \"default\" and \"default_factory\" where the\n+            # type may be a C-type that can't be converted to Python.\n+            return self._make_string()\n+\n+    def _make_string(self):\n+        from .AutoDocTransforms import AnnotationWriter\n+        writer = AnnotationWriter(description=\"Dataclass field\")\n+        string = writer.write(self.arg)\n+        return ExprNodes.StringNode(self.pos, value=EncodedString(string))\n+\n+    def generate_evaluation_code(self, code):\n+        return self.arg.generate_evaluation_code(code)\n+\n+\n+def _setup_dataclass_fields(node, fields, dataclass_module):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode,\n+                            CloneNode)\n+\n+    # For defaults and default_factories containing things like lambda,\n+    # they're already declared in the class scope, and it creates a big\n+    # problem if multiple copies are floating around in both the __init__\n+    # function, and in the __dataclass_fields__ structure.\n+    # Therefore, create module-level constants holding these values and\n+    # pass those around instead\n+    variables_assignment_stats = []\n+    for name, field in fields.items():\n+        for attrname in [ \"default\", \"default_factory\" ]:\n+            f_def = getattr(field, attrname)\n+            if f_def is MISSING or f_def.is_literal or f_def.is_name:\n+                # some simple cases where we don't need to set up\n+                # the variable as a module-level constant\n+                continue\n+            global_scope = node.scope.global_scope()\n+            module_field_name = global_scope.mangle(global_scope.mangle(\n+                                    Naming.dataclass_field_default_cname,\n+                                    node.class_name), name)\n+            # create an entry in the global scope for this variable to live\n+            nn = NameNode(f_def.pos, name=EncodedString(module_field_name))\n+            nn.entry = global_scope.declare_var(nn.name, type=f_def.type or PyrexTypes.unspecified_type,\n+                                                pos=f_def.pos, cname=nn.name, is_cdef=1)\n+            # replace the field so that future users just receive the namenode\n+            setattr(field, attrname, nn)\n+\n+            variables_assignment_stats.append(\n+                Nodes.SingleAssignmentNode(f_def.pos,\n+                                           lhs = nn,\n+                                           rhs = DontAnalyseDeclarationsNode(f_def.pos, arg=f_def)))\n+\n+    placeholders = {}\n+    field_func = AttributeNode(node.pos, obj = dataclass_module,\n+                                    attribute=EncodedString(\"field\"))\n+    dc_fields = DictNode(node.pos, key_value_pairs=[])\n+    dc_fields_namevalue_assignments = []\n+    for name, field in fields.items():\n+        placeholder_name = \"PLACEHOLDER_%s\" % name\n+        placeholders[placeholder_name] = GetTypeNode(node.scope.entries[name])",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r485906541",
            "id": 485906541,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkwNjU0MQ==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 575,
            "original_position": 575,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 485373094,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/485906541/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/485906541",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r485917198"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/485917198"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "This is because I'm only requiring this from utilitycode but only `__Pyx_FetchSharedCythonABIModule`. On second look it'd probably be better splitting it into 2 bits so I can get `__Pyx_FetchSharedCythonABIModule` on its own.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-09T20:56:35Z",
            "diff_hunk": "@@ -1,6 +1,6 @@\n /////////////// FetchCommonType.proto ///////////////\n \n-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);\n+static CYTHON_UNUSED PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r485917198",
            "id": 485917198,
            "in_reply_to_id": 485900059,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxNzE5OA==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 3,
            "original_position": 4,
            "original_start_line": 1,
            "path": "Cython/Utility/CommonStructures.c",
            "position": null,
            "pull_request_review_id": 485397552,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/485917198/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/485917198",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r485931754"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/485931754"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "The difference/complication between this and `typeof` is that `typeof` always returns a string, while I'm trying to return a Python type object if at all possible (to match what goes in `__dataclass_fields__` when generated by the standard library). It isn't always possible but I was trying to match what's generated by the standard library as closely as I could.\r\n\r\nI think the idea for doing it here was to try to have (almost) a single transformation which adds all the methods and attributes that make a class a dataclass. After that it can just pass through the normal Cython pipeline as normal.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-09T21:27:22Z",
            "diff_hunk": "@@ -0,0 +1,611 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode(pos, name):\n+    loader_utilitycode = UtilityCode.load_cached(\"%sModuleLoader\" % name, \"Dataclasses.c\")\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load%sModule\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+def make_dataclass_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Dataclass\")\n+def make_typing_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Typing\")\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(\n+        UtilityCode.load_cached(\"DataclassModuleLoader\", \"Dataclasses.c\"))\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:\n+        # store fields as nodes so they can be used in code construction\n+        # more readily; define class inside function so default arguments\n+        # have a useful pos\n+        default = MISSING\n+        default_factory = MISSING\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.field' must only consist of compile-time \"\n+                          \"keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead and see \"\n+                          \"'https://docs.python.org/library/dataclasses.html#mutable-default-values'\"\n+                          \"for more details\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+\n+    # https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    dataclass_scope = make_common_utilitycode(node.scope)\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclass_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _setup_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion done comes later\n+    # (for some reason this has to be on the class scope, so save and restore)\n+    annotation_typing = node.scope.directives['annotation_typing']\n+    node.scope.directives['annotation_typing'] = False\n+    stats.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(stats)\n+    analyse_decs_transform.exit_scope()\n+    node.scope.directives['annotation_typing'] = annotation_typing\n+\n+    RemoveDontAnalyseDeclarations()(stats)\n+\n+    node.body.stats.extend(stats.stats)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclass_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.pep563_annotation\n+        if annotation:\n+            annotation = u\": %s\" % annotation\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:\n+                            pass  # not convinced a failure means much\n+                    if nn.entry:\n+                        return nn.analyse_types(env)\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.pep563_annotation\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+class DontAnalyseDeclarationsNode(ExprNodes.ExprNode):\n+    # arg    ExprNode\n+    #\n+    # This is designed to wrap stuff that's already been analysed\n+    # so that lambdas aren't redeclared for example\n+    # and then immediately be replaced\n+\n+    subexprs = []\n+\n+    def analyse_declarations(self, env):\n+        return\n+\n+class RemoveDontAnalyseDeclarations(VisitorTransform):\n+    def visit_DontAnalyseDeclarationsNode(self, node):\n+        return node.arg\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string\n+    subexprs = ['arg']\n+\n+    def __init__(self, pos, arg):\n+        super(FieldsValueNode, self).__init__(pos, arg=arg)\n+\n+    def analyse_types(self, env):\n+        self.arg.analyse_types(env)\n+        self.type = self.arg.type\n+        return self\n+\n+    def coerce_to_pyobject(self, env):\n+        if self.arg.type.can_coerce_to_pyobject(env):\n+            return self.arg.coerce_to_pyobject(env)\n+        else:\n+            # A string representation of the code that gave the field seems like a reasonable\n+            # fallback. This'll mostly happen for \"default\" and \"default_factory\" where the\n+            # type may be a C-type that can't be converted to Python.\n+            return self._make_string()\n+\n+    def _make_string(self):\n+        from .AutoDocTransforms import AnnotationWriter\n+        writer = AnnotationWriter(description=\"Dataclass field\")\n+        string = writer.write(self.arg)\n+        return ExprNodes.StringNode(self.pos, value=EncodedString(string))\n+\n+    def generate_evaluation_code(self, code):\n+        return self.arg.generate_evaluation_code(code)\n+\n+\n+def _setup_dataclass_fields(node, fields, dataclass_module):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode,\n+                            CloneNode)\n+\n+    # For defaults and default_factories containing things like lambda,\n+    # they're already declared in the class scope, and it creates a big\n+    # problem if multiple copies are floating around in both the __init__\n+    # function, and in the __dataclass_fields__ structure.\n+    # Therefore, create module-level constants holding these values and\n+    # pass those around instead\n+    variables_assignment_stats = []\n+    for name, field in fields.items():\n+        for attrname in [ \"default\", \"default_factory\" ]:\n+            f_def = getattr(field, attrname)\n+            if f_def is MISSING or f_def.is_literal or f_def.is_name:\n+                # some simple cases where we don't need to set up\n+                # the variable as a module-level constant\n+                continue\n+            global_scope = node.scope.global_scope()\n+            module_field_name = global_scope.mangle(global_scope.mangle(\n+                                    Naming.dataclass_field_default_cname,\n+                                    node.class_name), name)\n+            # create an entry in the global scope for this variable to live\n+            nn = NameNode(f_def.pos, name=EncodedString(module_field_name))\n+            nn.entry = global_scope.declare_var(nn.name, type=f_def.type or PyrexTypes.unspecified_type,\n+                                                pos=f_def.pos, cname=nn.name, is_cdef=1)\n+            # replace the field so that future users just receive the namenode\n+            setattr(field, attrname, nn)\n+\n+            variables_assignment_stats.append(\n+                Nodes.SingleAssignmentNode(f_def.pos,\n+                                           lhs = nn,\n+                                           rhs = DontAnalyseDeclarationsNode(f_def.pos, arg=f_def)))\n+\n+    placeholders = {}\n+    field_func = AttributeNode(node.pos, obj = dataclass_module,\n+                                    attribute=EncodedString(\"field\"))\n+    dc_fields = DictNode(node.pos, key_value_pairs=[])\n+    dc_fields_namevalue_assignments = []\n+    for name, field in fields.items():\n+        placeholder_name = \"PLACEHOLDER_%s\" % name\n+        placeholders[placeholder_name] = GetTypeNode(node.scope.entries[name])",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r485931754",
            "id": 485931754,
            "in_reply_to_id": 485906541,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMTc1NA==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 575,
            "original_position": 575,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 485415803,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/485931754/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/485931754",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r486132635"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/486132635"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "In fairness this was the one bit of code I still understood 6 months later, which suggests it was probably the best bit.\r\n\r\nI've replaced it with Tempita though.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-10T07:44:29Z",
            "diff_hunk": "@@ -177,3 +178,18 @@\n \n def py_version_hex(major, minor=0, micro=0, release_level=0, release_serial=0):\n     return (major << 24) | (minor << 16) | (micro << 8) | (release_level << 4) | (release_serial)\n+\n+class _py_code:\n+    # This is in Naming.py to be able to abuse the UtilityCode \"subsitute naming\" mechanism.",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r486132635",
            "id": 486132635,
            "in_reply_to_id": 485903258,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzMjYzNQ==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 183,
            "original_position": 14,
            "original_start_line": null,
            "path": "Cython/Compiler/Naming.py",
            "position": null,
            "pull_request_review_id": 485664395,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/486132635/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/486132635",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r486152428"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/486152428"
                }
            },
            "author_association": "MEMBER",
            "body": "I'd try to stick the `@requires` where the dependency actually arises, and that's in the implementation part most of the time.\r\n```suggestion\r\n\r\nstatic PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);\r\n#if CYTHON_COMPILING_IN_LIMITED_API\r\nstatic PyTypeObject* __Pyx_FetchCommonTypeFromSpec(PyType_Spec *spec, PyObject *bases);\r\n#endif\r\n\r\n/////////////// FetchCommonType ///////////////\r\n//@requires: FetchSharedCythonModule\r\n\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-10T08:16:53Z",
            "diff_hunk": "@@ -14,6 +11,16 @@ static PyObject *__Pyx_FetchSharedCythonABIModule(void) {\n     return abi_module;\n }\n \n+/////////////// FetchCommonType.proto ///////////////\n+//@requires: FetchSharedCythonModule\n+\n+static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);\n+#if CYTHON_COMPILING_IN_LIMITED_API\n+static PyTypeObject* __Pyx_FetchCommonTypeFromSpec(PyType_Spec *spec, PyObject *bases);\n+#endif\n+\n+/////////////// FetchCommonType ///////////////\n+",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r486152428",
            "id": 486152428,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MjQyOA==",
            "original_commit_id": "3449117240c87f7746fbb3bf0dbf79d96d5841f2",
            "original_line": 23,
            "original_position": 28,
            "original_start_line": 15,
            "path": "Cython/Utility/CommonStructures.c",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/486152428/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/486152428",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r486511899"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/486511899"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "The CPython dataclass implementation defines [`field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field) which is used to give extra control - for example for turning saying \"this attribute doesn't appear in `__repr__`\" or for setting up a default factory function.\r\n\r\n`field` ends up being used in two places: controlling the code generation and as inspectable information in `__dataclass_fields__`. In the standard library module the same structure is naturally used for both. In Cython that doesn't quite work as naturally. Even so I found it useful to replicate the `dataclasses.field` structure at the code generation stage to keep track of what options are set for each attribute.\r\n\r\nWhen I was writing this I was copying from the standard library module quite a bit so it made sense to try to use similar structures.\r\n\r\nI'll try to get some of this in comments next to the code though since the comments currently next to the code aren't particularly helpful.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-09-10T17:25:57Z",
            "diff_hunk": "@@ -0,0 +1,611 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode(pos, name):\n+    loader_utilitycode = UtilityCode.load_cached(\"%sModuleLoader\" % name, \"Dataclasses.c\")\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load%sModule\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+def make_dataclass_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Dataclass\")\n+def make_typing_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Typing\")\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(\n+        UtilityCode.load_cached(\"DataclassModuleLoader\", \"Dataclasses.c\"))\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:\n+        # store fields as nodes so they can be used in code construction\n+        # more readily; define class inside function so default arguments\n+        # have a useful pos",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r486511899",
            "id": 486511899,
            "in_reply_to_id": 485897978,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMTg5OQ==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 78,
            "original_position": 78,
            "original_start_line": 76,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 486154801,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/486511899/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/486511899",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499348658"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499348658"
                }
            },
            "author_association": "MEMBER",
            "body": "Isn't there a way that this wouldn't be needed, rather than creating a fake entry? (same below)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T05:11:05Z",
            "diff_hunk": "@@ -135,9 +137,28 @@ def load_cythonscope(self):\n         for ext_type in ext_types:\n             ext_type.is_cython_builtin_type = 1\n \n-\n         # self.entries[\"array\"] = view_utility_scope.entries.pop(\"array\")\n \n+        # dataclasses and typing scopes\n+        dataclassesscope = ModuleScope(u'dataclasses', self, None)\n+        self.declare_module('dataclasses', dataclassesscope, None).as_module = dataclassesscope\n+        dataclassesscope.is_cython_builtin = True\n+        dataclassesscope.pxd_file_loaded = True\n+        entry = dataclassesscope.declare_type(\"InitVar\", InitOrClassVar(\"InitVar\"), pos = None)\n+        # just need .as_variable to appear like an entry - the namenode is swapped\n+        # out in TransformBuiltinMethods anyway\n+        dummy_entry = Entry(\"InitVar\", \"<error>\", py_object_type)\n+        entry.as_variable = dummy_entry",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499348658",
            "id": 499348658,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0ODY1OA==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 151,
            "original_position": 40,
            "original_start_line": 148,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499348658/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499348658",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499348984"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499348984"
                }
            },
            "author_association": "MEMBER",
            "body": "Suggests to me that `name` would better be named `cname`.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T05:12:44Z",
            "diff_hunk": "@@ -0,0 +1,629 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode_and_utilcode(pos, name, py_code):\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+                                                        context={'name': name, 'py_code': py_code})\n+    return (ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_%s_Module\" % name,",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499348984",
            "id": 499348984,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0ODk4NA==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 18,
            "original_position": 18,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499348984/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499348984",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499350639"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499350639"
                }
            },
            "author_association": "MEMBER",
            "body": "Link to the CPython docs here.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T05:20:27Z",
            "diff_hunk": "@@ -1046,5 +1046,26 @@ generated containing declarations for its object struct and type object. By\n including the ``.h`` file in external C code that you write, that code can\n access the attributes of the extension type.\n \n+Dataclass extension types\n+=========================\n \n+Cython supports extension types that behave like the dataclasses defined in\n+the Python 3.7+ standard library. The main benefit of using a dataclass is\n+that it can auto-generate simple `__init__`, `__repr__` and comparison\n+functions. The Cython implementation behaves as much like the Python\n+standard library implementation as possible and therefore the documentation\n+here only briefly outlines the differences - if you plan on using them\n+then please read the documentation for the standard library module.",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499350639",
            "id": 499350639,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1MDYzOQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 1058,
            "original_position": 13,
            "original_start_line": null,
            "path": "docs/src/userguide/extension_types.rst",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499350639/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499350639",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499352761"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499352761"
                }
            },
            "author_association": "MEMBER",
            "body": "Would be nice if we didn't need these. I don't think there is value in having our own copies, compared to the ones in the stdlib. I think having our own (slightly more explicit) decorator is good, but for the declarations, having our own copies seems more excessive than helpful. As you can see from your implementation, it also requires a lot of complexity and infrastructure.\r\n\r\nBasically, if you use this feature in `.pyx` files, then the fallbacks aren't really needed for the compile time declarations. If you use it in `.py` files, then you'll need a suitable Python version anyway, and still don't need the fallbacks.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T05:30:52Z",
            "diff_hunk": "@@ -0,0 +1,15 @@\n+cimport cython\n+\n+@cython.dataclasses.dataclass\n+cdef class MyDataclass:\n+    # fields can be declared using annotations\n+    a: cython.int = 0\n+    b: double = cython.dataclasses.field(default_factory = lambda: 10, repr=False)\n+\n+    # fields can also be declared using `cdef`:\n+    cdef str c\n+    c = \"hello\"  # assignment of default value on a separate line\n+\n+    # cython equivalents to InitVar and typing.ClassVar also work\n+    d: cython.dataclasses.InitVar[double] = 5\n+    e: cython.typing.ClassVar[list] = []",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499352761",
            "id": 499352761,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1Mjc2MQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": 13,
            "path": "docs/examples/userguide/extension_types/dataclass.pyx",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499352761/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499352761",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499354160"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499354160"
                }
            },
            "author_association": "MEMBER",
            "body": "Unless this is intended as a Py3-only feature, Py2 should use \"new\"-style classes here.\r\n```suggestion\r\nclass Field(object):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T05:37:17Z",
            "diff_hunk": "@@ -0,0 +1,113 @@\n+################### Dataclasses_fallback ###############################\n+\n+# This is the fallback dataclass code if the stdlib module isn't available.\n+# It defines enough of the support types to be used with cdef classes\n+# and to fail if used on regular types.\n+\n+# (Intended to be included as py code - not compiled)\n+\n+from collections import namedtuple\n+try:\n+    from types import MappingProxyType\n+except ImportError:\n+    # mutable fallback if unavailable\n+    MappingProxyType = lambda x: x\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+_DataclassParams = namedtuple('_DataclassParams',\n+    [\"init\", \"repr\", \"eq\", \"order\", \"unsafe_hash\", \"frozen\"])\n+class Field:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499354160",
            "id": 499354160,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NDE2MA==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 22,
            "original_position": 22,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499354160/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499354160",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499355395"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499355395"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this annotation needed? Doesn't it even require an explicit replacement context?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T05:42:19Z",
            "diff_hunk": "@@ -0,0 +1,82 @@\n+///////////////////// ModuleLoader.proto //////////////////////////\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code); /* proto */\n+\n+//////////////////// ModuleLoader ///////////////////////\n+//@requires: CommonStructures.c::FetchSharedCythonModule\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code) {\n+    // In supporting dataclasses we want to be able to use directives like:\n+    //  cython.dataclasses.dataclass, cython.dataclasses.field, cython.dataclasses.InitVar\n+    //   (based on the Standard Library dataclasses module)\n+    //  cython.typing.ClassVar (based on the standard library tying module)\n+    // These are processed efficiently by Cython as much as possible, but if they are treated\n+    // as a Python object then the objects from the standard library module should be substituted.\n+    // If those objects aren't available (due to Python version) then a simple fallback is substituted\n+    // instead, which largely just fails with a not-implemented error.\n+    //\n+    // The fallbacks are placed in the \"shared abi module\" as a convenient internal place to\n+    // store them\n+\n+    PyObject *shared_abi_module = 0, *module = 0;\n+\n+    shared_abi_module = __Pyx_FetchSharedCythonABIModule();\n+    if (!shared_abi_module) return NULL;\n+\n+    if (PyObject_HasAttrString(shared_abi_module, name)) {\n+        PyObject* result = PyObject_GetAttrString(shared_abi_module, name);\n+        Py_DECREF(shared_abi_module);\n+        return result;\n+    }\n+\n+    // the best and simplest case is simply to defer to the standard library (if available)\n+    module = PyImport_ImportModule(name);\n+    if (!module) {\n+        PyObject *localDict, *runValue, *builtins, *modulename;\n+        if (PyErr_ExceptionMatches(PyExc_ImportError)) {\n+            PyErr_Clear();  // this is reasonably likely (especially on older versions of Python)\n+        } else {\n+            goto bad;\n+        }\n+        modulename = PyBytes_FromFormat(\"_cython_\" CYTHON_ABI \".%s\", name);\n+        if (!modulename) goto bad;\n+#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_CPYTHON\n+        module = PyImport_AddModuleObject(modulename); // borrowed\n+#else\n+        module = PyImport_AddModule(PyBytes_AsString(modulename)); // borrowed\n+#endif\n+        Py_DECREF(modulename);\n+        if (!module) goto bad;\n+        Py_INCREF(module);\n+        if (PyObject_SetAttrString(shared_abi_module, name, module)<0) goto bad;\n+        localDict = PyModule_GetDict(module); // borrowed\n+        if (!localDict) goto bad;\n+        builtins = PyEval_GetBuiltins(); // borrowed\n+        if (!builtins) goto bad;\n+        if (PyDict_SetItemString(localDict, \"__builtins__\", builtins) <0) goto bad;\n+\n+        runValue = PyRun_String(fallback_code, Py_file_input, localDict, localDict);\n+        if (!runValue) goto bad;\n+        Py_DECREF(runValue);\n+    }\n+    goto shared_cleanup;\n+\n+    bad:\n+        Py_CLEAR(module);\n+    shared_cleanup:\n+        Py_XDECREF(shared_abi_module);\n+    return module;\n+}\n+\n+///////////////////// SpecificModuleLoader.proto //////////////////////\n+//@substitute: tempita",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499355395",
            "id": 499355395,
            "line": 68,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTM5NQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 72,
            "original_position": 72,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.c",
            "position": 68,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499355395/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499355395",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499359647"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499359647"
                }
            },
            "author_association": "MEMBER",
            "body": "I'd rather see the `AnnotationNode` stored in `entry.annotation` than duplicating the fields here.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T05:59:03Z",
            "diff_hunk": "@@ -84,6 +84,7 @@ class Entry(object):\n     # type             PyrexType  Type of entity\n     # doc              string     Doc string\n     # annotation       ExprNode   PEP 484/526 annotation\n+    # pep563_annotation string    PEP563 string version of the annotation",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499359647",
            "id": 499359647,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1OTY0Nw==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 87,
            "original_position": 4,
            "original_start_line": 86,
            "path": "Cython/Compiler/Symtab.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499359647/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499359647",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499359823"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499359823"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nclass InitOrClassVar(object):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T05:59:41Z",
            "diff_hunk": "@@ -4368,6 +4374,72 @@ def same_as_resolved_type(self, other_type):\n     def error_condition(self, result_code):\n         return \"dummy\"\n \n+class InitOrClassVar:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499359823",
            "id": 499359823,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1OTgyMw==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 4377,
            "original_position": 37,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499359823/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499359823",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499360629"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499360629"
                }
            },
            "author_association": "MEMBER",
            "body": "I had to read this sentence three times in order to make it pass my parser.\r\n```suggestion\r\n    Although not really a CppClassType, it uses a template-like syntax.\r\n    So it mimics the interface to let existing code use it with minimal fuss.\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:02:32Z",
            "diff_hunk": "@@ -4368,6 +4374,72 @@ def same_as_resolved_type(self, other_type):\n     def error_condition(self, result_code):\n         return \"dummy\"\n \n+class InitOrClassVar:\n+    \"\"\"Used to help Cython interpret dataclass InitVar or ClassVar.\n+\n+    Although not really a CppClassType, it uses a template-like syntax\n+    so claims to be to allow exisiting code to use it with minimal fuss",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499360629",
            "id": 499360629,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MDYyOQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 4381,
            "original_position": 41,
            "original_start_line": 4380,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499360629/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499360629",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499361671"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499361671"
                }
            },
            "author_association": "MEMBER",
            "body": "I think these erequire context. Otherwise they'd read too generic when used in code.\r\n```suggestion\r\n    #  is_dataclass_initvar            boolean     Is a dataclass InitVar\r\n    #  is_dataclass_classvar           boolean     Is a dataclass ClassVar\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:06:19Z",
            "diff_hunk": "@@ -198,6 +198,8 @@ class PyrexType(BaseType):\n     #  is_buffer             boolean     Is buffer access type\n     #  is_pythran_expr       boolean     Is Pythran expr\n     #  is_numpy_buffer       boolean     Is Numpy array buffer\n+    #  is_initvar            boolean     Is a dataclass InitVar\n+    #  is_classvar            boolean     Is a dataclass ClassVar",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499361671",
            "id": 499361671,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MTY3MQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 202,
            "original_position": 5,
            "original_start_line": 201,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499361671/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499361671",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499363815"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499363815"
                }
            },
            "author_association": "MEMBER",
            "body": "unused?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:14:17Z",
            "diff_hunk": "@@ -790,6 +790,7 @@ def visit_CImportStatNode(self, node):\n         return node\n \n     def visit_FromCImportStatNode(self, node):\n+        extra_stats = []",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499363815",
            "id": 499363815,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MzgxNQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 793,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499363815/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499363815",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499364166"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499364166"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    'dataclasses.dataclass' : ('class', 'cclass',)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:15:22Z",
            "diff_hunk": "@@ -369,6 +373,7 @@ def normalise_encoding_name(option_name, encoding):\n     'fast_gil': ('module',),\n     'iterable_coroutine': ('module', 'function'),\n     'trashcan' : ('cclass',),\n+    'dataclass.dataclass' : ('class', 'cclass',)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499364166",
            "id": 499364166,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2NDE2Ng==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 376,
            "original_position": 15,
            "original_start_line": null,
            "path": "Cython/Compiler/Options.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499364166/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499364166",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499364447"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499364447"
                }
            },
            "author_association": "MEMBER",
            "body": "why not?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:16:25Z",
            "diff_hunk": "@@ -326,6 +326,10 @@ def normalise_encoding_name(option_name, encoding):\n     'c_string_type': one_of('bytes', 'bytearray', 'str', 'unicode'),\n     'c_string_encoding': normalise_encoding_name,\n     'trashcan': bool,\n+    'dataclasses.dataclass': Ellipsis,  # use Ellipsis as a flag not to attempt to analyse the arguments\n+                            # when the directive is applied",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499364447",
            "id": 499364447,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2NDQ0Nw==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 330,
            "original_position": 5,
            "original_start_line": 329,
            "path": "Cython/Compiler/Options.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499364447/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499364447",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499364884"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499364884"
                }
            },
            "author_association": "MEMBER",
            "body": "Did you mean \"instance attribute\" or \"class attribute\" here?\r\n```suggestion\r\n                # in a dataclass an assignment should not prevent a name becoming an instance attribute\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:18:02Z",
            "diff_hunk": "@@ -2055,7 +2064,12 @@ def analyse_target_declaration(self, env):\n             self.entry = env.lookup_here(self.name)\n         if not self.entry and self.annotation is not None:\n             # name : type = ...\n-            self.declare_from_annotation(env, as_target=True)\n+            if 'dataclasses.dataclass' in env.directives:\n+                # in a dataclass an assignment should not prevent a name becoming a class member",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499364884",
            "id": 499364884,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2NDg4NA==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 2068,
            "original_position": 29,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499364884/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499364884",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499365785"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499365785"
                }
            },
            "author_association": "MEMBER",
            "body": "Just assign `is_dataclass = 'dataclasses.dataclass' in env.directives` and pass that to `as_target`. No need to duplicate the calls. (The more code I have to read in order to spot the difference, the more I get distracted while trying to understand the code. Don't make me think, just give it a name.)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:21:03Z",
            "diff_hunk": "@@ -2055,7 +2064,12 @@ def analyse_target_declaration(self, env):\n             self.entry = env.lookup_here(self.name)\n         if not self.entry and self.annotation is not None:\n             # name : type = ...\n-            self.declare_from_annotation(env, as_target=True)\n+            if 'dataclasses.dataclass' in env.directives:\n+                # in a dataclass an assignment should not prevent a name becoming a class member\n+                # hence \"as_target = False\"\n+                self.declare_from_annotation(env, as_target=False)\n+            else:\n+                self.declare_from_annotation(env, as_target=True)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499365785",
            "id": 499365785,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2NTc4NQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 2072,
            "original_position": 33,
            "original_start_line": 2069,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499365785/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499365785",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499368461"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499368461"
                }
            },
            "author_association": "MEMBER",
            "body": "I'd rather have this as an explicit marker that makes the property generation optional or sets it as internally requested.\r\n\r\nOTOH, we have a type here already, don't we? Why not look at it? Even if the decision is non-trivial, it can be taken by the type itself.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:29:19Z",
            "diff_hunk": "@@ -2008,11 +2008,20 @@ def declare_from_annotation(self, env, as_target=False):\n                           \"'%s' cannot be specialized since its type is not a fused argument to this function\" %\n                           self.name)\n                     atype = error_type\n-\n-            entry = self.entry = env.declare_var(name, atype, self.pos, is_cdef=not as_target)\n+            kwds = {}\n+            if 'dataclasses.dataclass' in env.directives:\n+                # handle \"frozen\" directive - full inspection of the dataclass directives happens\n+                # in Dataclass.py\n+                frozen_directive = env.directives['dataclasses.dataclass']\n+                if frozen_directive:\n+                    frozen_directive = frozen_directive[1].get('frozen', None)\n+                is_frozen = frozen_directive and frozen_directive.is_literal and frozen_directive.value\n+                kwds = {'visibility': 'readonly?' if is_frozen else 'public?'}",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499368461",
            "id": 499368461,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2ODQ2MQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 2019,
            "original_position": 14,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499368461/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499368461",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499372354"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499372354"
                }
            },
            "author_association": "MEMBER",
            "body": "`setup` is a noun. This function does something.\r\n```suggestion\r\ndef _set_up_dataclass_fields(node, fields, dataclass_module):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:41:21Z",
            "diff_hunk": "@@ -0,0 +1,629 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode_and_utilcode(pos, name, py_code):\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+                                                        context={'name': name, 'py_code': py_code})\n+    return (ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_%s_Module\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[]),\n+            loader_utilitycode)\n+\n+def make_dataclasses_module_callnode_and_utilcode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    return _make_module_callnode_and_utilcode(pos, \"dataclasses\", python_utility_code.as_c_string_literal())\n+def make_dataclasses_module_callnode(pos):\n+    return make_dataclasses_module_callnode_and_utilcode(pos)[0]\n+def make_typing_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Typing_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    return _make_module_callnode_and_utilcode(pos, \"typing\", python_utility_code.as_c_string_literal())[0]\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(make_dataclasses_module_callnode_and_utilcode(None)[1])\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    dataclass_scope = make_common_utilitycode(node.scope)\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _setup_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    RemoveDontAnalyseDeclarations()(comp_directives)\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.pep563_annotation\n+        if annotation:\n+            annotation = u\": %s\" % annotation\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:\n+                            pass  # not convinced a failure means much\n+                    if nn.entry:\n+                        return nn.analyse_types(env)\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.pep563_annotation\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+class DontAnalyseDeclarationsNode(ExprNodes.ExprNode):\n+    # arg    ExprNode\n+    #\n+    # This is designed to wrap stuff that's already been analysed\n+    # so that lambdas aren't redeclared for example\n+    # and then immediately be replaced\n+\n+    subexprs = []\n+\n+    def analyse_declarations(self, env):\n+        return\n+\n+class RemoveDontAnalyseDeclarations(VisitorTransform):\n+    def visit_DontAnalyseDeclarationsNode(self, node):\n+        return node.arg\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string\n+    subexprs = ['arg']\n+\n+    def __init__(self, pos, arg):\n+        super(FieldsValueNode, self).__init__(pos, arg=arg)\n+\n+    def analyse_types(self, env):\n+        self.arg.analyse_types(env)\n+        self.type = self.arg.type\n+        return self\n+\n+    def coerce_to_pyobject(self, env):\n+        if self.arg.type.can_coerce_to_pyobject(env):\n+            return self.arg.coerce_to_pyobject(env)\n+        else:\n+            # A string representation of the code that gave the field seems like a reasonable\n+            # fallback. This'll mostly happen for \"default\" and \"default_factory\" where the\n+            # type may be a C-type that can't be converted to Python.\n+            return self._make_string()\n+\n+    def _make_string(self):\n+        from .AutoDocTransforms import AnnotationWriter\n+        writer = AnnotationWriter(description=\"Dataclass field\")\n+        string = writer.write(self.arg)\n+        return ExprNodes.StringNode(self.pos, value=EncodedString(string))\n+\n+    def generate_evaluation_code(self, code):\n+        return self.arg.generate_evaluation_code(code)\n+\n+\n+def _setup_dataclass_fields(node, fields, dataclass_module):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499372354",
            "id": 499372354,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3MjM1NA==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 546,
            "original_position": 546,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499372354/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499372354",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499373073"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499373073"
                }
            },
            "author_association": "MEMBER",
            "body": "There must be a better way to do this. If it's about lambdas, then why can't they detect themselves whether they actually need to do something or not? Or maybe the transformation that uses this runs too late and should be executed before (or as part of) the analysis?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:43:25Z",
            "diff_hunk": "@@ -0,0 +1,629 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode_and_utilcode(pos, name, py_code):\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+                                                        context={'name': name, 'py_code': py_code})\n+    return (ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_%s_Module\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[]),\n+            loader_utilitycode)\n+\n+def make_dataclasses_module_callnode_and_utilcode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    return _make_module_callnode_and_utilcode(pos, \"dataclasses\", python_utility_code.as_c_string_literal())\n+def make_dataclasses_module_callnode(pos):\n+    return make_dataclasses_module_callnode_and_utilcode(pos)[0]\n+def make_typing_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Typing_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    return _make_module_callnode_and_utilcode(pos, \"typing\", python_utility_code.as_c_string_literal())[0]\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(make_dataclasses_module_callnode_and_utilcode(None)[1])\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    dataclass_scope = make_common_utilitycode(node.scope)\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _setup_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    RemoveDontAnalyseDeclarations()(comp_directives)\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.pep563_annotation\n+        if annotation:\n+            annotation = u\": %s\" % annotation\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:\n+                            pass  # not convinced a failure means much\n+                    if nn.entry:\n+                        return nn.analyse_types(env)\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.pep563_annotation\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+class DontAnalyseDeclarationsNode(ExprNodes.ExprNode):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499373073",
            "id": 499373073,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3MzA3Mw==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 493,
            "original_position": 493,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499373073/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499373073",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499375279"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499375279"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    class Field(object):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T06:49:29Z",
            "diff_hunk": "@@ -0,0 +1,629 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode_and_utilcode(pos, name, py_code):\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+                                                        context={'name': name, 'py_code': py_code})\n+    return (ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_%s_Module\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[]),\n+            loader_utilitycode)\n+\n+def make_dataclasses_module_callnode_and_utilcode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    return _make_module_callnode_and_utilcode(pos, \"dataclasses\", python_utility_code.as_c_string_literal())\n+def make_dataclasses_module_callnode(pos):\n+    return make_dataclasses_module_callnode_and_utilcode(pos)[0]\n+def make_typing_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Typing_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    return _make_module_callnode_and_utilcode(pos, \"typing\", python_utility_code.as_c_string_literal())[0]\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(make_dataclasses_module_callnode_and_utilcode(None)[1])\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499375279",
            "id": 499375279,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NTI3OQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 82,
            "original_position": 82,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 485691787,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499375279/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499375279",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r499792776"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/499792776"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I definitely agree that making our own copies of these is awkward. It needs some mechanism to track these attributes (i.e. how do we know that a name `ClassVar` comes from the dataclass module) which I don't think currently exists. It might be useful infrastructure though for dealing with things like the `typing` module.\r\n\r\n> Basically, if you use this feature in .pyx files, then the fallbacks aren't really needed for the compile time declarations. If you use it in .py files, then you'll need a suitable Python version anyway, and still don't need the fallbacks.\r\n\r\nI can see the value in not trying to provide fallbacks. For something like:\r\n\r\n```\r\n# some_py_file.py\r\nimport cython\r\nimport dataclasses\r\n\r\n@cython.cclass\r\n@cython.dataclass\r\nclass C:\r\n  d: dataclasses.InitVar[double] = 5\r\n```\r\n\r\nthe `import dataclasses` line would still be executable and still fail on older versions of Python, even if Cython interpreted the rest correctly. I don't really know how to deal with that.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-05T18:32:15Z",
            "diff_hunk": "@@ -0,0 +1,15 @@\n+cimport cython\n+\n+@cython.dataclasses.dataclass\n+cdef class MyDataclass:\n+    # fields can be declared using annotations\n+    a: cython.int = 0\n+    b: double = cython.dataclasses.field(default_factory = lambda: 10, repr=False)\n+\n+    # fields can also be declared using `cdef`:\n+    cdef str c\n+    c = \"hello\"  # assignment of default value on a separate line\n+\n+    # cython equivalents to InitVar and typing.ClassVar also work\n+    d: cython.dataclasses.InitVar[double] = 5\n+    e: cython.typing.ClassVar[list] = []",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r499792776",
            "id": 499792776,
            "in_reply_to_id": 499352761,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5Mjc3Ng==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": 13,
            "path": "docs/examples/userguide/extension_types/dataclass.pyx",
            "position": null,
            "pull_request_review_id": 502316244,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/499792776/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/499792776",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r502886930"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/502886930"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I won't take this exact suggestion but I'll make a similar change - `classvar` is actually from `typing` instead.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-11T08:56:32Z",
            "diff_hunk": "@@ -198,6 +198,8 @@ class PyrexType(BaseType):\n     #  is_buffer             boolean     Is buffer access type\n     #  is_pythran_expr       boolean     Is Pythran expr\n     #  is_numpy_buffer       boolean     Is Numpy array buffer\n+    #  is_initvar            boolean     Is a dataclass InitVar\n+    #  is_classvar            boolean     Is a dataclass ClassVar",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r502886930",
            "id": 502886930,
            "in_reply_to_id": 499361671,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg4NjkzMA==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 202,
            "original_position": 5,
            "original_start_line": 201,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 506158547,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/502886930/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/502886930",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r502887205"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/502887205"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Because `ClassVar` comes from typing rather than `dataclasses` so I was using the same mechanism to handle both modules.\r\n\r\nIt's possible it may not be necessary though. Not sure yet.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-10-11T08:59:03Z",
            "diff_hunk": "@@ -0,0 +1,82 @@\n+///////////////////// ModuleLoader.proto //////////////////////////\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code); /* proto */\n+\n+//////////////////// ModuleLoader ///////////////////////\n+//@requires: CommonStructures.c::FetchSharedCythonModule\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code) {\n+    // In supporting dataclasses we want to be able to use directives like:\n+    //  cython.dataclasses.dataclass, cython.dataclasses.field, cython.dataclasses.InitVar\n+    //   (based on the Standard Library dataclasses module)\n+    //  cython.typing.ClassVar (based on the standard library tying module)\n+    // These are processed efficiently by Cython as much as possible, but if they are treated\n+    // as a Python object then the objects from the standard library module should be substituted.\n+    // If those objects aren't available (due to Python version) then a simple fallback is substituted\n+    // instead, which largely just fails with a not-implemented error.\n+    //\n+    // The fallbacks are placed in the \"shared abi module\" as a convenient internal place to\n+    // store them\n+\n+    PyObject *shared_abi_module = 0, *module = 0;\n+\n+    shared_abi_module = __Pyx_FetchSharedCythonABIModule();\n+    if (!shared_abi_module) return NULL;\n+\n+    if (PyObject_HasAttrString(shared_abi_module, name)) {\n+        PyObject* result = PyObject_GetAttrString(shared_abi_module, name);\n+        Py_DECREF(shared_abi_module);\n+        return result;\n+    }\n+\n+    // the best and simplest case is simply to defer to the standard library (if available)\n+    module = PyImport_ImportModule(name);\n+    if (!module) {\n+        PyObject *localDict, *runValue, *builtins, *modulename;\n+        if (PyErr_ExceptionMatches(PyExc_ImportError)) {\n+            PyErr_Clear();  // this is reasonably likely (especially on older versions of Python)\n+        } else {\n+            goto bad;\n+        }\n+        modulename = PyBytes_FromFormat(\"_cython_\" CYTHON_ABI \".%s\", name);\n+        if (!modulename) goto bad;\n+#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_CPYTHON\n+        module = PyImport_AddModuleObject(modulename); // borrowed\n+#else\n+        module = PyImport_AddModule(PyBytes_AsString(modulename)); // borrowed\n+#endif\n+        Py_DECREF(modulename);\n+        if (!module) goto bad;\n+        Py_INCREF(module);\n+        if (PyObject_SetAttrString(shared_abi_module, name, module)<0) goto bad;\n+        localDict = PyModule_GetDict(module); // borrowed\n+        if (!localDict) goto bad;\n+        builtins = PyEval_GetBuiltins(); // borrowed\n+        if (!builtins) goto bad;\n+        if (PyDict_SetItemString(localDict, \"__builtins__\", builtins) <0) goto bad;\n+\n+        runValue = PyRun_String(fallback_code, Py_file_input, localDict, localDict);\n+        if (!runValue) goto bad;\n+        Py_DECREF(runValue);\n+    }\n+    goto shared_cleanup;\n+\n+    bad:\n+        Py_CLEAR(module);\n+    shared_cleanup:\n+        Py_XDECREF(shared_abi_module);\n+    return module;\n+}\n+\n+///////////////////// SpecificModuleLoader.proto //////////////////////\n+//@substitute: tempita",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r502887205",
            "id": 502887205,
            "in_reply_to_id": 499355395,
            "line": 68,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg4NzIwNQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 72,
            "original_position": 72,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.c",
            "position": 68,
            "pull_request_review_id": 506158547,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/502887205/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/502887205",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r546410153"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/546410153"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Right - with the current version of changes based on https://github.com/cython/cython/pull/3910 we don't need these any more.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-12-20T18:08:51Z",
            "diff_hunk": "@@ -0,0 +1,15 @@\n+cimport cython\n+\n+@cython.dataclasses.dataclass\n+cdef class MyDataclass:\n+    # fields can be declared using annotations\n+    a: cython.int = 0\n+    b: double = cython.dataclasses.field(default_factory = lambda: 10, repr=False)\n+\n+    # fields can also be declared using `cdef`:\n+    cdef str c\n+    c = \"hello\"  # assignment of default value on a separate line\n+\n+    # cython equivalents to InitVar and typing.ClassVar also work\n+    d: cython.dataclasses.InitVar[double] = 5\n+    e: cython.typing.ClassVar[list] = []",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r546410153",
            "id": 546410153,
            "in_reply_to_id": 499352761,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxMDE1Mw==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": 13,
            "path": "docs/examples/userguide/extension_types/dataclass.pyx",
            "position": null,
            "pull_request_review_id": 556039289,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/546410153/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/546410153",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r549092067"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/549092067"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Comment is updated slightly to clarify the reasoning.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-12-27T09:59:44Z",
            "diff_hunk": "@@ -326,6 +326,10 @@ def normalise_encoding_name(option_name, encoding):\n     'c_string_type': one_of('bytes', 'bytearray', 'str', 'unicode'),\n     'c_string_encoding': normalise_encoding_name,\n     'trashcan': bool,\n+    'dataclasses.dataclass': Ellipsis,  # use Ellipsis as a flag not to attempt to analyse the arguments\n+                            # when the directive is applied",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r549092067",
            "id": 549092067,
            "in_reply_to_id": 499364447,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA5MjA2Nw==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 330,
            "original_position": 5,
            "original_start_line": 329,
            "path": "Cython/Compiler/Options.py",
            "position": null,
            "pull_request_review_id": 558916859,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/549092067/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/549092067",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r549092096"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/549092096"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Not exactly what you suggested, but I think it gets simplified a lot by making the decision here in ExprNodes (since we have all the information needed).",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-12-27T10:00:06Z",
            "diff_hunk": "@@ -2008,11 +2008,20 @@ def declare_from_annotation(self, env, as_target=False):\n                           \"'%s' cannot be specialized since its type is not a fused argument to this function\" %\n                           self.name)\n                     atype = error_type\n-\n-            entry = self.entry = env.declare_var(name, atype, self.pos, is_cdef=not as_target)\n+            kwds = {}\n+            if 'dataclasses.dataclass' in env.directives:\n+                # handle \"frozen\" directive - full inspection of the dataclass directives happens\n+                # in Dataclass.py\n+                frozen_directive = env.directives['dataclasses.dataclass']\n+                if frozen_directive:\n+                    frozen_directive = frozen_directive[1].get('frozen', None)\n+                is_frozen = frozen_directive and frozen_directive.is_literal and frozen_directive.value\n+                kwds = {'visibility': 'readonly?' if is_frozen else 'public?'}",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r549092096",
            "id": 549092096,
            "in_reply_to_id": 499368461,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA5MjA5Ng==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 2019,
            "original_position": 14,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 558916883,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/549092096/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/549092096",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r549092125"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/549092125"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I've added a guard to allow analyse_declarations be run twice on lambdas and generator expressions. I don't think it's possible to move the dataclass generation any earlier - it relies on the analyse_declarations stage having been run so that it know the types of things",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2020-12-27T10:00:24Z",
            "diff_hunk": "@@ -0,0 +1,629 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode_and_utilcode(pos, name, py_code):\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+                                                        context={'name': name, 'py_code': py_code})\n+    return (ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_%s_Module\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[]),\n+            loader_utilitycode)\n+\n+def make_dataclasses_module_callnode_and_utilcode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    return _make_module_callnode_and_utilcode(pos, \"dataclasses\", python_utility_code.as_c_string_literal())\n+def make_dataclasses_module_callnode(pos):\n+    return make_dataclasses_module_callnode_and_utilcode(pos)[0]\n+def make_typing_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Typing_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    return _make_module_callnode_and_utilcode(pos, \"typing\", python_utility_code.as_c_string_literal())[0]\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(make_dataclasses_module_callnode_and_utilcode(None)[1])\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    dataclass_scope = make_common_utilitycode(node.scope)\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _setup_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    RemoveDontAnalyseDeclarations()(comp_directives)\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.pep563_annotation\n+        if annotation:\n+            annotation = u\": %s\" % annotation\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:\n+                            pass  # not convinced a failure means much\n+                    if nn.entry:\n+                        return nn.analyse_types(env)\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.pep563_annotation\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+class DontAnalyseDeclarationsNode(ExprNodes.ExprNode):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r549092125",
            "id": 549092125,
            "in_reply_to_id": 499373073,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA5MjEyNQ==",
            "original_commit_id": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "original_line": 493,
            "original_position": 493,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 558916899,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/549092125/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/549092125",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579708333"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579708333"
                }
            },
            "author_association": "MEMBER",
            "body": "This import seems unused now.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:00:30Z",
            "diff_hunk": "@@ -1,6 +1,6 @@\n from __future__ import absolute_import\n \n-from .Symtab import ModuleScope\n+from .Symtab import ModuleScope, Entry",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579708333",
            "id": 579708333,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcwODMzMw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 3,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579708333/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579708333",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579708532"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579708532"
                }
            },
            "author_association": "MEMBER",
            "body": "Should be an `EncodedString`, judging by its usage. Same for the type names below, etc.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:02:53Z",
            "diff_hunk": "@@ -171,3 +181,45 @@ def load_testscope_utility(cy_util_name, **kwargs):\n                                      test_cython_utility_dep])\n \n cythonview_testscope_utility_code = load_testscope_utility(\"View.TestScope\")\n+\n+_known_module_scopes = {}\n+\n+def get_known_python_import(qualified_name):\n+    # I don't think this is in the right place, but it isn't clear where it should be\n+\n+    qualified_name = qualified_name.split(\".\")\n+    module_name = qualified_name[0]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579708532",
            "id": 579708532,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcwODUzMg==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 191,
            "original_position": 54,
            "original_start_line": null,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579708532/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579708532",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579708717"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579708717"
                }
            },
            "author_association": "MEMBER",
            "body": "Inconsistent indentation of the trailing lines. One indentation level should be 4 spaces.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:05:13Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579708717",
            "id": 579708717,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcwODcxNw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 23,
            "original_position": 23,
            "original_start_line": 18,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579708717/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579708717",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579709038"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579709038"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nclass _MISSING_TYPE(object):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:07:15Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579709038",
            "id": 579709038,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcwOTAzOA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 59,
            "original_position": 59,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579709038/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579709038",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579709424"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579709424"
                }
            },
            "author_association": "MEMBER",
            "body": "Does this have to be a nested class?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:09:47Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579709424",
            "id": 579709424,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcwOTQyNA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 68,
            "original_position": 68,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579709424/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579709424",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579709964"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579709964"
                }
            },
            "author_association": "MEMBER",
            "body": "Isn't there a specific exception to catch here? A bare `except` seems rather dangerous.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:14:53Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579709964",
            "id": 579709964,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcwOTk2NA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 466,
            "original_position": 466,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579709964/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579709964",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579710259"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579710259"
                }
            },
            "author_association": "MEMBER",
            "body": "Weird indentation.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:17:24Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579710259",
            "id": 579710259,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMDI1OQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 147,
            "original_position": 147,
            "original_start_line": 145,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579710259/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579710259",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579710599"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579710599"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:20:04Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579710599",
            "id": 579710599,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMDU5OQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 214,
            "original_position": 214,
            "original_start_line": 213,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579710599/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579710599",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579710637"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579710637"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        directives=node.scope.directives.copy(),\r\n        body=stats)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:20:38Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579710637",
            "id": 579710637,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMDYzNw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 223,
            "original_position": 223,
            "original_start_line": 222,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579710637/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579710637",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579710742"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579710742"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    has_default_factory = ExprNodes.AttributeNode(node.pos,\r\n        obj=dataclass_module,\r\n        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:21:48Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579710742",
            "id": 579710742,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMDc0Mg==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 248,
            "original_position": 248,
            "original_start_line": 246,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579710742/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579710742",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579712144"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579712144"
                }
            },
            "author_association": "MEMBER",
            "body": "Not sure if it's an issue, but it might be more efficient to generate all Cython code and then call `TreeFragment` once. Extracting the method nodes by their name seems easy enough then.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:36:11Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579712144",
            "id": 579712144,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMjE0NA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 339,
            "original_position": 339,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712144/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712144",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579712309"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579712309"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n            return ExprNodes.RawCNameExprNode(\r\n                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:37:34Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579712309",
            "id": 579712309,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMjMwOQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 448,
            "original_position": 448,
            "original_start_line": 447,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712309/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712309",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579712438"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579712438"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:38:38Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579712438",
            "id": 579712438,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMjQzOA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 455,
            "original_position": 455,
            "original_start_line": 454,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712438/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712438",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579712743"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579712743"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n            module_field_name = global_scope.mangle(\r\n                global_scope.mangle(Naming.dataclass_field_default_cname, node.class_name),\r\n                name)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:41:24Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:\n+                            pass  # not convinced a failure means much\n+                    if nn.entry:\n+                        return nn.analyse_types(env)\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.annotation.string.value if self.entry.annotation else None\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string\n+    subexprs = ['arg']\n+\n+    def __init__(self, pos, arg):\n+        super(FieldsValueNode, self).__init__(pos, arg=arg)\n+\n+    def analyse_types(self, env):\n+        self.arg.analyse_types(env)\n+        self.type = self.arg.type\n+        return self\n+\n+    def coerce_to_pyobject(self, env):\n+        if self.arg.type.can_coerce_to_pyobject(env):\n+            return self.arg.coerce_to_pyobject(env)\n+        else:\n+            # A string representation of the code that gave the field seems like a reasonable\n+            # fallback. This'll mostly happen for \"default\" and \"default_factory\" where the\n+            # type may be a C-type that can't be converted to Python.\n+            return self._make_string()\n+\n+    def _make_string(self):\n+        from .AutoDocTransforms import AnnotationWriter\n+        writer = AnnotationWriter(description=\"Dataclass field\")\n+        string = writer.write(self.arg)\n+        return ExprNodes.StringNode(self.pos, value=EncodedString(string))\n+\n+    def generate_evaluation_code(self, code):\n+        return self.arg.generate_evaluation_code(code)\n+\n+\n+def _set_up_dataclass_fields(node, fields, dataclass_module):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode,\n+                            CloneNode)\n+\n+    # For defaults and default_factories containing things like lambda,\n+    # they're already declared in the class scope, and it creates a big\n+    # problem if multiple copies are floating around in both the __init__\n+    # function, and in the __dataclass_fields__ structure.\n+    # Therefore, create module-level constants holding these values and\n+    # pass those around instead\n+    variables_assignment_stats = []\n+    for name, field in fields.items():\n+        if field.private:\n+            continue  # doesn't appear in the public interface\n+        for attrname in [ \"default\", \"default_factory\" ]:\n+            f_def = getattr(field, attrname)\n+            if f_def is MISSING or f_def.is_literal or f_def.is_name:\n+                # some simple cases where we don't need to set up\n+                # the variable as a module-level constant\n+                continue\n+            global_scope = node.scope.global_scope()\n+            module_field_name = global_scope.mangle(global_scope.mangle(\n+                                    Naming.dataclass_field_default_cname,\n+                                    node.class_name), name)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579712743",
            "id": 579712743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMjc0Mw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 535,
            "original_position": 535,
            "original_start_line": 533,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712743/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712743",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579712943"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579712943"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        \"\"\"\r\n        Gets the module.path that this node was imported from.\r\n\r\n        Many nodes do not have one, or it is ambiguous, in which case\r\n        this function returns a false value.\r\n        \"\"\"\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:43:49Z",
            "diff_hunk": "@@ -1156,6 +1156,14 @@ def from_node(cls, node, **kwargs):\n                 kwargs[attr_name] = value\n         return cls(node.pos, **kwargs)\n \n+    def get_unambiguous_import_path(self):\n+        \"\"\"\n+        Gets the module.path that this node was imported from\n+\n+        Many nodes do not have one, or it is not unambiguous, in which case\n+        this function returns a false value\"\"\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579712943",
            "id": 579712943,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMjk0Mw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 1164,
            "original_position": 9,
            "original_start_line": 1160,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712943/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579712943",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579713559"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579713559"
                }
            },
            "author_association": "MEMBER",
            "body": "This seems a bit magic. The naming is misleading at first, and then it's unclear what `frozen_directive[1]` is doing, exactly. Could this be worth a helper function, e.g. `get_dataclass_option(env, 'frozen')`, returning either `.value` or `None`, or so. Probably worth looking at other usages first, if any.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:49:13Z",
            "diff_hunk": "@@ -2008,13 +2016,24 @@ def declare_from_annotation(self, env, as_target=False):\n                           \"'%s' cannot be specialized since its type is not a fused argument to this function\" %\n                           self.name)\n                     atype = error_type\n+            kwds = {}\n+            if 'dataclasses.dataclass' in env.directives:\n+                # handle \"frozen\" directive - full inspection of the dataclass directives happens\n+                # in Dataclass.py\n+                frozen_directive = env.directives['dataclasses.dataclass']\n+                if frozen_directive:\n+                    frozen_directive = frozen_directive[1].get('frozen', None)\n+                is_frozen = frozen_directive and frozen_directive.is_literal and frozen_directive.value",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579713559",
            "id": 579713559,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxMzU1OQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2026,
            "original_position": 26,
            "original_start_line": 2023,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579713559/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579713559",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579714009"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579714009"
                }
            },
            "author_association": "MEMBER",
            "body": "Why not store the `visibility` directly? This seems unnecessarily complex.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:53:41Z",
            "diff_hunk": "@@ -2008,13 +2016,24 @@ def declare_from_annotation(self, env, as_target=False):\n                           \"'%s' cannot be specialized since its type is not a fused argument to this function\" %\n                           self.name)\n                     atype = error_type\n+            kwds = {}",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579714009",
            "id": 579714009,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNDAwOQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2019,
            "original_position": 19,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714009/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714009",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579714146"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579714146"
                }
            },
            "author_association": "MEMBER",
            "body": "I have no idea what this means. What is an \"unambiguous import path\"? What would make it ambiguous? (I'm not just referring to the missing `is_…`, it feels like there might be more unclear about this name.)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:55:24Z",
            "diff_hunk": "@@ -2058,9 +2087,14 @@ def analyse_as_extension_type(self, env):\n     def analyse_target_declaration(self, env):\n         if not self.entry:\n             self.entry = env.lookup_here(self.name)\n+        if self.entry:\n+            self.entry.unambiguous_import_path = False  # already exists somewhere and so is now ambiguous",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579714146",
            "id": 579714146,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNDE0Ng==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2091,
            "original_position": 70,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714146/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714146",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579714517"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579714517"
                }
            },
            "author_association": "MEMBER",
            "body": "This returns True/False or None, right? Not an import path?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:58:11Z",
            "diff_hunk": "@@ -2557,6 +2591,11 @@ def annotate(self, code):\n                 style, text = 'c_call', 'c function (%s)'\n             code.annotate(pos, AnnotationItem(style, text % self.type, size=len(self.name)))\n \n+    def get_unambiguous_import_path(self):\n+        if self.entry:\n+            return self.entry.unambiguous_import_path\n+        return None",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579714517",
            "id": 579714517,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNDUxNw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2597,
            "original_position": 88,
            "original_start_line": 2594,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714517/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714517",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579714630"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579714630"
                }
            },
            "author_association": "MEMBER",
            "body": "And now I'm fully confused.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:58:59Z",
            "diff_hunk": "@@ -2666,6 +2705,9 @@ def generate_result_code(self, code):\n             code.error_goto_if_null(self.result(), self.pos)))\n         self.generate_gotref(code)\n \n+    def get_unambiguous_import_path(self):\n+        return self.module_name.value",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579714630",
            "id": 579714630,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNDYzMA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2709,
            "original_position": 98,
            "original_start_line": 2708,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714630/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714630",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579714683"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579714683"
                }
            },
            "author_association": "MEMBER",
            "body": "This spelling makes it necessary to read twice.\r\n```suggestion\r\n            # this if-statement makes it safe to run twice\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T21:59:46Z",
            "diff_hunk": "@@ -9787,6 +9835,9 @@ class LambdaNode(InnerFunctionNode):\n     name = StringEncoding.EncodedString('<lambda>')\n \n     def analyse_declarations(self, env):\n+        if hasattr(self, \"lambda_name\"):\n+            # this if statement makes it safe to run twice",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579714683",
            "id": 579714683,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNDY4Mw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 9839,
            "original_position": 137,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714683/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714683",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579714746"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579714746"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n            # this if-statement makes it safe to run twice\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:00:05Z",
            "diff_hunk": "@@ -9816,6 +9867,9 @@ class GeneratorExpressionNode(LambdaNode):\n     binding = False\n \n     def analyse_declarations(self, env):\n+        if hasattr(self, \"genexpr_name\"):\n+            # this if statement makes it safe to run twice",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579714746",
            "id": 579714746,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNDc0Ng==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 9871,
            "original_position": 147,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714746/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714746",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579714882"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579714882"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't think we should allow setting both here.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:02:02Z",
            "diff_hunk": "@@ -952,6 +955,10 @@ def inject_type_from_annotations(self, env):\n         base_type, arg_type = annotation.analyse_type_annotation(env, assigned_value=self.default)\n         if base_type is not None:\n             self.base_type = base_type\n+        if arg_type and arg_type.is_typing_optional:\n+            self.or_none = True\n+        if arg_type and arg_type.is_pyobject:\n+            self.not_none = True",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579714882",
            "id": 579714882,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNDg4Mg==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 961,
            "original_position": 35,
            "original_start_line": 958,
            "path": "Cython/Compiler/Nodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714882/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714882",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579714933"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579714933"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                if scope is None and len(self.module_path) == 1:\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:02:26Z",
            "diff_hunk": "@@ -1049,7 +1056,13 @@ def analyse(self, env, could_be_name=False):\n                     else:\n                         scope = None\n                         break\n-\n+                if scope is None and len(self.module_path)==1:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579714933",
            "id": 579714933,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNDkzMw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 1059,
            "original_position": 44,
            "original_start_line": null,
            "path": "Cython/Compiler/Nodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714933/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579714933",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579715023"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579715023"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                    # for indexed_pytype we can be a bit more flexible and pass None\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:03:43Z",
            "diff_hunk": "@@ -1172,20 +1185,23 @@ def analyse(self, env, could_be_name=False, base_type=None):\n             base_type = self.base_type_node.analyse(env)\n         if base_type.is_error: return base_type\n \n-        if base_type.is_cpp_class and base_type.is_template_type():\n+        if ((base_type.is_cpp_class and base_type.is_template_type()) or\n+                base_type.is_indexed_pytype):\n             # Templated class\n             if self.keyword_args and self.keyword_args.key_value_pairs:\n-                error(self.pos, \"c++ templates cannot take keyword arguments\")\n+                tp = \"c++ templates\" if base_type.is_cpp_class else \"indexed type\"\n+                error(self.pos, \"%s cannot take keyword arguments\" % tp)\n                 self.type = PyrexTypes.error_type\n             else:\n                 template_types = []\n                 for template_node in self.positional_args:\n                     type = template_node.analyse_as_type(env)\n-                    if type is None:\n+                    if type is None and base_type.is_cpp_class:\n                         error(template_node.pos, \"unknown type in template argument\")\n                         type = error_type\n+                    # for indexed_ed_pytype we can be a bit more flexible and pass None",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579715023",
            "id": 579715023,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNTAyMw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 1202,
            "original_position": 75,
            "original_start_line": null,
            "path": "Cython/Compiler/Nodes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579715023/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579715023",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579715292"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579715292"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                        or (isinstance(rd, ExprNodes.AttributeNode) and rd.attribute == \"dataclass\")):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:06:08Z",
            "diff_hunk": "@@ -1060,6 +1072,12 @@ def _extract_directives(self, node, scope_name):\n                 realdecs.append(dec)\n         if realdecs and (scope_name == 'cclass' or\n                          isinstance(node, (Nodes.CClassDefNode, Nodes.CVarDefNode))):\n+            for rd in realdecs:\n+                rd = rd.decorator\n+                if ((rd.is_name and rd.name == \"dataclass\")\n+                        or (isinstance(rd, ExprNodes.AttributeNode) and rd.attribute==\"dataclass\")):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579715292",
            "id": 579715292,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNTI5Mg==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 1078,
            "original_position": 67,
            "original_start_line": null,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579715292/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579715292",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579715331"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579715331"
                }
            },
            "author_association": "MEMBER",
            "body": "?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:06:37Z",
            "diff_hunk": "@@ -3080,6 +3101,12 @@ def visit_NameNode(self, node):\n \n     def visit_cython_attribute(self, node):\n         attribute = node.as_cython_attribute()\n+        #if (not attribute and node.is_name\n+        #        and node.name in [\"typing.ClassVar\", \"dataclasses.InitVar\"]  # not directives so don't get picked up correctly\n+        #        ):\n+        #    entry = self.current_env().lookup(node.name)\n+        #    if entry and getattr(entry.scope, \"is_cython_builtin\"):\n+        #        attribute = node.name",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579715331",
            "id": 579715331,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNTMzMQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 3109,
            "original_position": 92,
            "original_start_line": 3104,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579715331/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579715331",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579715373"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579715373"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                node.function = ExprNodes.AttributeNode(\r\n                    node.pos, obj=dataclass_module, attribute=EncodedString(function))\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:07:03Z",
            "diff_hunk": "@@ -3253,6 +3280,11 @@ def visit_SimpleCallNode(self, node):\n                 node.function = ExprNodes.NameNode(node.pos, name=EncodedString('set'))\n             elif function == u'staticmethod':\n                 node.function = ExprNodes.NameNode(node.pos, name=EncodedString('staticmethod'))\n+            elif function == u'dataclass':\n+                from .Dataclass import make_dataclass_module_callnode\n+                dataclass_module = make_dataclass_module_callnode(node.pos)\n+                node.function = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                               attribute=EncodedString(function))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579715373",
            "id": 579715373,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNTM3Mw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 3287,
            "original_position": 104,
            "original_start_line": 3286,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579715373/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579715373",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579716553"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579716553"
                }
            },
            "author_association": "MEMBER",
            "body": "I understand where these are coming from, but `is_typing_optional` totally reads like \"is typing optional?\", not like a reference to the `typing` module. Not sure right now what a better name would be, but this scheme also doesn't seem to scale well.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:18:11Z",
            "diff_hunk": "@@ -192,12 +192,16 @@ class PyrexType(BaseType):\n     #  is_string             boolean     Is a C char * type\n     #  is_pyunicode_ptr      boolean     Is a C PyUNICODE * type\n     #  is_cpp_string         boolean     Is a C++ std::string type\n+    #  is_indexed_pytype     boolean     Is a Python type identifier that can be indexed/\"templated\"\n     #  is_unicode_char       boolean     Is either Py_UCS4 or Py_UNICODE\n     #  is_returncode         boolean     Is used only to signal exceptions\n     #  is_error              boolean     Is the dummy error type\n     #  is_buffer             boolean     Is buffer access type\n     #  is_pythran_expr       boolean     Is Pythran expr\n     #  is_numpy_buffer       boolean     Is Numpy array buffer\n+    #  is_dataclasses_initvar        boolean     Is a dataclasses InitVar\n+    #  is_typing_classvar            boolean     Is a typing ClassVar\n+    #  is_typing_optional            boolean     Is a typing Optional",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579716553",
            "id": 579716553,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNjU1Mw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 204,
            "original_position": 13,
            "original_start_line": 202,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579716553/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579716553",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579716853"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579716853"
                }
            },
            "author_association": "MEMBER",
            "body": "Do you mean known standard library imports, maybe?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:20:44Z",
            "diff_hunk": "@@ -158,13 +158,17 @@ class Entry(object):\n     # is_fused_specialized boolean Whether this entry of a cdef or def function\n     #                              is a specialization\n     # is_cgetter       boolean    Is a c-level getter function\n+    # unambiguous_import_path     Either None (default), False (definitely can't be determined)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579716853",
            "id": 579716853,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNjg1Mw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 161,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/Symtab.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579716853/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579716853",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579716931"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579716931"
                }
            },
            "author_association": "MEMBER",
            "body": "I was considering `PyTypeSubscript` as a better name, but then realised that we are not interested in the subscript property here, but in the fact that we are building a type. So – `PythonTypingTypeConstructor`, maybe?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:21:53Z",
            "diff_hunk": "@@ -4369,6 +4379,117 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class IndexedPythonType(PyrexType):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579716931",
            "id": 579716931,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNjkzMQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 4382,
            "original_position": 63,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579716931/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579716931",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579717051"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579717051"
                }
            },
            "author_association": "MEMBER",
            "body": "Why not ban it?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:23:30Z",
            "diff_hunk": "@@ -2219,6 +2229,14 @@ def declare_var(self, name, type, pos,\n                     cname = None, visibility = 'private',\n                     api = 0, in_pxd = 0, is_cdef = 0):\n         name = self.mangle_class_private_name(name)\n+\n+        if type.is_typing_classvar:\n+            is_cdef = 0\n+\n+        if type.is_dataclasses_initvar and 'dataclass' not in self.directives:\n+            # no real reason to ban it, but it doesn't hugely make sense\n+            warning(pos, \"Use of cython.dataclasses.InitVar does not make sense outside a dataclass\")",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579717051",
            "id": 579717051,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNzA1MQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2238,
            "original_position": 65,
            "original_start_line": 2237,
            "path": "Cython/Compiler/Symtab.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717051/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717051",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579717274"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579717274"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        if (!PyErr_ExceptionMatches(PyExc_ImportError)) goto bad;\r\n        PyErr_Clear();  // this is reasonably likely (especially on older versions of Python)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:25:45Z",
            "diff_hunk": "@@ -0,0 +1,78 @@\n+///////////////////// ModuleLoader.proto //////////////////////////\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code); /* proto */\n+\n+//////////////////// ModuleLoader ///////////////////////\n+//@requires: CommonStructures.c::FetchSharedCythonModule\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code) {\n+    // In supporting dataclasses we want to be able to use directives the contents\n+    // of the standard library dataclasses module where available\n+    // If those objects aren't available (due to Python version) then a simple fallback is substituted\n+    // instead, which largely just fails with a not-implemented error.\n+    //\n+    // The fallbacks are placed in the \"shared abi module\" as a convenient internal place to\n+    // store them\n+\n+    PyObject *shared_abi_module = 0, *module = 0;\n+\n+    shared_abi_module = __Pyx_FetchSharedCythonABIModule();\n+    if (!shared_abi_module) return NULL;\n+\n+    if (PyObject_HasAttrString(shared_abi_module, name)) {\n+        PyObject* result = PyObject_GetAttrString(shared_abi_module, name);\n+        Py_DECREF(shared_abi_module);\n+        return result;\n+    }\n+\n+    // the best and simplest case is simply to defer to the standard library (if available)\n+    module = PyImport_ImportModule(name);\n+    if (!module) {\n+        PyObject *localDict, *runValue, *builtins, *modulename;\n+        if (PyErr_ExceptionMatches(PyExc_ImportError)) {\n+            PyErr_Clear();  // this is reasonably likely (especially on older versions of Python)\n+        } else {\n+            goto bad;\n+        }",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579717274",
            "id": 579717274,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNzI3NA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 36,
            "original_position": 36,
            "original_start_line": 32,
            "path": "Cython/Utility/Dataclasses.c",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717274/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717274",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579717605"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579717605"
                }
            },
            "author_association": "MEMBER",
            "body": "Isn't this duplicated code? We probably need something like this wherever we use the ABI module, right?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:28:18Z",
            "diff_hunk": "@@ -0,0 +1,78 @@\n+///////////////////// ModuleLoader.proto //////////////////////////\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code); /* proto */\n+\n+//////////////////// ModuleLoader ///////////////////////\n+//@requires: CommonStructures.c::FetchSharedCythonModule\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code) {\n+    // In supporting dataclasses we want to be able to use directives the contents\n+    // of the standard library dataclasses module where available\n+    // If those objects aren't available (due to Python version) then a simple fallback is substituted\n+    // instead, which largely just fails with a not-implemented error.\n+    //\n+    // The fallbacks are placed in the \"shared abi module\" as a convenient internal place to\n+    // store them\n+\n+    PyObject *shared_abi_module = 0, *module = 0;\n+\n+    shared_abi_module = __Pyx_FetchSharedCythonABIModule();\n+    if (!shared_abi_module) return NULL;\n+\n+    if (PyObject_HasAttrString(shared_abi_module, name)) {\n+        PyObject* result = PyObject_GetAttrString(shared_abi_module, name);\n+        Py_DECREF(shared_abi_module);\n+        return result;\n+    }\n+\n+    // the best and simplest case is simply to defer to the standard library (if available)\n+    module = PyImport_ImportModule(name);\n+    if (!module) {\n+        PyObject *localDict, *runValue, *builtins, *modulename;\n+        if (PyErr_ExceptionMatches(PyExc_ImportError)) {\n+            PyErr_Clear();  // this is reasonably likely (especially on older versions of Python)\n+        } else {\n+            goto bad;\n+        }\n+        modulename = PyBytes_FromFormat(\"_cython_\" CYTHON_ABI \".%s\", name);\n+        if (!modulename) goto bad;\n+#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_CPYTHON\n+        module = PyImport_AddModuleObject(modulename); // borrowed\n+#else\n+        module = PyImport_AddModule(PyBytes_AsString(modulename)); // borrowed\n+#endif\n+        Py_DECREF(modulename);\n+        if (!module) goto bad;\n+        Py_INCREF(module);",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579717605",
            "id": 579717605,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNzYwNQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 46,
            "original_position": 46,
            "original_start_line": 37,
            "path": "Cython/Utility/Dataclasses.c",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717605/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717605",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579717687"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579717687"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nclass _MISSING_TYPE(object):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:28:53Z",
            "diff_hunk": "@@ -0,0 +1,98 @@\n+################### Dataclasses_fallback ###############################\n+\n+# This is the fallback dataclass code if the stdlib module isn't available.\n+# It defines enough of the support types to be used with cdef classes\n+# and to fail if used on regular types.\n+\n+# (Intended to be included as py code - not compiled)\n+\n+from collections import namedtuple\n+try:\n+    from types import MappingProxyType\n+except ImportError:\n+    # mutable fallback if unavailable\n+    MappingProxyType = lambda x: x\n+\n+class _MISSING_TYPE:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579717687",
            "id": 579717687,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNzY4Nw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 16,
            "original_position": 16,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717687/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717687",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579717882"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579717882"
                }
            },
            "author_association": "MEMBER",
            "body": "`typing` is older than `dataclasses`, and thus more likely to exist.\r\n```suggestion\r\n    import typing\r\n    import dataclasses\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:31:11Z",
            "diff_hunk": "@@ -0,0 +1,20 @@\n+cimport cython\n+try:\n+    import dataclasses\n+    import typing",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579717882",
            "id": 579717882,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxNzg4Mg==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 4,
            "original_position": 4,
            "original_start_line": 3,
            "path": "docs/examples/userguide/extension_types/dataclass.pyx",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717882/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579717882",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579718132"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579718132"
                }
            },
            "author_association": "MEMBER",
            "body": "Why not `except ImportError:` ?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-20T22:34:43Z",
            "diff_hunk": "@@ -5,10 +5,13 @@\n import cython\n \n from typing import Dict, List, TypeVar, Optional, Generic, Tuple\n+\n try:\n+    import typing\n+    from typing import Set as _SET_\n     from typing import ClassVar\n-except ImportError:\n-    ClassVar = Optional  # fake it in Py3.5\n+except:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579718132",
            "id": 579718132,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxODEzMg==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 13,
            "original_position": 11,
            "original_start_line": null,
            "path": "tests/run/pep526_variable_annotations.py",
            "position": null,
            "pull_request_review_id": 594785037,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579718132/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579718132",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579784333"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579784333"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "It's not a name I was very happy with, so I'm happy to change it to another one. The idea is\r\n\r\n```\r\nfrom types import List\r\n```\r\n\r\nis unambiguous - `List` only ever comes from the `types` module (... there's a slight issue with monkey patching, but if we consider that then we can't reason about any of these Python imports, ever...)\r\n\r\n```\r\nfrom types import List\r\nif some_value:\r\n   List = []\r\n```\r\n\r\nis ambiguous, because there's multiple different values that `List` can be.\r\n\r\nI was using it as a sort of tri-state value, where it could be `False` (definitely ambiguous), `None` (not currently known) or <string> (e.g. `\"types.List\"`)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T10:17:11Z",
            "diff_hunk": "@@ -2058,9 +2087,14 @@ def analyse_as_extension_type(self, env):\n     def analyse_target_declaration(self, env):\n         if not self.entry:\n             self.entry = env.lookup_here(self.name)\n+        if self.entry:\n+            self.entry.unambiguous_import_path = False  # already exists somewhere and so is now ambiguous",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579784333",
            "id": 579784333,
            "in_reply_to_id": 579714146,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc4NDMzMw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2091,
            "original_position": 70,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579784333/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579784333",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579784506"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579784506"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "No, it's `False`, `None` or a string",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T10:18:00Z",
            "diff_hunk": "@@ -2557,6 +2591,11 @@ def annotate(self, code):\n                 style, text = 'c_call', 'c function (%s)'\n             code.annotate(pos, AnnotationItem(style, text % self.type, size=len(self.name)))\n \n+    def get_unambiguous_import_path(self):\n+        if self.entry:\n+            return self.entry.unambiguous_import_path\n+        return None",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579784506",
            "id": 579784506,
            "in_reply_to_id": 579714517,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc4NDUwNg==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2597,
            "original_position": 88,
            "original_start_line": 2594,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579784506/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579784506",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579786423"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579786423"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "It's like that so that the default constructor arguments (`_TrueNode`, `_FalseNode` and `_NoneNode`) can be built using `node.pos`.\r\n\r\nThere's definitely other ways of achieving this though, so i can change it if you feel strongly against it.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T10:34:59Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579786423",
            "id": 579786423,
            "in_reply_to_id": 579709424,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc4NjQyMw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 68,
            "original_position": 68,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579786423/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579786423",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579789764"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579789764"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I've made a change to do this. I'm not sure it makes things clearer or not, but it may be more efficient. There's still an extra call to `TreeFragment` in `_set_up_dataclass_fields` that I'd rather not eliminate because the order is important there.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T11:03:44Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579789764",
            "id": 579789764,
            "in_reply_to_id": 579712144,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc4OTc2NA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 339,
            "original_position": 339,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579789764/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579789764",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579793750"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579793750"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think I've simplified this to get rid of it.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T11:37:26Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_dataclasses_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives = node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579793750",
            "id": 579793750,
            "in_reply_to_id": 579709964,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc5Mzc1MA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 466,
            "original_position": 466,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579793750/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579793750",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579794887"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579794887"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think this is the only one that needs handling outside Dataclass.py (thus it probably isn't worth a helper function). I've tried to clear it up with better variable names.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T11:46:55Z",
            "diff_hunk": "@@ -2008,13 +2016,24 @@ def declare_from_annotation(self, env, as_target=False):\n                           \"'%s' cannot be specialized since its type is not a fused argument to this function\" %\n                           self.name)\n                     atype = error_type\n+            kwds = {}\n+            if 'dataclasses.dataclass' in env.directives:\n+                # handle \"frozen\" directive - full inspection of the dataclass directives happens\n+                # in Dataclass.py\n+                frozen_directive = env.directives['dataclasses.dataclass']\n+                if frozen_directive:\n+                    frozen_directive = frozen_directive[1].get('frozen', None)\n+                is_frozen = frozen_directive and frozen_directive.is_literal and frozen_directive.value",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579794887",
            "id": 579794887,
            "in_reply_to_id": 579713559,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc5NDg4Nw==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2026,
            "original_position": 26,
            "original_start_line": 2023,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579794887/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579794887",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579796722"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579796722"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I don't think `PythonTypingTypeConstructor` - in more recent versions of Python you can subscript the types directly and just do `list[int]` (although this PR doesn't handle it). Therefore they not *necessarily* come from the `typing` module. I've changed it to `PythonTypeConstructor` instead.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T12:02:35Z",
            "diff_hunk": "@@ -4369,6 +4379,117 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class IndexedPythonType(PyrexType):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579796722",
            "id": 579796722,
            "in_reply_to_id": 579716931,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc5NjcyMg==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 4382,
            "original_position": 63,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579796722/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579796722",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579797165"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579797165"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Yeah I'm happy with that as a name. Provided we no-one ever tries to use this mechanism on a non-standard library module like Numpy in future",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T12:06:11Z",
            "diff_hunk": "@@ -158,13 +158,17 @@ class Entry(object):\n     # is_fused_specialized boolean Whether this entry of a cdef or def function\n     #                              is a specialization\n     # is_cgetter       boolean    Is a c-level getter function\n+    # unambiguous_import_path     Either None (default), False (definitely can't be determined)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579797165",
            "id": 579797165,
            "in_reply_to_id": 579716853,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc5NzE2NQ==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 161,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/Symtab.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579797165/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579797165",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579798060"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579798060"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I don't think so... The main difference here is that I provide a small amount of Python fallback code so that the entries in `__dataclass_fields__` always have a type. I don't think the ABI module provides something to do that.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T12:13:07Z",
            "diff_hunk": "@@ -0,0 +1,78 @@\n+///////////////////// ModuleLoader.proto //////////////////////////\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code); /* proto */\n+\n+//////////////////// ModuleLoader ///////////////////////\n+//@requires: CommonStructures.c::FetchSharedCythonModule\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code) {\n+    // In supporting dataclasses we want to be able to use directives the contents\n+    // of the standard library dataclasses module where available\n+    // If those objects aren't available (due to Python version) then a simple fallback is substituted\n+    // instead, which largely just fails with a not-implemented error.\n+    //\n+    // The fallbacks are placed in the \"shared abi module\" as a convenient internal place to\n+    // store them\n+\n+    PyObject *shared_abi_module = 0, *module = 0;\n+\n+    shared_abi_module = __Pyx_FetchSharedCythonABIModule();\n+    if (!shared_abi_module) return NULL;\n+\n+    if (PyObject_HasAttrString(shared_abi_module, name)) {\n+        PyObject* result = PyObject_GetAttrString(shared_abi_module, name);\n+        Py_DECREF(shared_abi_module);\n+        return result;\n+    }\n+\n+    // the best and simplest case is simply to defer to the standard library (if available)\n+    module = PyImport_ImportModule(name);\n+    if (!module) {\n+        PyObject *localDict, *runValue, *builtins, *modulename;\n+        if (PyErr_ExceptionMatches(PyExc_ImportError)) {\n+            PyErr_Clear();  // this is reasonably likely (especially on older versions of Python)\n+        } else {\n+            goto bad;\n+        }\n+        modulename = PyBytes_FromFormat(\"_cython_\" CYTHON_ABI \".%s\", name);\n+        if (!modulename) goto bad;\n+#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_CPYTHON\n+        module = PyImport_AddModuleObject(modulename); // borrowed\n+#else\n+        module = PyImport_AddModule(PyBytes_AsString(modulename)); // borrowed\n+#endif\n+        Py_DECREF(modulename);\n+        if (!module) goto bad;\n+        Py_INCREF(module);",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579798060",
            "id": 579798060,
            "in_reply_to_id": 579717605,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTc5ODA2MA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 46,
            "original_position": 46,
            "original_start_line": 37,
            "path": "Cython/Utility/Dataclasses.c",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579798060/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579798060",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r579800186"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/579800186"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I've replaced it with `is_special_python_type_constructor` which covers all of them, and then just done `type.name==\"typing.Optional\"`",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-02-21T12:29:45Z",
            "diff_hunk": "@@ -192,12 +192,16 @@ class PyrexType(BaseType):\n     #  is_string             boolean     Is a C char * type\n     #  is_pyunicode_ptr      boolean     Is a C PyUNICODE * type\n     #  is_cpp_string         boolean     Is a C++ std::string type\n+    #  is_indexed_pytype     boolean     Is a Python type identifier that can be indexed/\"templated\"\n     #  is_unicode_char       boolean     Is either Py_UCS4 or Py_UNICODE\n     #  is_returncode         boolean     Is used only to signal exceptions\n     #  is_error              boolean     Is the dummy error type\n     #  is_buffer             boolean     Is buffer access type\n     #  is_pythran_expr       boolean     Is Pythran expr\n     #  is_numpy_buffer       boolean     Is Numpy array buffer\n+    #  is_dataclasses_initvar        boolean     Is a dataclasses InitVar\n+    #  is_typing_classvar            boolean     Is a typing ClassVar\n+    #  is_typing_optional            boolean     Is a typing Optional",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r579800186",
            "id": 579800186,
            "in_reply_to_id": 579716553,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTgwMDE4Ng==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 204,
            "original_position": 13,
            "original_start_line": 202,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 594826479,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/579800186/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-02-21T18:11:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/579800186",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r640029823"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/640029823"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Sorry for the mess. What does PyPy print here?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-05-26T18:39:24Z",
            "diff_hunk": "@@ -195,9 +195,9 @@ cdef class TestFrozen:\n     >>> inst = TestFrozen(a=5)\n     >>> inst.a\n     5.0\n-    >>> inst.a = 2.\n+    >>> inst.a = 2.  # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n-    AttributeError: attribute 'a' of 'cdef_class_dataclass.TestFrozen' objects is not writable\n+    AttributeError: attribute 'a' of '...TestFrozen' objects is not writable",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r640029823",
            "id": 640029823,
            "line": 215,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDAyOTgyMw==",
            "original_commit_id": "67287e48cf538845fc90a2deac907917b1594600",
            "original_line": 200,
            "original_position": 8,
            "original_start_line": null,
            "path": "tests/run/cdef_class_dataclass.pyx",
            "position": 215,
            "pull_request_review_id": 669420200,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/640029823/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-05-26T18:39:24Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/640029823",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/823911?v=4",
                "events_url": "https://api.github.com/users/mattip/events{/privacy}",
                "followers_url": "https://api.github.com/users/mattip/followers",
                "following_url": "https://api.github.com/users/mattip/following{/other_user}",
                "gists_url": "https://api.github.com/users/mattip/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mattip",
                "id": 823911,
                "login": "mattip",
                "node_id": "MDQ6VXNlcjgyMzkxMQ==",
                "organizations_url": "https://api.github.com/users/mattip/orgs",
                "received_events_url": "https://api.github.com/users/mattip/received_events",
                "repos_url": "https://api.github.com/users/mattip/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mattip/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mattip/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mattip"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r640034656"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/640034656"
                }
            },
            "author_association": "MEMBER",
            "body": "It's probably not just PyPy, is it? That's something that changed in Py3.10. It now puts the FQCN in exception messages.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-05-26T18:46:35Z",
            "diff_hunk": "@@ -195,9 +195,9 @@ cdef class TestFrozen:\n     >>> inst = TestFrozen(a=5)\n     >>> inst.a\n     5.0\n-    >>> inst.a = 2.\n+    >>> inst.a = 2.  # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n-    AttributeError: attribute 'a' of 'cdef_class_dataclass.TestFrozen' objects is not writable\n+    AttributeError: attribute 'a' of '...TestFrozen' objects is not writable",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r640034656",
            "id": 640034656,
            "in_reply_to_id": 640029823,
            "line": 215,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDAzNDY1Ng==",
            "original_commit_id": "67287e48cf538845fc90a2deac907917b1594600",
            "original_line": 200,
            "original_position": 8,
            "original_start_line": null,
            "path": "tests/run/cdef_class_dataclass.pyx",
            "position": 215,
            "pull_request_review_id": 669426319,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/640034656/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-05-26T18:46:36Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/640034656",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r640044041"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/640044041"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "It looks like PyPy omits the module name in this case and most other versions of Python include it. I'm not convinced this is the sort of thing where PyPy is morally obliged to match exactly (although no doubt you have your own views on this) - it only matters because doctest matches the exact text.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-05-26T19:00:38Z",
            "diff_hunk": "@@ -195,9 +195,9 @@ cdef class TestFrozen:\n     >>> inst = TestFrozen(a=5)\n     >>> inst.a\n     5.0\n-    >>> inst.a = 2.\n+    >>> inst.a = 2.  # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n-    AttributeError: attribute 'a' of 'cdef_class_dataclass.TestFrozen' objects is not writable\n+    AttributeError: attribute 'a' of '...TestFrozen' objects is not writable",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r640044041",
            "id": 640044041,
            "in_reply_to_id": 640029823,
            "line": 215,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDA0NDA0MQ==",
            "original_commit_id": "67287e48cf538845fc90a2deac907917b1594600",
            "original_line": 200,
            "original_position": 8,
            "original_start_line": null,
            "path": "tests/run/cdef_class_dataclass.pyx",
            "position": 215,
            "pull_request_review_id": 669438196,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/640044041/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-05-26T19:00:39Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/640044041",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r642059796"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/642059796"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think the rules of when the module name is expected in an error message are not clear. I remember going back and forth on this trying to get some project's (NumPy? Cython? stdlib?) tests to pass. The problem is something like pure-python classes are different from classes defined via the C-API or so.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-05-30T11:11:09Z",
            "diff_hunk": "@@ -195,9 +195,9 @@ cdef class TestFrozen:\n     >>> inst = TestFrozen(a=5)\n     >>> inst.a\n     5.0\n-    >>> inst.a = 2.\n+    >>> inst.a = 2.  # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n-    AttributeError: attribute 'a' of 'cdef_class_dataclass.TestFrozen' objects is not writable\n+    AttributeError: attribute 'a' of '...TestFrozen' objects is not writable",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r642059796",
            "id": 642059796,
            "in_reply_to_id": 640029823,
            "line": 215,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MjA1OTc5Ng==",
            "original_commit_id": "67287e48cf538845fc90a2deac907917b1594600",
            "original_line": 200,
            "original_position": 8,
            "original_start_line": null,
            "path": "tests/run/cdef_class_dataclass.pyx",
            "position": 215,
            "pull_request_review_id": 671818123,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/642059796/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-05-30T11:11:09Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/642059796",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/823911?v=4",
                "events_url": "https://api.github.com/users/mattip/events{/privacy}",
                "followers_url": "https://api.github.com/users/mattip/followers",
                "following_url": "https://api.github.com/users/mattip/following{/other_user}",
                "gists_url": "https://api.github.com/users/mattip/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mattip",
                "id": 823911,
                "login": "mattip",
                "node_id": "MDQ6VXNlcjgyMzkxMQ==",
                "organizations_url": "https://api.github.com/users/mattip/orgs",
                "received_events_url": "https://api.github.com/users/mattip/received_events",
                "repos_url": "https://api.github.com/users/mattip/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mattip/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mattip/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mattip"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r642059935"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/642059935"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "But if PyPy could improve, it can be done, just I need some direction.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-05-30T11:12:22Z",
            "diff_hunk": "@@ -195,9 +195,9 @@ cdef class TestFrozen:\n     >>> inst = TestFrozen(a=5)\n     >>> inst.a\n     5.0\n-    >>> inst.a = 2.\n+    >>> inst.a = 2.  # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n-    AttributeError: attribute 'a' of 'cdef_class_dataclass.TestFrozen' objects is not writable\n+    AttributeError: attribute 'a' of '...TestFrozen' objects is not writable",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r642059935",
            "id": 642059935,
            "in_reply_to_id": 640029823,
            "line": 215,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MjA1OTkzNQ==",
            "original_commit_id": "67287e48cf538845fc90a2deac907917b1594600",
            "original_line": 200,
            "original_position": 8,
            "original_start_line": null,
            "path": "tests/run/cdef_class_dataclass.pyx",
            "position": 215,
            "pull_request_review_id": 671818225,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/642059935/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-05-30T11:12:22Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/642059935",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/823911?v=4",
                "events_url": "https://api.github.com/users/mattip/events{/privacy}",
                "followers_url": "https://api.github.com/users/mattip/followers",
                "following_url": "https://api.github.com/users/mattip/following{/other_user}",
                "gists_url": "https://api.github.com/users/mattip/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mattip",
                "id": 823911,
                "login": "mattip",
                "node_id": "MDQ6VXNlcjgyMzkxMQ==",
                "organizations_url": "https://api.github.com/users/mattip/orgs",
                "received_events_url": "https://api.github.com/users/mattip/received_events",
                "repos_url": "https://api.github.com/users/mattip/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mattip/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mattip/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mattip"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r642062477"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/642062477"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "It looks to me like all the CPython versions from 2.7-3.10a6 produce `attribute 'attribute_name' of 'module_name.ClassName' objects is not writable`. (3.10a6 is just the highest version I have installed to test... I'm sure the current version is the same) I think in general CPython's trying to use the qualified (dotted) names everywhere, so their current behaviour is probably their future behaviour. So I think the most compatible behaviour would be for PyPy to produce the qualified/dotted name.\r\n\r\nFor the sake of this test `#doctest: +ELLIPSIS` works perfectly well and tests everything I care about. So it'll probably remain.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-05-30T11:32:46Z",
            "diff_hunk": "@@ -195,9 +195,9 @@ cdef class TestFrozen:\n     >>> inst = TestFrozen(a=5)\n     >>> inst.a\n     5.0\n-    >>> inst.a = 2.\n+    >>> inst.a = 2.  # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n-    AttributeError: attribute 'a' of 'cdef_class_dataclass.TestFrozen' objects is not writable\n+    AttributeError: attribute 'a' of '...TestFrozen' objects is not writable",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r642062477",
            "id": 642062477,
            "in_reply_to_id": 640029823,
            "line": 215,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MjA2MjQ3Nw==",
            "original_commit_id": "67287e48cf538845fc90a2deac907917b1594600",
            "original_line": 200,
            "original_position": 8,
            "original_start_line": null,
            "path": "tests/run/cdef_class_dataclass.pyx",
            "position": 215,
            "pull_request_review_id": 671820092,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/642062477/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-05-30T11:38:10Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/642062477",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r658711004"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/658711004"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It seems that a small comment will suffice\r\n```python\r\ndef get_known_standard_library_import(self):\r\n    \"\"\"returns False/None/str\"\"\"\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-06-25T12:02:58Z",
            "diff_hunk": "@@ -2557,6 +2591,11 @@ def annotate(self, code):\n                 style, text = 'c_call', 'c function (%s)'\n             code.annotate(pos, AnnotationItem(style, text % self.type, size=len(self.name)))\n \n+    def get_unambiguous_import_path(self):\n+        if self.entry:\n+            return self.entry.unambiguous_import_path\n+        return None",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r658711004",
            "id": 658711004,
            "in_reply_to_id": 579714517,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODcxMTAwNA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 2597,
            "original_position": 88,
            "original_start_line": 2594,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 692747124,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/658711004/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-06-25T12:02:58Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/658711004",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/52697657?v=4",
                "events_url": "https://api.github.com/users/0dminnimda/events{/privacy}",
                "followers_url": "https://api.github.com/users/0dminnimda/followers",
                "following_url": "https://api.github.com/users/0dminnimda/following{/other_user}",
                "gists_url": "https://api.github.com/users/0dminnimda/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/0dminnimda",
                "id": 52697657,
                "login": "0dminnimda",
                "node_id": "MDQ6VXNlcjUyNjk3NjU3",
                "organizations_url": "https://api.github.com/users/0dminnimda/orgs",
                "received_events_url": "https://api.github.com/users/0dminnimda/received_events",
                "repos_url": "https://api.github.com/users/0dminnimda/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/0dminnimda/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/0dminnimda/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/0dminnimda"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r660065037"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/660065037"
                }
            },
            "author_association": "MEMBER",
            "body": "This probably needs to be an `EncodedString`.\r\n```suggestion\r\n                        target.entry.known_standard_library_import = EncodedString(\r\n                            \"%s.%s\" % (self.module.module_name.value, name))\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-06-28T19:38:25Z",
            "diff_hunk": "@@ -8631,6 +8654,14 @@ def analyse_declarations(self, env):\n                 self.import_star = 1\n             else:\n                 target.analyse_target_declaration(env)\n+                if target.entry:\n+                    if target.get_known_standard_library_import() is None:\n+                        target.entry.known_standard_library_import = \"%s.%s\" % (\n+                            self.module.module_name.value, name)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r660065037",
            "id": 660065037,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDA2NTAzNw==",
            "original_commit_id": "31790a151f40dcea142ab423dcc341038db3cc99",
            "original_line": 8660,
            "original_position": 119,
            "original_start_line": 8659,
            "path": "Cython/Compiler/Nodes.py",
            "position": null,
            "pull_request_review_id": 694326779,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/660065037/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-06-28T19:46:19Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/660065037",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r660066930"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/660066930"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n            return StringEncoding.EncodedString(\r\n                \"%s.%s\" % (self.obj.get_known_standard_library_import(), self.attribute))\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-06-28T19:41:49Z",
            "diff_hunk": "@@ -7441,6 +7487,11 @@ def annotate(self, code):\n             style, text = 'c_attr', 'c attribute (%s)'\n         code.annotate(self.pos, AnnotationItem(style, text % self.type, size=len(self.attribute)))\n \n+    def get_known_standard_library_import(self):\n+        if self.obj.get_known_standard_library_import():\n+            return \"%s.%s\" % (self.obj.get_known_standard_library_import(), self.attribute)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r660066930",
            "id": 660066930,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDA2NjkzMA==",
            "original_commit_id": "31790a151f40dcea142ab423dcc341038db3cc99",
            "original_line": 7492,
            "original_position": 129,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 694326779,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/660066930/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-06-28T19:46:01Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/660066930",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r660068218"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/660068218"
                }
            },
            "author_association": "MEMBER",
            "body": "Empty string instead of `False`, maybe? Not sure. It feels wrong to have three different types here. I think an empty string would cover the use cases of being false and not comparing equal to other module names. Are there others?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-06-28T19:44:01Z",
            "diff_hunk": "@@ -158,13 +158,17 @@ class Entry(object):\n     # is_fused_specialized boolean Whether this entry of a cdef or def function\n     #                              is a specialization\n     # is_cgetter       boolean    Is a c-level getter function\n+    # known_standard_library_import     Either None (default), False (definitely can't be determined)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r660068218",
            "id": 660068218,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDA2ODIxOA==",
            "original_commit_id": "31790a151f40dcea142ab423dcc341038db3cc99",
            "original_line": 161,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/Symtab.py",
            "position": null,
            "pull_request_review_id": 694326779,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/660068218/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-06-28T19:45:26Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/660068218",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r660085806"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/660085806"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Yeah I think that makes sense ",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-06-28T20:13:03Z",
            "diff_hunk": "@@ -158,13 +158,17 @@ class Entry(object):\n     # is_fused_specialized boolean Whether this entry of a cdef or def function\n     #                              is a specialization\n     # is_cgetter       boolean    Is a c-level getter function\n+    # known_standard_library_import     Either None (default), False (definitely can't be determined)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r660085806",
            "id": 660085806,
            "in_reply_to_id": 660068218,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDA4NTgwNg==",
            "original_commit_id": "31790a151f40dcea142ab423dcc341038db3cc99",
            "original_line": 161,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/Symtab.py",
            "position": null,
            "pull_request_review_id": 694353881,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/660085806/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-06-28T20:13:03Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/660085806",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r661810356"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/661810356"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "```suggestion\r\n```\r\n\r\nI think this was fixed in #4248 so I'll try removing it here.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-06-30T21:04:50Z",
            "diff_hunk": "@@ -917,6 +920,10 @@ def visit_NameNode(self, node):\n             directive = self.directive_names.get(node.name)\n             if directive is not None:\n                 node.cython_attribute = directive\n+        if node.annotation:\n+            # may not seem necessary but annotation can have cython attrributes\n+            # and isn't a child attribute - TODO should this need this special case?\n+            self.visitchildren(node.annotation.expr)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r661810356",
            "id": 661810356,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTgxMDM1Ng==",
            "original_commit_id": "dc9794d1278d20dea0ac4e29b7b9e4727afa198a",
            "original_line": 926,
            "original_position": 26,
            "original_start_line": 923,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 696616862,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/661810356/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-06-30T21:04:50Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/661810356",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672067975"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672067975"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n* More comprehensive support for non-trivial ``typing`` module annotations.\r\n  Patch by David Woods.  (Github issue :issue:`3910`)\r\n\r\n* ``cdef classes`` can be made into ``dataclasses`` using the ``@cython.dataclasses.dataclass``\r\n  decorator.\r\n  Patch by David Woods.  (Github issue :issue:`3400`)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T07:51:46Z",
            "diff_hunk": "@@ -114,6 +114,12 @@ Features added\n   the module file of a wrapper after the library (source file) that it wraps,\n   which can lead to surprising errors when the file gets overwritten.\n \n+* More comprehensive support understanding ``typing`` module\n+  annotations (Github issue #3910)\n+\n+* ``cdef classes`` can be made ``dataclasses`` using the ``@cython.dataclasses.dataclass``\n+  decorator (Github issue #3400)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672067975",
            "id": 672067975,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA2Nzk3NQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 121,
            "original_position": 8,
            "original_start_line": 117,
            "path": "CHANGES.rst",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672067975/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:52Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672067975",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672068139"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672068139"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T07:52:01Z",
            "diff_hunk": "@@ -26,6 +26,7 @@ def __init__(self, context):\n                                          cname='<error>')\n             entry.in_cinclude = True\n \n+",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672068139",
            "id": 672068139,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA2ODEzOQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 29,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672068139/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:52Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672068139",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672068205"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672068205"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T07:52:07Z",
            "diff_hunk": "@@ -98,6 +99,7 @@ def populate_cython_scope(self):\n             defining = 1,\n             cname = 'PyObject_TypeCheck')\n \n+",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672068205",
            "id": 672068205,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA2ODIwNQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 102,
            "original_position": 12,
            "original_start_line": null,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672068205/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:52Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672068205",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672069505"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672069505"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        dataclassesscope = ModuleScope(dc_str, self, context=None)\r\n        self.declare_module(dc_str, dataclassesscope, pos=None).as_module = dataclassesscope\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T07:54:06Z",
            "diff_hunk": "@@ -135,9 +137,17 @@ def load_cythonscope(self):\n         for ext_type in ext_types:\n             ext_type.is_cython_builtin_type = 1\n \n-\n         # self.entries[\"array\"] = view_utility_scope.entries.pop(\"array\")\n \n+        # dataclasses scope\n+        from .StringEncoding import EncodedString\n+        dc_str = EncodedString(u'dataclasses')\n+        dataclassesscope = ModuleScope(dc_str, self, None)\n+        self.declare_module(dc_str, dataclassesscope, None).as_module = dataclassesscope",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672069505",
            "id": 672069505,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA2OTUwNQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 146,
            "original_position": 27,
            "original_start_line": 145,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672069505/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672069505",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672069762"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672069762"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        # doesn't actually have any contents\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T07:54:31Z",
            "diff_hunk": "@@ -135,9 +137,17 @@ def load_cythonscope(self):\n         for ext_type in ext_types:\n             ext_type.is_cython_builtin_type = 1\n \n-\n         # self.entries[\"array\"] = view_utility_scope.entries.pop(\"array\")\n \n+        # dataclasses scope\n+        from .StringEncoding import EncodedString\n+        dc_str = EncodedString(u'dataclasses')\n+        dataclassesscope = ModuleScope(dc_str, self, None)\n+        self.declare_module(dc_str, dataclassesscope, None).as_module = dataclassesscope\n+        dataclassesscope.is_cython_builtin = True\n+        dataclassesscope.pxd_file_loaded = True\n+        # doesn't actually any contents",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672069762",
            "id": 672069762,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA2OTc2Mg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 149,
            "original_position": 30,
            "original_start_line": null,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672069762/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672069762",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672070739"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672070739"
                }
            },
            "author_association": "MEMBER",
            "body": "`Builtin.py`, maybe?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T07:55:50Z",
            "diff_hunk": "@@ -171,3 +181,55 @@ def load_testscope_utility(cy_util_name, **kwargs):\n                                      test_cython_utility_dep])\n \n cythonview_testscope_utility_code = load_testscope_utility(\"View.TestScope\")\n+\n+_known_module_scopes = {}\n+\n+def get_known_standard_library_module(module_name):\n+    # I don't think this is in the right place, but it isn't clear where it should be",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672070739",
            "id": 672070739,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA3MDczOQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 188,
            "original_position": 43,
            "original_start_line": null,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672070739/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672070739",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672074478"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672074478"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    name_parts = qualified_name.split(\".\")\r\n    module_name = EncodedString(name_parts[0])\r\n    rest = name_parts[1:]\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:01:18Z",
            "diff_hunk": "@@ -171,3 +181,55 @@ def load_testscope_utility(cy_util_name, **kwargs):\n                                      test_cython_utility_dep])\n \n cythonview_testscope_utility_code = load_testscope_utility(\"View.TestScope\")\n+\n+_known_module_scopes = {}\n+\n+def get_known_standard_library_module(module_name):\n+    # I don't think this is in the right place, but it isn't clear where it should be\n+    from .StringEncoding import EncodedString\n+\n+    mod = _known_module_scopes.get(module_name, None)\n+    if not mod:\n+        if module_name == \"typing\":\n+            from . import Builtin\n+            mod = ModuleScope(module_name, None, None)\n+            for name, tp in [('Dict', Builtin.dict_type),\n+                             ('List', Builtin.list_type),\n+                             ('Tuple', Builtin.tuple_type),\n+                             ('Set', Builtin.set_type),\n+                             ('FrozenSet', Builtin.frozenset_type),\n+                             ('DefaultDict', Builtin.dict_type),\n+                             ('OrderedDict', Builtin.dict_type)]:\n+                name = EncodedString(name)\n+                if name == \"Tuple\":\n+                    indexed_type = PythonTupleTypeConstructor(EncodedString(\"typing.\"+name), tp)\n+                else:\n+                    indexed_type = PythonTypeConstructor(EncodedString(\"typing.\"+name), tp)\n+                entry = mod.declare_type(name, indexed_type, pos = None)\n+            for name in ['ClassVar', 'Optional']:\n+                indexed_type = SpecialPythonTypeConstructor(EncodedString(\"typing.\"+name))\n+                entry = mod.declare_type(name, indexed_type, pos = None)\n+            _known_module_scopes[module_name] = mod\n+        elif module_name == \"dataclasses\":\n+            mod = ModuleScope(module_name, None, None)\n+            indexed_type = SpecialPythonTypeConstructor(EncodedString(\"dataclasses.InitVar\"))\n+            entry = mod.declare_type(EncodedString(\"InitVar\"), indexed_type, pos = None)\n+            _known_module_scopes[module_name] = mod\n+    return mod\n+\n+\n+def get_known_standard_library_entry(qualified_name):\n+    from .StringEncoding import EncodedString\n+\n+    qualified_name = qualified_name.split(\".\")\n+    module_name = EncodedString(qualified_name[0])\n+    rest = qualified_name[1:]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672074478",
            "id": 672074478,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA3NDQ3OA==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 226,
            "original_position": 81,
            "original_start_line": 224,
            "path": "Cython/Compiler/CythonScope.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672074478/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672074478",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672075961"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672075961"
                }
            },
            "author_association": "MEMBER",
            "body": "Let's keep the imports a bit more readable. One+ line per module makes it clearer which ones are used.\r\n```suggestion\r\nfrom . import ExprNodes\r\nfrom . import Nodes\r\nfrom . import PyrexTypes\r\nfrom . import UtilNodes\r\nfrom . import Builtin\r\nfrom . import Naming\r\nfrom .Errors import error, warning\r\nfrom .Code import UtilityCode, TempitaUtilityCode\r\nfrom .Visitor import VisitorTransform\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:03:43Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672075961",
            "id": 672075961,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA3NTk2MQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 9,
            "original_position": 9,
            "original_start_line": 5,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672075961/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672075961",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672077103"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672077103"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    return ExprNodes.PythonCapiCallNode(\r\n        pos, \"__Pyx_Load_dataclasses_Module\",\r\n        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\r\n        utility_code=loader_utilitycode,\r\n        args=[],\r\n    )\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:05:34Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672077103",
            "id": 672077103,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA3NzEwMw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 23,
            "original_position": 23,
            "original_start_line": 20,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672077103/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672077103",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672079164"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672079164"
                }
            },
            "author_association": "MEMBER",
            "body": "Do we need constants here? They could just be created in the constructor at need, right?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:08:46Z",
            "diff_hunk": "@@ -0,0 +1,593 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672079164",
            "id": 672079164,
            "in_reply_to_id": 579709424,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA3OTE2NA==",
            "original_commit_id": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "original_line": 68,
            "original_position": 68,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672079164/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672079164",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672080347"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672080347"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\r\n                          % field_name)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:10:02Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672080347",
            "id": 672080347,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA4MDM0Nw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 101,
            "original_position": 101,
            "original_start_line": 100,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672080347/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672080347",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672080995"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672080995"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        def __init__(self, default=MISSING, default_factory=MISSING,\r\n                     repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\r\n                     compare=_TrueNode, metadata=_NoneNode,\r\n                     is_initvar=False):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:10:35Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672080995",
            "id": 672080995,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA4MDk5NQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": 82,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672080995/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672080995",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672081952"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672081952"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:11:25Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672081952",
            "id": 672081952,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA4MTk1Mg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 105,
            "original_position": 105,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672081952/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672081952",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672083034"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672083034"
                }
            },
            "author_association": "MEMBER",
            "body": "This class seems worth a docstring that explains its purpose. At first sight, \"removing assignments\" sounds like a really wrong thing to do. Maybe rename it to `RemoveAssignmentsToNames`?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:12:16Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672083034",
            "id": 672083034,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA4MzAzNA==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672083034/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672083034",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672086527"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672086527"
                }
            },
            "author_association": "MEMBER",
            "body": "_for_ stat_list? What does that mean?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:15:46Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672086527",
            "id": 672086527,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA4NjUyNw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 108,
            "original_position": 108,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672086527/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672086527",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672087183"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672087183"
                }
            },
            "author_association": "MEMBER",
            "body": "Difficult to spot that there's a loop starting here.\r\n```suggestion\r\n\r\n    for entry in var_entries:\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:16:43Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672087183",
            "id": 672087183,
            "line": 140,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA4NzE4Mw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 116,
            "original_position": 116,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 140,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672087183/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672087183",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672087436"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672087436"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        is_initvar = (entry.type.is_special_python_type_constructor and\r\n                      entry.type.name == \"dataclasses.InitVar\")\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:17:06Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672087436",
            "id": 672087436,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA4NzQzNg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 119,
            "original_position": 119,
            "original_start_line": 118,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672087436/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672087436",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672089305"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672089305"
                }
            },
            "author_association": "MEMBER",
            "body": "Are the keyword argument names validated anywhere? Or will this just crash if users mistype something?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:19:51Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672089305",
            "id": 672089305,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA4OTMwNQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 138,
            "original_position": 138,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672089305/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672089305",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672090281"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672090281"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                    if ((func.is_name and func.name == \"field\")\r\n                            or (func.is_attribute and func.attribute == \"field\")):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:21:12Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672090281",
            "id": 672090281,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA5MDI4MQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 144,
            "original_position": 144,
            "original_start_line": 142,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672090281/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672090281",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672092123"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672092123"
                }
            },
            "author_association": "MEMBER",
            "body": "We import `TreeFragment` at the top, which in turn imports `ExprNodes`, so there already is an import time dependency. Instead of a local import here, I'd just import `ExprNodes` globally and use it as a prefix where needed. (The same applies further down.)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:23:44Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672092123",
            "id": 672092123,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA5MjEyMw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 165,
            "original_position": 165,
            "original_start_line": 163,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672092123/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672092123",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672093985"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672093985"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    All of these \"generate_*_code\" functions return a tuple of:\r\n    - code string\r\n    - placeholder dict (often empty)\r\n    - stat list (often empty)\r\n    which can then be combined later and processed once.\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:26:20Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672093985",
            "id": 672093985,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA5Mzk4NQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 250,
            "original_position": 250,
            "original_start_line": 246,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672093985/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672093985",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672096786"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672096786"
                }
            },
            "author_association": "MEMBER",
            "body": "Looks like we could generate a conditional expression here. Less code, more efficient.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:30:01Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672096786",
            "id": 672096786,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA5Njc4Ng==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 327,
            "original_position": 327,
            "original_start_line": 321,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672096786/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672096786",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672099352"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672099352"
                }
            },
            "author_association": "MEMBER",
            "body": "Since we're doing a type check here anyway, I think an `isinstance()` call + cast would be more efficient.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:33:34Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672099352",
            "id": 672099352,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjA5OTM1Mg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 368,
            "original_position": 368,
            "original_start_line": 365,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672099352/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672099352",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672102434"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672102434"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this also how it's implemented in Python? Always test equality first?\r\nI'm asking because it feels like there's an underlying assumption that isn't spelled out here.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:37:51Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672102434",
            "id": 672102434,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjEwMjQzNA==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 376,
            "original_position": 376,
            "original_start_line": 370,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672102434/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672102434",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672106443"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672106443"
                }
            },
            "author_association": "MEMBER",
            "body": "Punctuation was invented to help with reading, probably a very long time ago. The fact that it has prevailed for millennia seems to suggest that the idea isn't entirely wrong and has its benefits. At least, we should only reject it if we find a good reason. I don't see one here.\r\n```suggestion\r\n    # some fallback provision if it turns out not to resolve to a Python object.\r\n    # Initialize with \"entry\".\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:43:25Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672106443",
            "id": 672106443,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjEwNjQ0Mw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 445,
            "original_position": 445,
            "original_start_line": 444,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672106443/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672106443",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672113720"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672113720"
                }
            },
            "author_association": "MEMBER",
            "body": "`(int, long)` was probably returned in order to allow direct usage in `isinstance()` calls (see the fused types code). Maybe `int` isn't special enough to break the rules here. Returning `int` instead would probably solve most issues, and if we need it for an `isinstance()` call, it's better to say so explicitly at that point rather than having such a weird return value. Might be worth a separate PR.\r\n\r\nRemember that we'll eventually drop Py2 support, at which point all of this becomes obsolete. We should better write our code now in a way that requires fewer changes in the future. (I.e. write it for Py3 and add quirks for Py2.)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:53:34Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672113720",
            "id": 672113720,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjExMzcyMA==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 463,
            "original_position": 463,
            "original_start_line": 460,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672113720/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672113720",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672118156"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672118156"
                }
            },
            "author_association": "MEMBER",
            "body": "Other usages seem to suggest that if there's an `annotation`, then there's an `annotation.string`. Either fix those or simplify this (and avoid jumping between different meanings for the same variable):\r\n```suggestion\r\n        if entry.annotation:\r\n            annotation = u\": %s\" % entry.annotation.string.value\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T08:59:26Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672118156",
            "id": 672118156,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjExODE1Ng==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 288,
            "original_position": 288,
            "original_start_line": 286,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672118156/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672118156",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672121764"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672121764"
                }
            },
            "author_association": "MEMBER",
            "body": "Ok. Let's keep this as it is. We'll see where that gets us.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T09:04:34Z",
            "diff_hunk": "@@ -0,0 +1,611 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def _make_module_callnode(pos, name):\n+    loader_utilitycode = UtilityCode.load_cached(\"%sModuleLoader\" % name, \"Dataclasses.c\")\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load%sModule\" % name,\n+                                PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                utility_code = loader_utilitycode,\n+                                args=[])\n+\n+def make_dataclass_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Dataclass\")\n+def make_typing_module_callnode(pos):\n+    return _make_module_callnode(pos, \"Typing\")\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+def make_common_utilitycode(scope):\n+    scope.global_scope().use_utility_code(\n+        UtilityCode.load_cached(\"DataclassModuleLoader\", \"Dataclasses.c\"))\n+\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE:\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field:\n+        # store fields as nodes so they can be used in code construction\n+        # more readily; define class inside function so default arguments\n+        # have a useful pos\n+        default = MISSING\n+        default_factory = MISSING\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = entry.type.is_initvar\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.field' must only consist of compile-time \"\n+                          \"keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type,\n+                                    Builtin.dict_type,\n+                                    Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead and see \"\n+                          \"'https://docs.python.org/library/dataclasses.html#mutable-default-values'\"\n+                          \"for more details\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+\n+    # https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    dataclass_scope = make_common_utilitycode(node.scope)\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclass_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _setup_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    init_stats = generate_init_code(kwargs['init'], node, fields)\n+    repr_stats = generate_repr_code(kwargs['repr'], node, fields)\n+    eq_stats = generate_eq_code(kwargs['eq'], node, fields)\n+    order_stats = generate_order_code(kwargs['order'], node, fields)\n+    hash_stats = generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'],\n+                       node, fields)\n+\n+    stats.stats = stats.stats + init_stats + repr_stats + eq_stats + order_stats + hash_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion done comes later\n+    # (for some reason this has to be on the class scope, so save and restore)\n+    annotation_typing = node.scope.directives['annotation_typing']\n+    node.scope.directives['annotation_typing'] = False\n+    stats.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(stats)\n+    analyse_decs_transform.exit_scope()\n+    node.scope.directives['annotation_typing'] = annotation_typing\n+\n+    RemoveDontAnalyseDeclarations()(stats)\n+\n+    node.body.stats.extend(stats.stats)\n+\n+def generate_init_code(init, node, fields):\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclass_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+                                        obj = dataclass_module,\n+                                        attribute = EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.pep563_annotation\n+        if annotation:\n+            annotation = u\": %s\" % annotation\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    return code_tree.stats\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return []  # already exists\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return []\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        stats.extend(generate_cmp_code(op, name, node, fields))\n+    return stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return []\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+    code_tree = TreeFragment(code_lines,\n+                              level='c_class', pipeline=[NormalizeTree(None)]\n+                              ).substitute({})\n+    return code_tree.stats\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(self.pos, Builtin.type_type,\n+                                                type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = py_name.split(\",\")\n+                names = [ n.strip(\"() \") for n in names ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    # try to set the entry now to prevent the user accidentally shadowing\n+                    # the name\n+                    nn.entry = env.builtin_scope().lookup(name)\n+                    if not nn.entry:\n+                        try:\n+                            nn.entry = env.declare_builtin(name, self.pos)\n+                        except:\n+                            pass  # not convinced a failure means much\n+                    if nn.entry:\n+                        return nn.analyse_types(env)\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.pep563_annotation\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+class DontAnalyseDeclarationsNode(ExprNodes.ExprNode):\n+    # arg    ExprNode\n+    #\n+    # This is designed to wrap stuff that's already been analysed\n+    # so that lambdas aren't redeclared for example\n+    # and then immediately be replaced\n+\n+    subexprs = []\n+\n+    def analyse_declarations(self, env):\n+        return\n+\n+class RemoveDontAnalyseDeclarations(VisitorTransform):\n+    def visit_DontAnalyseDeclarationsNode(self, node):\n+        return node.arg\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string\n+    subexprs = ['arg']\n+\n+    def __init__(self, pos, arg):\n+        super(FieldsValueNode, self).__init__(pos, arg=arg)\n+\n+    def analyse_types(self, env):\n+        self.arg.analyse_types(env)\n+        self.type = self.arg.type\n+        return self\n+\n+    def coerce_to_pyobject(self, env):\n+        if self.arg.type.can_coerce_to_pyobject(env):\n+            return self.arg.coerce_to_pyobject(env)\n+        else:\n+            # A string representation of the code that gave the field seems like a reasonable\n+            # fallback. This'll mostly happen for \"default\" and \"default_factory\" where the\n+            # type may be a C-type that can't be converted to Python.\n+            return self._make_string()\n+\n+    def _make_string(self):\n+        from .AutoDocTransforms import AnnotationWriter\n+        writer = AnnotationWriter(description=\"Dataclass field\")\n+        string = writer.write(self.arg)\n+        return ExprNodes.StringNode(self.pos, value=EncodedString(string))\n+\n+    def generate_evaluation_code(self, code):\n+        return self.arg.generate_evaluation_code(code)\n+\n+\n+def _setup_dataclass_fields(node, fields, dataclass_module):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode,\n+                            CloneNode)\n+\n+    # For defaults and default_factories containing things like lambda,\n+    # they're already declared in the class scope, and it creates a big\n+    # problem if multiple copies are floating around in both the __init__\n+    # function, and in the __dataclass_fields__ structure.\n+    # Therefore, create module-level constants holding these values and\n+    # pass those around instead\n+    variables_assignment_stats = []\n+    for name, field in fields.items():\n+        for attrname in [ \"default\", \"default_factory\" ]:\n+            f_def = getattr(field, attrname)\n+            if f_def is MISSING or f_def.is_literal or f_def.is_name:\n+                # some simple cases where we don't need to set up\n+                # the variable as a module-level constant\n+                continue\n+            global_scope = node.scope.global_scope()\n+            module_field_name = global_scope.mangle(global_scope.mangle(\n+                                    Naming.dataclass_field_default_cname,\n+                                    node.class_name), name)\n+            # create an entry in the global scope for this variable to live\n+            nn = NameNode(f_def.pos, name=EncodedString(module_field_name))\n+            nn.entry = global_scope.declare_var(nn.name, type=f_def.type or PyrexTypes.unspecified_type,\n+                                                pos=f_def.pos, cname=nn.name, is_cdef=1)\n+            # replace the field so that future users just receive the namenode\n+            setattr(field, attrname, nn)\n+\n+            variables_assignment_stats.append(\n+                Nodes.SingleAssignmentNode(f_def.pos,\n+                                           lhs = nn,\n+                                           rhs = DontAnalyseDeclarationsNode(f_def.pos, arg=f_def)))\n+\n+    placeholders = {}\n+    field_func = AttributeNode(node.pos, obj = dataclass_module,\n+                                    attribute=EncodedString(\"field\"))\n+    dc_fields = DictNode(node.pos, key_value_pairs=[])\n+    dc_fields_namevalue_assignments = []\n+    for name, field in fields.items():\n+        placeholder_name = \"PLACEHOLDER_%s\" % name\n+        placeholders[placeholder_name] = GetTypeNode(node.scope.entries[name])",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672121764",
            "id": 672121764,
            "in_reply_to_id": 485906541,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjEyMTc2NA==",
            "original_commit_id": "043a102296c9949e1924c783c0b0d061810d85e9",
            "original_line": 575,
            "original_position": 575,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672121764/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672121764",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672156026"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672156026"
                }
            },
            "author_association": "MEMBER",
            "body": "Seems to return a scope, not a module. Could be worth making that part of the name.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T09:52:39Z",
            "diff_hunk": "@@ -2049,6 +2071,11 @@ def analyse_as_module(self, env):\n             entry = env.lookup(self.name)\n         if entry and entry.as_module:\n             return entry.as_module\n+        if entry and entry.known_standard_library_import:\n+            from .CythonScope import get_known_standard_library_module\n+            scope = get_known_standard_library_module(entry.known_standard_library_import)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672156026",
            "id": 672156026,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE1NjAyNg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 2076,
            "original_position": 50,
            "original_start_line": 2075,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672156026/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672156026",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672156932"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672156932"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n            # In a dataclass, an assignment should not prevent a name from becoming an instance attribute.\r\n            # Hence, \"as_target = not is_dataclass\".\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T09:53:56Z",
            "diff_hunk": "@@ -2080,9 +2112,14 @@ def analyse_as_extension_type(self, env):\n     def analyse_target_declaration(self, env):\n         if not self.entry:\n             self.entry = env.lookup_here(self.name)\n+        if self.entry:\n+            self.entry.known_standard_library_import = \"\"  # already exists somewhere and so is now ambiguous\n         if not self.entry and self.annotation is not None:\n             # name : type = ...\n-            self.declare_from_annotation(env, as_target=True)\n+            is_dataclass = 'dataclasses.dataclass' in env.directives\n+            # in a dataclass an assignment should not prevent a name becoming an instance attribute\n+            # hence \"as_target = not is_dataclass\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672156932",
            "id": 672156932,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE1NjkzMg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 2121,
            "original_position": 79,
            "original_start_line": 2120,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672156932/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672156932",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672157421"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672157421"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T09:54:42Z",
            "diff_hunk": "@@ -7107,6 +7152,7 @@ def analyse_as_module(self, env):\n                 return entry.as_module\n         return None\n \n+",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672157421",
            "id": 672157421,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE1NzQyMQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 7155,
            "original_position": 119,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672157421/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672157421",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672158199"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672158199"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        module_name = self.obj.get_known_standard_library_import()\r\n        if module_name:\r\n            return StringEncoding.EncodedString(\"%s.%s\" % (module_name, self.attribute))\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T09:55:46Z",
            "diff_hunk": "@@ -7456,6 +7502,12 @@ def annotate(self, code):\n             style, text = 'c_attr', 'c attribute (%s)'\n         code.annotate(self.pos, AnnotationItem(style, text % self.type, size=len(self.attribute)))\n \n+    def get_known_standard_library_import(self):\n+        if self.obj.get_known_standard_library_import():\n+            return StringEncoding.EncodedString(\n+                \"%s.%s\" % (self.obj.get_known_standard_library_import(), self.attribute))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672158199",
            "id": 672158199,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE1ODE5OQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 7508,
            "original_position": 130,
            "original_start_line": 7506,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672158199/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672158199",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672158928"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672158928"
                }
            },
            "author_association": "MEMBER",
            "body": "… although it shouldn't run twice, obviously. :)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T09:56:47Z",
            "diff_hunk": "@@ -9826,6 +9878,9 @@ class LambdaNode(InnerFunctionNode):\n     name = StringEncoding.EncodedString('<lambda>')\n \n     def analyse_declarations(self, env):\n+        if hasattr(self, \"lambda_name\"):\n+            # this if-statement makes it safe to run twice",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672158928",
            "id": 672158928,
            "line": 9904,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE1ODkyOA==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 9882,
            "original_position": 141,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": 147,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672158928/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672158928",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672159984"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672159984"
                }
            },
            "author_association": "MEMBER",
            "body": "I heard that wood good expensive recently, but letters?\r\n```suggestion\r\ndataclass_field_default_cname = pyrex_prefix + \"dataclass_default\"\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T09:58:22Z",
            "diff_hunk": "@@ -135,6 +135,7 @@\n cython_runtime_cname   = pyrex_prefix + \"cython_runtime\"\n cyfunction_type_cname = pyrex_prefix + \"CyFunctionType\"\n fusedfunction_type_cname = pyrex_prefix + \"FusedFunctionType\"\n+dataclass_field_default_cname = pyrex_prefix + \"dataclass_dflt\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672159984",
            "id": 672159984,
            "line": 141,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE1OTk4NA==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 138,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/Naming.py",
            "position": 7,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672159984/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672159984",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672162703"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672162703"
                }
            },
            "author_association": "MEMBER",
            "body": "What does it mean if we don't have an `entry` here? Will the attribute then be set later? Or does it somehow imply that we don't need it? Maybe we can make the node types explicit for which we need to do this?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:02:18Z",
            "diff_hunk": "@@ -5821,6 +5839,10 @@ def analyse_declarations(self, env):\n             return\n         else:\n             self.lhs.analyse_target_declaration(env)\n+            if (getattr(self.lhs, \"entry\", None) and",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672162703",
            "id": 672162703,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE2MjcwMw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 5842,
            "original_position": 95,
            "original_start_line": null,
            "path": "Cython/Compiler/Nodes.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672162703/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672162703",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672168083"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672168083"
                }
            },
            "author_association": "MEMBER",
            "body": "I've seen this code so often by now that I wonder if `DictNode` should simply grow a method for it.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:10:22Z",
            "diff_hunk": "@@ -1045,6 +1048,10 @@ def try_to_parse_directive(self, optname, args, kwds, pos):\n                 raise PostParseError(pos,\n                     'The %s directive takes one compile-time string argument' % optname)\n             return (optname, directivetype(optname, str(args[0].value)))\n+        elif directivetype is Ellipsis:\n+            # signal to pass things on without processing\n+            return (optname, (args,\n+                              dict([(key.value, value) for key, value in kwds.key_value_pairs])))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672168083",
            "id": 672168083,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE2ODA4Mw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 1054,
            "original_position": 35,
            "original_start_line": null,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672168083/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672168083",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672169026"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672169026"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                        or (rd.is_attribute and rd.attribute == \"dataclass\")):\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:11:36Z",
            "diff_hunk": "@@ -1121,6 +1129,12 @@ def _extract_directives(self, node, scope_name):\n                 realdecs.append(dec)\n         if realdecs and (scope_name == 'cclass' or\n                          isinstance(node, (Nodes.CClassDefNode, Nodes.CVarDefNode))):\n+            for rd in realdecs:\n+                rd = rd.decorator\n+                if ((rd.is_name and rd.name == \"dataclass\")\n+                        or (isinstance(rd, ExprNodes.AttributeNode) and rd.attribute == \"dataclass\")):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672169026",
            "id": 672169026,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE2OTAyNg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 1135,
            "original_position": 56,
            "original_start_line": null,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672169026/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672169026",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672170421"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672170421"
                }
            },
            "author_association": "MEMBER",
            "body": "Untested code? It says `make_dataclasses_module_callnode` everywhere else.\r\n```suggestion\r\n                from .Dataclass import make_dataclasses_module_callnode\r\n                dataclass_module = make_dataclasses_module_callnode(node.pos)\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:13:52Z",
            "diff_hunk": "@@ -3366,6 +3383,11 @@ def visit_SimpleCallNode(self, node):\n                 node.function = ExprNodes.NameNode(node.pos, name=EncodedString('set'))\n             elif function == u'staticmethod':\n                 node.function = ExprNodes.NameNode(node.pos, name=EncodedString('staticmethod'))\n+            elif function == u'dataclass':\n+                from .Dataclass import make_dataclass_module_callnode\n+                dataclass_module = make_dataclass_module_callnode(node.pos)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672170421",
            "id": 672170421,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE3MDQyMQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 3388,
            "original_position": 78,
            "original_start_line": 3387,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672170421/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672170421",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672173312"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672173312"
                }
            },
            "author_association": "MEMBER",
            "body": "We should stop writing `0/1` for `False/True`, and also covert old code when we touch it. Python has had a boolean type [since Python 2.3](https://www.python.org/dev/peps/pep-0285/). It's about time to use it.\r\n```suggestion\r\n    is_python_type_constructor = False\r\n    is_special_python_type_constructor = False\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:18:20Z",
            "diff_hunk": "@@ -256,6 +258,8 @@ class PyrexType(BaseType):\n     is_struct_or_union = 0\n     is_cpp_class = 0\n     is_optional_cpp_class = 0\n+    is_python_type_constructor = 0\n+    is_special_python_type_constructor = 0",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672173312",
            "id": 672173312,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE3MzMxMg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 262,
            "original_position": 14,
            "original_start_line": 261,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672173312/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672173312",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672174834"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672174834"
                }
            },
            "author_association": "MEMBER",
            "body": "We already use `specialize_here()` for fused types, but with a different signature. That's confusing.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:20:49Z",
            "diff_hunk": "@@ -4404,6 +4410,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyrexType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672174834",
            "id": 672174834,
            "line": 4416,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE3NDgzNA==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 4422,
            "original_position": 55,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": 55,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672174834/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672174834",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672174944"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672174944"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this a type? And, if so, is it a type that inherits straight from `PyrexType`? Not a Python object type?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:21:00Z",
            "diff_hunk": "@@ -4404,6 +4410,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyrexType):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672174944",
            "id": 672174944,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE3NDk0NA==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 4413,
            "original_position": 46,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672174944/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672174944",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672178555"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672178555"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        if (PyObject_SetAttrString(shared_abi_module, name, module) < 0) goto bad;\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:26:47Z",
            "diff_hunk": "@@ -0,0 +1,79 @@\n+///////////////////// ModuleLoader.proto //////////////////////////\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code); /* proto */\n+\n+//////////////////// ModuleLoader ///////////////////////\n+//@requires: CommonStructures.c::FetchSharedCythonModule\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code) {\n+    // In supporting dataclasses we want to be able to use directives the contents\n+    // of the standard library dataclasses module where available\n+    // If those objects aren't available (due to Python version) then a simple fallback is substituted\n+    // instead, which largely just fails with a not-implemented error.\n+    //\n+    // The fallbacks are placed in the \"shared abi module\" as a convenient internal place to\n+    // store them\n+\n+    PyObject *shared_abi_module = 0, *module = 0;\n+\n+    shared_abi_module = __Pyx_FetchSharedCythonABIModule();\n+    if (!shared_abi_module) return NULL;\n+\n+    if (PyObject_HasAttrString(shared_abi_module, name)) {\n+        PyObject* result = PyObject_GetAttrString(shared_abi_module, name);\n+        Py_DECREF(shared_abi_module);\n+        return result;\n+    }\n+\n+    // the best and simplest case is simply to defer to the standard library (if available)\n+    module = PyImport_ImportModule(name);\n+    if (!module) {\n+        PyObject *localDict, *runValue, *builtins, *modulename;\n+        if (!PyErr_ExceptionMatches(PyExc_ImportError)) goto bad;\n+        PyErr_Clear();  // this is reasonably likely (especially on older versions of Python)\n+#if PY_MAJOR_VERSION < 3\n+        modulename = PyBytes_FromFormat(\"_cython_\" CYTHON_ABI \".%s\", name);\n+#else\n+        modulename = PyUnicode_FromFormat(\"_cython_\" CYTHON_ABI \".%s\", name);\n+#endif\n+        if (!modulename) goto bad;\n+#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_CPYTHON\n+        module = PyImport_AddModuleObject(modulename); // borrowed\n+#else\n+        module = PyImport_AddModule(PyBytes_AsString(modulename)); // borrowed\n+#endif\n+        Py_DECREF(modulename);\n+        if (!module) goto bad;\n+        Py_INCREF(module);\n+        if (PyObject_SetAttrString(shared_abi_module, name, module)<0) goto bad;",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672178555",
            "id": 672178555,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE3ODU1NQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 48,
            "original_position": 48,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.c",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672178555/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672178555",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672180287"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672180287"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n* ``Tuple[...]``, which is converted into a Cython C-tuple where possible\r\n  and a regular Python ``tuple`` otherwise.\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:29:23Z",
            "diff_hunk": "@@ -328,15 +328,27 @@ declare types of variables in a Python 3.6 compatible way as follows:\n \n There is currently no way to express the visibility of object attributes.\n \n-Cython does not support the full range of annotations described by PEP-484.\n-For example it does not currently understand features from the ``typing`` module\n-such  as ``Optional[]`` or typed containers such as ``List[str]``. This is partly\n-because some of these type hints are not relevant for the compilation to\n+``typing`` Module\n+^^^^^^^^^^^^^^^^^\n+\n+Support for the full range of annotations described by PEP-484 is not yet\n+complete. Cython 3 currently understands the following features from the\n+``typing`` module:\n+\n+* ``Optional[tp]``, which is interpreted as ``tp or None``;\n+* typed containers such as ``List[str]``, which is interpreted as ``list``. The\n+  hint that the elements are of type ``str`` is currently ignored;\n+* ``Tuple[...]``, which is converted into a Cython C-tuple where possible (and\n+  a regular Python ``tuple`` otherwise).",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672180287",
            "id": 672180287,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE4MDI4Nw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 342,
            "original_position": 19,
            "original_start_line": 341,
            "path": "docs/src/tutorial/pure.rst",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672180287/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672180287",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672188487"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672188487"
                }
            },
            "author_association": "MEMBER",
            "body": "Specifically `typing.Union` sounds like a prime candidate for fused types compilation to me.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-19T10:42:58Z",
            "diff_hunk": "@@ -328,15 +328,27 @@ declare types of variables in a Python 3.6 compatible way as follows:\n \n There is currently no way to express the visibility of object attributes.\n \n-Cython does not support the full range of annotations described by PEP-484.\n-For example it does not currently understand features from the ``typing`` module\n-such  as ``Optional[]`` or typed containers such as ``List[str]``. This is partly\n-because some of these type hints are not relevant for the compilation to\n+``typing`` Module\n+^^^^^^^^^^^^^^^^^\n+\n+Support for the full range of annotations described by PEP-484 is not yet\n+complete. Cython 3 currently understands the following features from the\n+``typing`` module:\n+\n+* ``Optional[tp]``, which is interpreted as ``tp or None``;\n+* typed containers such as ``List[str]``, which is interpreted as ``list``. The\n+  hint that the elements are of type ``str`` is currently ignored;\n+* ``Tuple[...]``, which is converted into a Cython C-tuple where possible (and\n+  a regular Python ``tuple`` otherwise).\n+* ``ClassVar[...]``, which is understood in the context of\n+  ``cdef class`` or ``@cython.cclass``.\n+\n+Some of the unsupported features (e.g. ``typing.Union``) are likely to remain\n+unsupported since these type hints are not relevant for the compilation to",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672188487",
            "id": 672188487,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjE4ODQ4Nw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 347,
            "original_position": 24,
            "original_start_line": 346,
            "path": "docs/src/tutorial/pure.rst",
            "position": null,
            "pull_request_review_id": 709251886,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672188487/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-19T10:49:53Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672188487",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r672904059"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/672904059"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "> Are the keyword argument names validated anywhere?\r\n\r\nThey are now (and tested)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-20T08:11:03Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r672904059",
            "id": 672904059,
            "in_reply_to_id": 672089305,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MjkwNDA1OQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 138,
            "original_position": 138,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 710297004,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/672904059/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-20T08:11:03Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/672904059",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r673256335"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/673256335"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think this was because picked because the CPython implementation uses a variable called `f\"_dflt_{field.name}\"` to store the default values. https://github.com/python/cpython/blob/4868b94c6089d457673b1ba5b5b64c2f38c435af/Lib/dataclasses.py#L454. What I'm doing isn't *exactly* the same, but that's where I got it from\r\n\r\nIn both cases it doesn't really matter - it's a hidden variable that the user shouldn't really be able to get to so we can name it whatever we like. But I have a mild preference for using the short name \"by analogy\" to the CPython implementation.\r\n\r\nFor now I'll keep the short name and add an explanatory note. Change it if you disagree with my preference though!",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-20T15:58:57Z",
            "diff_hunk": "@@ -135,6 +135,7 @@\n cython_runtime_cname   = pyrex_prefix + \"cython_runtime\"\n cyfunction_type_cname = pyrex_prefix + \"CyFunctionType\"\n fusedfunction_type_cname = pyrex_prefix + \"FusedFunctionType\"\n+dataclass_field_default_cname = pyrex_prefix + \"dataclass_dflt\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r673256335",
            "id": 673256335,
            "in_reply_to_id": 672159984,
            "line": 141,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MzI1NjMzNQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 138,
            "original_position": 4,
            "original_start_line": null,
            "path": "Cython/Compiler/Naming.py",
            "position": 7,
            "pull_request_review_id": 710755244,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/673256335/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-20T15:58:57Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/673256335",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r673329592"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/673329592"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Usually just that the lhs variable isn't made purely from namenodes and attributes. Putting a breakpoint in there shows an example that comes from the utility code with:\r\n\r\n```\r\nAttributeNode(obj=IndexNode(...), attribute=\"name\")\r\n```\r\n\r\nIt just isn't useful to Cython as a recognised path to a standard library module so it implies that we don't need to try to identify it.\r\n\r\nI'll take your suggestion of explicitly identifying the node types though (but it still needs the check for entry)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-20T17:23:37Z",
            "diff_hunk": "@@ -5821,6 +5839,10 @@ def analyse_declarations(self, env):\n             return\n         else:\n             self.lhs.analyse_target_declaration(env)\n+            if (getattr(self.lhs, \"entry\", None) and",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r673329592",
            "id": 673329592,
            "in_reply_to_id": 672162703,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MzMyOTU5Mg==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 5842,
            "original_position": 95,
            "original_start_line": null,
            "path": "Cython/Compiler/Nodes.py",
            "position": null,
            "pull_request_review_id": 710884252,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/673329592/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-20T17:23:37Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/673329592",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r673332781"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/673332781"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "This wasn't how it was implemented in Python. I've switched to something a little closer to the Python implementation and commented it better.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-20T17:26:41Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r673332781",
            "id": 673332781,
            "in_reply_to_id": 672102434,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MzMzMjc4MQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 376,
            "original_position": 376,
            "original_start_line": 370,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 710886900,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/673332781/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-20T17:26:41Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/673332781",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r673335435"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/673335435"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Indeed - https://github.com/cython/cython/issues/4201. I've removed the e.g.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-20T17:29:01Z",
            "diff_hunk": "@@ -328,15 +328,27 @@ declare types of variables in a Python 3.6 compatible way as follows:\n \n There is currently no way to express the visibility of object attributes.\n \n-Cython does not support the full range of annotations described by PEP-484.\n-For example it does not currently understand features from the ``typing`` module\n-such  as ``Optional[]`` or typed containers such as ``List[str]``. This is partly\n-because some of these type hints are not relevant for the compilation to\n+``typing`` Module\n+^^^^^^^^^^^^^^^^^\n+\n+Support for the full range of annotations described by PEP-484 is not yet\n+complete. Cython 3 currently understands the following features from the\n+``typing`` module:\n+\n+* ``Optional[tp]``, which is interpreted as ``tp or None``;\n+* typed containers such as ``List[str]``, which is interpreted as ``list``. The\n+  hint that the elements are of type ``str`` is currently ignored;\n+* ``Tuple[...]``, which is converted into a Cython C-tuple where possible (and\n+  a regular Python ``tuple`` otherwise).\n+* ``ClassVar[...]``, which is understood in the context of\n+  ``cdef class`` or ``@cython.cclass``.\n+\n+Some of the unsupported features (e.g. ``typing.Union``) are likely to remain\n+unsupported since these type hints are not relevant for the compilation to",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r673335435",
            "id": 673335435,
            "in_reply_to_id": 672188487,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MzMzNTQzNQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 347,
            "original_position": 24,
            "original_start_line": 346,
            "path": "docs/src/tutorial/pure.rst",
            "position": null,
            "pull_request_review_id": 710889154,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/673335435/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-20T17:29:02Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/673335435",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r673695381"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/673695381"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think this was an attempt to present `cython.dataclasses.dataclass` as `dataclasses.dataclass` if it wasn't used in a Cython-specific context - it never worked hugely reliably, and I don't think it's a necessary thing to do, so I'll remove it.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-21T06:30:08Z",
            "diff_hunk": "@@ -3366,6 +3383,11 @@ def visit_SimpleCallNode(self, node):\n                 node.function = ExprNodes.NameNode(node.pos, name=EncodedString('set'))\n             elif function == u'staticmethod':\n                 node.function = ExprNodes.NameNode(node.pos, name=EncodedString('staticmethod'))\n+            elif function == u'dataclass':\n+                from .Dataclass import make_dataclass_module_callnode\n+                dataclass_module = make_dataclass_module_callnode(node.pos)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r673695381",
            "id": 673695381,
            "in_reply_to_id": 672170421,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MzY5NTM4MQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 3388,
            "original_position": 78,
            "original_start_line": 3387,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 711298615,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/673695381/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-21T06:30:08Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/673695381",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r673697513"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/673697513"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "We use `specialize(self, value)` for `FusedTypes`. `specialize_here` was only defined for `CppClassType` (to handle templates) and has the same signature that I use here.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-21T06:34:36Z",
            "diff_hunk": "@@ -4404,6 +4410,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyrexType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r673697513",
            "id": 673697513,
            "in_reply_to_id": 672174834,
            "line": 4416,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MzY5NzUxMw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 4422,
            "original_position": 55,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": 55,
            "pull_request_review_id": 711301255,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/673697513/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-21T06:34:36Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/673697513",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r673703541"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/673703541"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "It should hopefully always end up specialized hence always end up transformed to another type. I'm not sure quite what an unspecialized `PythonTypeConstructor` means at the end of the code generation stage.\r\n\r\nI guess it probably makes sense to fall back to looking like a `PyObjectType` though so I'll do this.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-21T06:46:24Z",
            "diff_hunk": "@@ -4404,6 +4410,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyrexType):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r673703541",
            "id": 673703541,
            "in_reply_to_id": 672174944,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MzcwMzU0MQ==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 4413,
            "original_position": 46,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 711308455,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/673703541/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-07-21T06:46:24Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/673703541",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r673710317"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/673710317"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I've left this for now.\r\n\r\nIt sounds like it might be better as a `py_type_names` function that returns a list of strings (and maybe a convenience `py_types_for_instance_check` function that turns it to a tuple if needed)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-07-21T06:58:34Z",
            "diff_hunk": "@@ -0,0 +1,594 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from .Errors import error, warning\n+from . import ExprNodes, Nodes, PyrexTypes\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from . import UtilNodes, Builtin, Naming\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\"SpecificModuleLoader\", \"Dataclasses.c\",\n+            context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(pos, \"__Pyx_Load_dataclasses_Module\",\n+                                            PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+                                            utility_code = loader_utilitycode,\n+                                            args=[])\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignments(VisitorTransform, SkipDeclarations):\n+    def __init__(self, names):\n+        super(RemoveAssignments, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+def process_class_get_fields(node):\n+    _TrueNode = ExprNodes.BoolNode(node.pos, value=True)\n+    _FalseNode = ExprNodes.BoolNode(node.pos, value=False)\n+    _NoneNode = ExprNodes.NoneNode(node.pos)\n+\n+    class Field(object):\n+        \"\"\"\n+        Field is based on the dataclasses.field class from the standard library module.\n+        It is used internally during the generation of Cython dataclasses to keep track\n+        of the settings for individual attributes.\n+\n+        Attributes of this class are stored as nodes so they can be used in code construction\n+        more readily (i.e. we store BoolNode rather than bool)\n+        The class (+ _TrueNode, _FalseNode and _NoneNode) are defined inside a function\n+        that when _TrueNode (etc) are used as default arguments they can have a useful pos\n+        \"\"\"\n+        default = MISSING\n+        default_factory = MISSING\n+        private = False\n+        def __init__(self, default=MISSING, default_factory=MISSING,\n+                        repr=_TrueNode, hash=_NoneNode, init=_TrueNode,\n+                        compare=_TrueNode, metadata=_NoneNode,\n+                        is_initvar=False):\n+            if default is not MISSING:\n+                self.default = default\n+            if default_factory is not MISSING:\n+                self.default_factory = default_factory\n+            self.repr = repr\n+            self.hash = hash\n+            self.init = init\n+            self.compare = compare\n+            self.metadata = metadata\n+            self.is_initvar = is_initvar\n+\n+            for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+                field_value = getattr(self, field_name)\n+                if not field_value.is_literal:\n+                    error(field_value.pos, \"cython.dataclasses.field parameter '%s' must be a literal value\"\n+                            % field_name)\n+\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=lambda entry: entry.pos)\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # remove assignments for stat_list\n+    transform = RemoveAssignments(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                        entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = { k.value: v for k, v in assignment.keyword_args.key_value_pairs }\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(**keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (isinstance(func, ExprNodes.AttributeNode)\n+                                and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(default=assignment)\n+        else:\n+            field = Field()\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    from .ExprNodes import (AttributeNode, TupleNode, NameNode,\n+                            GeneralCallNode, DictNode,\n+                            IdentifierStringNode, BoolNode, DictItemNode)\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute\n+    dataclass_params_func = AttributeNode(node.pos, obj=dataclass_module,\n+                                            attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = DictNode.from_pairs(node.pos,\n+            [ (IdentifierStringNode(node.pos, value=EncodedString(k)),\n+                BoolNode(node.pos, value=v))\n+                for k, v in kwargs.items() ])\n+    dataclass_params = GeneralCallNode(node.pos,\n+                                    function = dataclass_params_func,\n+                                    positional_args = TupleNode(node.pos, args=[]),\n+                                    keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = \\\n+        Nodes.SingleAssignmentNode(node.pos,\n+                        lhs = NameNode(node.pos,\n+                                        name=EncodedString(\"__dataclass_params__\")),\n+                        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment]\n+                                    + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class',\n+                             pipeline=[NormalizeTree(node.scope),\n+                                       ]\n+                              ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code functions return a tuple of:\n+     code string\n+     placeholder dict (often empty)\n+     stat list (often empty)\n+    which can then be combined later and processed once\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\"))\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        annotation = entry.annotation.string if entry.annotation else None\n+        if annotation:\n+            annotation = u\": %s\" % annotation.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                             \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_call,\n+                  \"    pass\",  # just in-case it's an empty body\n+                  ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    if %s is %s:\"\n+                                % (name, default_factory_placeholder))\n+                code_lines.append(u\"        %s.%s = %s()\"\n+                                % (selfname, name, ph_name))\n+                code_lines.append(u\"    else:\")\n+                code_lines.append(u\"        %s.%s = %s\" % (selfname, name, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                    if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items()\n+                if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\"def %s(self, other):\" % funcname,\n+                  \"    cdef %s other_cast\" % node.class_name,\n+                  \"    try:\",\n+                  \"        other_cast = other\",\n+                  \"    except TypeError:\",\n+                  \"        return NotImplemented\"]\n+\n+    for name in names:\n+        shared = \"if not (self.%s == other_cast.%s):\" % (name, name)\n+        if op == \"==\":\n+            code_lines.append(\"    %s return False\" % shared)\n+        else:\n+            code_lines.append(\"    %s return self.%s %s other_cast.%s\" %\n+                              (shared, name, op, name))\n+\n+    if \"=\" in op:\n+        code_lines.append(\"    return True\")\n+    else:\n+        code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            error(node.pos, \"Request for dataclass unsafe_hash when a '__hash__' function\"\n+                  \" already exists\")\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [Nodes.SingleAssignmentNode(node.pos,\n+                                        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                                        rhs = ExprNodes.NoneNode(node.pos))]\n+        if not eq:\n+            return\n+\n+    names = [ name for name, field in fields.items()\n+                if (not field.is_initvar and\n+                    (field.compare.value if field.hash.value is None else field.hash.value)) ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = u\"\"\"def __hash__(self):\n+    return hash((%s))\n+\"\"\" % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object\n+    # Initialize with \"entry\"\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r673710317",
            "id": 673710317,
            "in_reply_to_id": 672113720,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3MzcxMDMxNw==",
            "original_commit_id": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "original_line": 463,
            "original_position": 463,
            "original_start_line": 460,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 711316360,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/673710317/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-07-21T06:58:34Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/673710317",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683897185"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683897185"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "See the comment I made on the other PR.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:10:15Z",
            "diff_hunk": "@@ -450,3 +450,57 @@ def init_builtins():\n \n \n init_builtins()\n+\n+##############################\n+# Support for a few standard library modules that Cython understands (currently typing and dataclasses\n+##############################\n+_known_module_scopes = {}\n+\n+def get_known_standard_library_module_scope(module_name):\n+    from .StringEncoding import EncodedString\n+\n+    mod = _known_module_scopes.get(module_name, None)\n+    if not mod:\n+        if module_name == \"typing\":\n+            mod = ModuleScope(module_name, None, None)\n+            for name, tp in [('Dict', dict_type),\n+                             ('List', list_type),\n+                             ('Tuple', tuple_type),\n+                             ('Set', set_type),\n+                             ('FrozenSet', frozenset_type),\n+                             ('DefaultDict', dict_type),\n+                             ('OrderedDict', dict_type)]:\n+                name = EncodedString(name)\n+                if name == \"Tuple\":\n+                    indexed_type = PyrexTypes.PythonTupleTypeConstructor(EncodedString(\"typing.\"+name), tp)\n+                else:\n+                    indexed_type = PyrexTypes.PythonTypeConstructor(EncodedString(\"typing.\"+name), tp)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683897185",
            "id": 683897185,
            "line": 477,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4Mzg5NzE4NQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 477,
            "original_position": 37,
            "original_start_line": 474,
            "path": "Cython/Compiler/Builtin.py",
            "position": 37,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683897185/reactions"
            },
            "side": "RIGHT",
            "start_line": 474,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683897185",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683901377"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683901377"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:23:46Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683901377",
            "id": 683901377,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwMTM3Nw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 42,
            "original_position": 42,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683901377/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683901377",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683901510"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683901510"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    a default value to initialize an instance attribute with.\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:24:14Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683901510",
            "id": 683901510,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwMTUxMA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 43,
            "original_position": 43,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683901510/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683901510",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683902552"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683902552"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Why do this instead of just `MISSING = object()`?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:27:38Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683902552",
            "id": 683902552,
            "line": 80,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwMjU1Mg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 80,
            "original_position": 80,
            "original_start_line": 78,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 80,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683902552/reactions"
            },
            "side": "RIGHT",
            "start_line": 78,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683902552",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683903251"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683903251"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "So why allow them in the first place and have `**additional_kwds`?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:29:45Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683903251",
            "id": 683903251,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwMzI1MQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 114,
            "original_position": 114,
            "original_start_line": 112,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683903251/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683903251",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683903639"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683903639"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    var_names = [entry.name for entry in var_entries]\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:30:56Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683903639",
            "id": 683903639,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwMzYzOQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 128,
            "original_position": 128,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683903639/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683903639",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683904898"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683904898"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:34:48Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683904898",
            "id": 683904898,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwNDg5OA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 197,
            "original_position": 197,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683904898/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683904898",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683905594"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683905594"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Could this not be `+=`?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:37:10Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683905594",
            "id": 683905594,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwNTU5NA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 244,
            "original_position": 244,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683905594/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683905594",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683905817"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683905817"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n    # Type conversion comes later\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:37:53Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683905817",
            "id": 683905817,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwNTgxNw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 248,
            "original_position": 248,
            "original_start_line": 247,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683905817/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683905817",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683906687"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683906687"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n            name = \"INIT_PLACEHOLDER_\" + placeholder_count[0]\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:40:43Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683906687",
            "id": 683906687,
            "line": 307,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwNjY4Nw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 301,
            "original_position": 301,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 307,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683906687/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683906687",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683907255"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683907255"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n            annotation = u\": \" + entry.annotation.string.value\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:42:26Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683907255",
            "id": 683907255,
            "line": 327,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwNzI1NQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 319,
            "original_position": 319,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 327,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683907255/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683907255",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683907434"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683907434"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n            assignment = u\" = \" + ph_name\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:43:03Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683907434",
            "id": 683907434,
            "line": 338,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwNzQzNA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 330,
            "original_position": 330,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 338,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683907434/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683907434",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683907555"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683907555"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n            error(entry.pos, (\"Non-default argument %s following default argument \"\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:43:30Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683907555",
            "id": 683907555,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwNzU1NQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 332,
            "original_position": 332,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683907555/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683907555",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683907762"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683907762"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n        args.append(u\"\".join((name, annotation, assignment)))\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:44:18Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683907762",
            "id": 683907762,
            "line": 344,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwNzc2Mg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 336,
            "original_position": 336,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 344,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683907762/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683907762",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683908133"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683908133"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n        elif field.default_factory is MISSING:\n```\nI think making this an `elif` makes it clear to anyone reading this code that either happens.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:45:29Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683908133",
            "id": 683908133,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwODEzMw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 347,
            "original_position": 347,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683908133/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683908133",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683908865"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683908865"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I am kind of lost, what does this ternary operation that we create do?\n\nIs `is` wise to use here, we may want to opt for `==`.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:47:56Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683908865",
            "id": 683908865,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwODg2NQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 354,
            "original_position": 354,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683908865/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683908865",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r683909485"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/683909485"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    return u\"\\n\".join(code_lines), placeholders, []\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T02:50:03Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, placeholders, []",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r683909485",
            "id": 683909485,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzkwOTQ4NQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 366,
            "original_position": 366,
            "original_start_line": 364,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 723925524,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/683909485/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T02:53:29Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/683909485",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684218469"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684218469"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Why are these False when the rest uses 0?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:04:01Z",
            "diff_hunk": "@@ -257,6 +259,8 @@ class PyrexType(BaseType):\n     is_struct_or_union = 0\n     is_cpp_class = 0\n     is_optional_cpp_class = 0\n+    is_python_type_constructor = False\n+    is_special_python_type_constructor = False",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684218469",
            "id": 684218469,
            "line": 263,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIxODQ2OQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 263,
            "original_position": 14,
            "original_start_line": 262,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": 14,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684218469/reactions"
            },
            "side": "RIGHT",
            "start_line": 262,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:02:59Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684218469",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684219666"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684219666"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Isn't this kind of unnecessary? I thought Python fell back to `__repr__`, or is this a quirk for Python 2 compatibility?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:05:45Z",
            "diff_hunk": "@@ -4398,6 +4404,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyObjectType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if self.base_type:\n+            # for a lot of the typing classes it doesn't really matter what the template it\n+            # (i.e. typing.Dict[int] is really just a dict)\n+            return self.base_type\n+        return self\n+\n+    def __repr__(self):\n+        if self.base_type:\n+            return \"%s[%r]\" % (self.name, self.base_type)\n+        else:\n+            return self.name\n+\n+    def __str__(self):\n+        return self.__repr__()",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684219666",
            "id": 684219666,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIxOTY2Ng==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 4430,
            "original_position": 69,
            "original_start_line": 4429,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684219666/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:02:59Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684219666",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684220073"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684220073"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    \"\"\"For things like ClassVar, Optional, etc, which have extra features on top of being\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:06:26Z",
            "diff_hunk": "@@ -4398,6 +4404,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyObjectType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if self.base_type:\n+            # for a lot of the typing classes it doesn't really matter what the template it\n+            # (i.e. typing.Dict[int] is really just a dict)\n+            return self.base_type\n+        return self\n+\n+    def __repr__(self):\n+        if self.base_type:\n+            return \"%s[%r]\" % (self.name, self.base_type)\n+        else:\n+            return self.name\n+\n+    def __str__(self):\n+        return self.__repr__()\n+\n+    def is_template_type(self):\n+        return True\n+\n+\n+class PythonTupleTypeConstructor(PythonTypeConstructor):\n+    def specialize_here(self, pos, env, template_values=None):\n+        if (template_values and None not in template_values and\n+                not any(v.is_pyobject for v in template_values)):\n+            entry = env.declare_tuple_type(pos, template_values)\n+            if entry:\n+                return entry.type\n+        return super(PythonTupleTypeConstructor, self).specialize_here(pos, env, template_values)\n+\n+\n+class SpecialPythonTypeConstructor(PythonTypeConstructor):\n+    \"\"\"\n+    For things like ClassVar, Optional, etc, which have extra features on top of being",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684220073",
            "id": 684220073,
            "line": 4445,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIyMDA3Mw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 4448,
            "original_position": 87,
            "original_start_line": 4447,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": 84,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684220073/reactions"
            },
            "side": "RIGHT",
            "start_line": 4444,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:02:59Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684220073",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684220199"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684220199"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    a \"templated\" type.\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:06:39Z",
            "diff_hunk": "@@ -4398,6 +4404,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyObjectType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if self.base_type:\n+            # for a lot of the typing classes it doesn't really matter what the template it\n+            # (i.e. typing.Dict[int] is really just a dict)\n+            return self.base_type\n+        return self\n+\n+    def __repr__(self):\n+        if self.base_type:\n+            return \"%s[%r]\" % (self.name, self.base_type)\n+        else:\n+            return self.name\n+\n+    def __str__(self):\n+        return self.__repr__()\n+\n+    def is_template_type(self):\n+        return True\n+\n+\n+class PythonTupleTypeConstructor(PythonTypeConstructor):\n+    def specialize_here(self, pos, env, template_values=None):\n+        if (template_values and None not in template_values and\n+                not any(v.is_pyobject for v in template_values)):\n+            entry = env.declare_tuple_type(pos, template_values)\n+            if entry:\n+                return entry.type\n+        return super(PythonTupleTypeConstructor, self).specialize_here(pos, env, template_values)\n+\n+\n+class SpecialPythonTypeConstructor(PythonTypeConstructor):\n+    \"\"\"\n+    For things like ClassVar, Optional, etc, which have extra features on top of being\n+    a \"templated\" type",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684220199",
            "id": 684220199,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIyMDE5OQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 4449,
            "original_position": 88,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684220199/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:02:59Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684220199",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684221489"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684221489"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n        while issubclass(cls, PythonTypeConstructor):  # Walk the MRO\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:08:30Z",
            "diff_hunk": "@@ -4398,6 +4404,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyObjectType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if self.base_type:\n+            # for a lot of the typing classes it doesn't really matter what the template it\n+            # (i.e. typing.Dict[int] is really just a dict)\n+            return self.base_type\n+        return self\n+\n+    def __repr__(self):\n+        if self.base_type:\n+            return \"%s[%r]\" % (self.name, self.base_type)\n+        else:\n+            return self.name\n+\n+    def __str__(self):\n+        return self.__repr__()\n+\n+    def is_template_type(self):\n+        return True\n+\n+\n+class PythonTupleTypeConstructor(PythonTypeConstructor):\n+    def specialize_here(self, pos, env, template_values=None):\n+        if (template_values and None not in template_values and\n+                not any(v.is_pyobject for v in template_values)):\n+            entry = env.declare_tuple_type(pos, template_values)\n+            if entry:\n+                return entry.type\n+        return super(PythonTupleTypeConstructor, self).specialize_here(pos, env, template_values)\n+\n+\n+class SpecialPythonTypeConstructor(PythonTypeConstructor):\n+    \"\"\"\n+    For things like ClassVar, Optional, etc, which have extra features on top of being\n+    a \"templated\" type\n+    \"\"\"\n+    is_special_python_type_constructor = True\n+\n+    @property\n+    def is_python_type_constructor(self):\n+        return not bool(self.template_type)\n+\n+    def __init__(self, name, template_type=None):\n+        super(SpecialPythonTypeConstructor, self).__init__(name, None)\n+        if (name == \"typing.ClassVar\" and template_type\n+                and not template_type.is_pyobject):\n+            # because classvars end up essentially used as globals they have\n+            # to be PyObjects. Try to find the nearest suitable type (although\n+            # practically I doubt this matters).\n+            py_type_name = template_type.py_type_name()\n+            if py_type_name:\n+                from .Builtin import builtin_scope\n+                template_type = (builtin_scope.lookup_type(py_type_name)\n+                                        or py_object_type)\n+            else:\n+                template_type = py_object_types\n+        self.template_type = template_type\n+\n+    def __getattribute__(self, attr):\n+        # order of lookup is:\n+        # 1. specifically overridden in this class or PythonTypeConstructor\n+        # 2. template type (if it exists)\n+        # 3. PyrexType\n+        dict_ = super(PythonTypeConstructor, self).__getattribute__(\"__dict__\")\n+        if attr in dict_:\n+            return dict_[attr]\n+        cls = super(PythonTypeConstructor, self).__getattribute__(\"__class__\")\n+        while issubclass(cls, PythonTypeConstructor):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684221489",
            "id": 684221489,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIyMTQ4OQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 4482,
            "original_position": 121,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684221489/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:02:59Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684221489",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684222219"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684222219"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Is this true for cases like: `Tuple[int, str]`, or is this code only for ClassVar?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:09:36Z",
            "diff_hunk": "@@ -4398,6 +4404,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyObjectType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if self.base_type:\n+            # for a lot of the typing classes it doesn't really matter what the template it\n+            # (i.e. typing.Dict[int] is really just a dict)\n+            return self.base_type\n+        return self\n+\n+    def __repr__(self):\n+        if self.base_type:\n+            return \"%s[%r]\" % (self.name, self.base_type)\n+        else:\n+            return self.name\n+\n+    def __str__(self):\n+        return self.__repr__()\n+\n+    def is_template_type(self):\n+        return True\n+\n+\n+class PythonTupleTypeConstructor(PythonTypeConstructor):\n+    def specialize_here(self, pos, env, template_values=None):\n+        if (template_values and None not in template_values and\n+                not any(v.is_pyobject for v in template_values)):\n+            entry = env.declare_tuple_type(pos, template_values)\n+            if entry:\n+                return entry.type\n+        return super(PythonTupleTypeConstructor, self).specialize_here(pos, env, template_values)\n+\n+\n+class SpecialPythonTypeConstructor(PythonTypeConstructor):\n+    \"\"\"\n+    For things like ClassVar, Optional, etc, which have extra features on top of being\n+    a \"templated\" type\n+    \"\"\"\n+    is_special_python_type_constructor = True\n+\n+    @property\n+    def is_python_type_constructor(self):\n+        return not bool(self.template_type)\n+\n+    def __init__(self, name, template_type=None):\n+        super(SpecialPythonTypeConstructor, self).__init__(name, None)\n+        if (name == \"typing.ClassVar\" and template_type\n+                and not template_type.is_pyobject):\n+            # because classvars end up essentially used as globals they have\n+            # to be PyObjects. Try to find the nearest suitable type (although\n+            # practically I doubt this matters).\n+            py_type_name = template_type.py_type_name()\n+            if py_type_name:\n+                from .Builtin import builtin_scope\n+                template_type = (builtin_scope.lookup_type(py_type_name)\n+                                        or py_object_type)\n+            else:\n+                template_type = py_object_types\n+        self.template_type = template_type\n+\n+    def __getattribute__(self, attr):\n+        # order of lookup is:\n+        # 1. specifically overridden in this class or PythonTypeConstructor\n+        # 2. template type (if it exists)\n+        # 3. PyrexType\n+        dict_ = super(PythonTypeConstructor, self).__getattribute__(\"__dict__\")\n+        if attr in dict_:\n+            return dict_[attr]\n+        cls = super(PythonTypeConstructor, self).__getattribute__(\"__class__\")\n+        while issubclass(cls, PythonTypeConstructor):\n+            if attr in cls.__dict__:\n+                return super(PythonTypeConstructor, self).__getattribute__(attr)\n+            cls = cls.__base__\n+\n+        tt = super(PythonTypeConstructor, self).__getattribute__(\"template_type\")\n+        if tt:\n+            return getattr(tt, attr)\n+\n+        return super(PythonTypeConstructor, self).__getattribute__(attr)  # fallback to looking like a PyrexType\n+\n+    def __repr__(self):\n+        if self.template_type:\n+            return \"%s[%r]\" % (self.name, self.template_type)\n+        else:\n+            return self.name\n+\n+    def is_template_type(self):\n+        return self.template_type is None\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if not self.is_template_type():\n+            error(pos, \"'%r' has already been specialized\" % self )\n+            return error_type\n+        if len(template_values) != 1:\n+            error(pos, \"'%s' takes exactly one template argument.\" % self.name)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684222219",
            "id": 684222219,
            "line": 4504,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIyMjIxOQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 4507,
            "original_position": 146,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": 143,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684222219/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684222219",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684224851"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684224851"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> want to be able to use directives the contents\n\nHuh?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:13:26Z",
            "diff_hunk": "@@ -0,0 +1,79 @@\n+///////////////////// ModuleLoader.proto //////////////////////////\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code); /* proto */\n+\n+//////////////////// ModuleLoader ///////////////////////\n+//@requires: CommonStructures.c::FetchSharedCythonModule\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code) {\n+    // In supporting dataclasses we want to be able to use directives the contents",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684224851",
            "id": 684224851,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIyNDg1MQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 9,
            "original_position": 9,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.c",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684224851/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684224851",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684226405"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684226405"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    // of the standard library dataclasses module where available.\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:15:39Z",
            "diff_hunk": "@@ -0,0 +1,79 @@\n+///////////////////// ModuleLoader.proto //////////////////////////\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code); /* proto */\n+\n+//////////////////// ModuleLoader ///////////////////////\n+//@requires: CommonStructures.c::FetchSharedCythonModule\n+\n+static PyObject* __Pyx_LoadInternalModule(const char* name, const char* fallback_code) {\n+    // In supporting dataclasses we want to be able to use directives the contents\n+    // of the standard library dataclasses module where available",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684226405",
            "id": 684226405,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIyNjQwNQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 10,
            "original_position": 10,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.c",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684226405/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684226405",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684228860"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684228860"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Isn't this the case? Should we not do this TODO?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:19:20Z",
            "diff_hunk": "@@ -2030,13 +2039,26 @@ def declare_from_annotation(self, env, as_target=False):\n                           \"'%s' cannot be specialized since its type is not a fused argument to this function\" %\n                           self.name)\n                     atype = error_type\n+            visibility = 'private'\n+            if 'dataclasses.dataclass' in env.directives:\n+                # handle \"frozen\" directive - full inspection of the dataclass directives happens\n+                # in Dataclass.py\n+                frozen_directive = None\n+                dataclass_directive = env.directives['dataclasses.dataclass']\n+                if dataclass_directive:\n+                    dataclass_directive_kwds = dataclass_directive[1]\n+                    frozen_directive = dataclass_directive_kwds.get('frozen', None)\n+                is_frozen = frozen_directive and frozen_directive.is_literal and frozen_directive.value\n+                if atype.is_pyobject or atype.can_coerce_to_pyobject(env):\n+                    visibility = 'readonly' if is_frozen else 'public'\n+                    # If the object can't be coerced that's fine - we just don't create a property\n             if as_target and env.is_c_class_scope and not (atype.is_pyobject or atype.is_error):\n                 # TODO: this will need revising slightly if either cdef dataclasses or\n                 # annotated cdef attributes are implemented",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684228860",
            "id": 684228860,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIyODg2MA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 2057,
            "original_position": 35,
            "original_start_line": 2056,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684228860/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684228860",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684231469"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684231469"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Run the function twice? Or this Cython function?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:23:06Z",
            "diff_hunk": "@@ -9841,6 +9896,9 @@ class LambdaNode(InnerFunctionNode):\n     name = StringEncoding.EncodedString('<lambda>')\n \n     def analyse_declarations(self, env):\n+        if hasattr(self, \"lambda_name\"):\n+            # this if-statement makes it safe to run twice",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684231469",
            "id": 684231469,
            "line": 9904,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIzMTQ2OQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 9900,
            "original_position": 146,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": 147,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684231469/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684231469",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684234270"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684234270"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Either both should be plural, or both should be singular.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:27:13Z",
            "diff_hunk": "@@ -1182,20 +1194,23 @@ def analyse(self, env, could_be_name=False, base_type=None):\n             base_type = self.base_type_node.analyse(env)\n         if base_type.is_error: return base_type\n \n-        if base_type.is_cpp_class and base_type.is_template_type():\n+        if ((base_type.is_cpp_class and base_type.is_template_type()) or\n+                base_type.is_python_type_constructor):\n             # Templated class\n             if self.keyword_args and self.keyword_args.key_value_pairs:\n-                error(self.pos, \"c++ templates cannot take keyword arguments\")\n+                tp = \"c++ templates\" if base_type.is_cpp_class else \"indexed type\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684234270",
            "id": 684234270,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIzNDI3MA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 1201,
            "original_position": 56,
            "original_start_line": null,
            "path": "Cython/Compiler/Nodes.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684234270/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684234270",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684236006"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684236006"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think we could create sentiel values instead? That is, a special `object()`, or does Cython not handle this correctly?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:29:33Z",
            "diff_hunk": "@@ -328,6 +328,11 @@ def normalise_encoding_name(option_name, encoding):\n     'c_string_encoding': normalise_encoding_name,\n     'trashcan': bool,\n     'total_ordering': bool,\n+    'dataclasses.dataclass': Ellipsis,  # use Ellipsis as a flag to defer analysis of the arguments\n+            # instead of analysing it in InterpretCompilerDirectives. The dataclass directives are quite\n+            # complicated and it's easier to deal with them at the point the dataclass is created\n+            # TODO this may not be the best way of flagging it?",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684236006",
            "id": 684236006,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIzNjAwNg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 334,
            "original_position": 7,
            "original_start_line": null,
            "path": "Cython/Compiler/Options.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684236006/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684236006",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684237327"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684237327"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Yeah we could create an actual sentiel `DEFERRED` or similar value.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:31:28Z",
            "diff_hunk": "@@ -978,7 +981,7 @@ def try_to_parse_directives(self, node):\n                 if directivetype is bool:\n                     arg = ExprNodes.BoolNode(node.pos, value=True)\n                     return [self.try_to_parse_directive(optname, [arg], None, node.pos)]\n-                elif directivetype is None:\n+                elif directivetype is None or directivetype is Ellipsis:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684237327",
            "id": 684237327,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIzNzMyNw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 984,
            "original_position": 24,
            "original_start_line": null,
            "path": "Cython/Compiler/ParseTreeTransforms.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684237327/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684237327",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684238755"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684238755"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n        #  3. repeat step 1 with the (possibly) updated entry (hence the loop)\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:33:33Z",
            "diff_hunk": "@@ -988,10 +993,19 @@ def lookup_target(self, name):\n \n     def lookup_type(self, name):\n         entry = self.lookup(name)\n-        if entry and entry.is_type:\n-            if entry.type.is_fused and self.fused_to_specific:\n-                return entry.type.specialize(self.fused_to_specific)\n-            return entry.type\n+        # The logic here is:\n+        #  1. if entry is a type then return it (and maybe specialize it)\n+        #  2. if the entry comes from a known standard library import then follow that\n+        #  3. repeat step 1 with the (possibly) updated entry",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684238755",
            "id": 684238755,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIzODc1NQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 999,
            "original_position": 37,
            "original_start_line": null,
            "path": "Cython/Compiler/Symtab.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684238755/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684238755",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684239394"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684239394"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    \"\"\"cython.dataclasses just shadows the standard library modules of the same name\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:34:25Z",
            "diff_hunk": "@@ -525,6 +525,35 @@ def threadid(self):\n     # def threadsavailable(self):\n         # return 1\n \n+class CythonDotImportedFromElsewhere(object):\n+    \"\"\"\n+    cython.dataclasses just shadows the standard library modules of the same name",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684239394",
            "id": 684239394,
            "line": 530,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDIzOTM5NA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 530,
            "original_position": 6,
            "original_start_line": 529,
            "path": "Cython/Shadow.py",
            "position": 6,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684239394/reactions"
            },
            "side": "RIGHT",
            "start_line": 529,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684239394",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684240497"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684240497"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I am pretty sure we do this elsewhere too for `cython.cimport`, can you move it there?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:35:48Z",
            "diff_hunk": "@@ -525,6 +525,35 @@ def threadid(self):\n     # def threadsavailable(self):\n         # return 1\n \n+class CythonDotImportedFromElsewhere(object):\n+    \"\"\"\n+    cython.dataclasses just shadows the standard library modules of the same name\n+    \"\"\"\n+    def __init__(self, module):\n+        self.__path__ = []\n+        self.__file__ = None\n+        self.__name__ = module\n+        self.__package__ = module\n+\n+    def __getattr__(self, attr):\n+        # we typically only expect this to be called once\n+        from importlib import import_module\n+        import sys\n+        try:\n+            mod = import_module(self.__name__)\n+        except ImportError:\n+            # but if they don't exist (Python is not sufficiently up-to-date) then\n+            # you can't use them\n+            raise AttributeError(\"%s: the standard library module %s is not available\" %\n+                                 (attr, self.__name__))\n+        sys.modules['cython.%s' % self.__name__] = mod\n+        return getattr(mod, attr)\n+\n+import sys\n+# In pure Python mode @cython.dataclasses.dataclass and dataclass field should just\n+# shadow the standard library ones (if they are available)\n+dataclasses = sys.modules['cython.dataclasses'] = CythonDotImportedFromElsewhere('dataclasses')\n+del sys",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684240497",
            "id": 684240497,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI0MDQ5Nw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 556,
            "original_position": 32,
            "original_start_line": 552,
            "path": "Cython/Shadow.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684240497/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684240497",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684246526"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684246526"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This isn't used elsewhere, just move the string to the error.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:43:45Z",
            "diff_hunk": "@@ -0,0 +1,98 @@\n+################### Dataclasses_fallback ###############################\n+\n+# This is the fallback dataclass code if the stdlib module isn't available.\n+# It defines enough of the support types to be used with cdef classes\n+# and to fail if used on regular types.\n+\n+# (Intended to be included as py code - not compiled)\n+\n+from collections import namedtuple\n+try:\n+    from types import MappingProxyType\n+except ImportError:\n+    # mutable fallback if unavailable\n+    MappingProxyType = lambda x: x\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+_DataclassParams = namedtuple('_DataclassParams',\n+    [\"init\", \"repr\", \"eq\", \"order\", \"unsafe_hash\", \"frozen\"])\n+class Field(object):\n+    __slots__ = ('name',\n+                 'type',\n+                 'default',\n+                 'default_factory',\n+                 'repr',\n+                 'hash',\n+                 'init',\n+                 'compare',\n+                 'metadata',\n+                 '_field_type',  # Private: not to be used by user code.\n+                 )\n+\n+    def __init__(self, default, default_factory, init, repr, hash, compare,\n+                 metadata):\n+        self.name = None\n+        self.type = None\n+        self.default = default\n+        self.default_factory = default_factory\n+        self.init = init\n+        self.repr = repr\n+        self.hash = hash\n+        self.compare = compare\n+        # Be aware that if MappingProxyType is unavailable (i.e. py2?) then we\n+        # don't enforce non-mutability that the real module does\n+        self.metadata = (MappingProxyType({})\n+                         if metadata is None else\n+                         MappingTypesProxy(metadata))\n+        self._field_type = None\n+\n+    def __repr__(self):\n+        return ('Field('\n+                'name={0!r},'\n+                'type={1!r},'\n+                'default={2!r},'\n+                'default_factory={3!r},'\n+                'init={4!r},'\n+                'repr={5!r},'\n+                'hash={6!r},'\n+                'compare={7!r},'\n+                'metadata={8!r},'\n+                ')'.format(self.name, self.type, self.default,\n+                           self.default_factory, self.init,\n+                           self.repr, self.hash, self.compare,\n+                           self.metadata))\n+\n+# A sentinel object for default values to signal that a default\n+# factory will be used.  This is given a nice repr() which will appear\n+# in the function signature of dataclasses' constructors.\n+class _HAS_DEFAULT_FACTORY_CLASS:\n+    def __repr__(self):\n+        return '<factory>'\n+_HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()\n+\n+_DATACLASS_MODULE_UNAVAILABLE_ERROR = (\"Standard library 'dataclasses' module\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684246526",
            "id": 684246526,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI0NjUyNg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 76,
            "original_position": 76,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684246526/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684246526",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684247925"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684247925"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Same question as before, if this isn't the case. Why is it accepted in the first place, is it to do with Cython calling this function and passing `*args, **kwargs` (meaning that the user would see a weird error that looks to be an issue with Cython)?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:45:41Z",
            "diff_hunk": "@@ -0,0 +1,98 @@\n+################### Dataclasses_fallback ###############################\n+\n+# This is the fallback dataclass code if the stdlib module isn't available.\n+# It defines enough of the support types to be used with cdef classes\n+# and to fail if used on regular types.\n+\n+# (Intended to be included as py code - not compiled)\n+\n+from collections import namedtuple\n+try:\n+    from types import MappingProxyType\n+except ImportError:\n+    # mutable fallback if unavailable\n+    MappingProxyType = lambda x: x\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+_DataclassParams = namedtuple('_DataclassParams',\n+    [\"init\", \"repr\", \"eq\", \"order\", \"unsafe_hash\", \"frozen\"])\n+class Field(object):\n+    __slots__ = ('name',\n+                 'type',\n+                 'default',\n+                 'default_factory',\n+                 'repr',\n+                 'hash',\n+                 'init',\n+                 'compare',\n+                 'metadata',\n+                 '_field_type',  # Private: not to be used by user code.\n+                 )\n+\n+    def __init__(self, default, default_factory, init, repr, hash, compare,\n+                 metadata):\n+        self.name = None\n+        self.type = None\n+        self.default = default\n+        self.default_factory = default_factory\n+        self.init = init\n+        self.repr = repr\n+        self.hash = hash\n+        self.compare = compare\n+        # Be aware that if MappingProxyType is unavailable (i.e. py2?) then we\n+        # don't enforce non-mutability that the real module does\n+        self.metadata = (MappingProxyType({})\n+                         if metadata is None else\n+                         MappingTypesProxy(metadata))\n+        self._field_type = None\n+\n+    def __repr__(self):\n+        return ('Field('\n+                'name={0!r},'\n+                'type={1!r},'\n+                'default={2!r},'\n+                'default_factory={3!r},'\n+                'init={4!r},'\n+                'repr={5!r},'\n+                'hash={6!r},'\n+                'compare={7!r},'\n+                'metadata={8!r},'\n+                ')'.format(self.name, self.type, self.default,\n+                           self.default_factory, self.init,\n+                           self.repr, self.hash, self.compare,\n+                           self.metadata))\n+\n+# A sentinel object for default values to signal that a default\n+# factory will be used.  This is given a nice repr() which will appear\n+# in the function signature of dataclasses' constructors.\n+class _HAS_DEFAULT_FACTORY_CLASS:\n+    def __repr__(self):\n+        return '<factory>'\n+_HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()\n+\n+_DATACLASS_MODULE_UNAVAILABLE_ERROR = (\"Standard library 'dataclasses' module\"\n+    \"is unavailable, likely due to the version of Python you're using.\")\n+\n+def dataclass(*args, **kwds):\n+    raise NotImplementedError(_DATACLASS_MODULE_UNAVAILABLE_ERROR)\n+\n+def field(*ignore, **kwds):\n+    default = kwds.pop(\"default\", MISSING)\n+    default_factory = kwds.pop(\"default_factory\", MISSING)\n+    init = kwds.pop(\"init\", True)\n+    repr = kwds.pop(\"repr\", True)\n+    hash = kwds.pop(\"hash\", None)\n+    compare = kwds.pop(\"compare\", True)\n+    metadata = kwds.pop(\"metadata\", None)\n+\n+    if kwds:\n+        raise ValueError(\"field received unexpected keyword arguments: %s\"\n+                         % list(kwds.keys()))\n+    if default is not MISSING and default_factory is not MISSING:\n+        raise ValueError('cannot specify both default and default_factory')\n+    if ignore:\n+        raise ValueError(\"'field' does not take any positional arguments\")",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684247925",
            "id": 684247925,
            "line": 105,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI0NzkyNQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 97,
            "original_position": 97,
            "original_start_line": 96,
            "path": "Cython/Utility/Dataclasses.py",
            "position": 105,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684247925/reactions"
            },
            "side": "RIGHT",
            "start_line": 104,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684247925",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684250418"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684250418"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "You should make a note that the typing used is not from cython itself.\n\nAs in, it's not `cython.dataclasses.InitVar` but `dataclasses.InitVar` from Python.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:49:03Z",
            "diff_hunk": "@@ -0,0 +1,20 @@\n+cimport cython\n+try:\n+    import typing\n+    import dataclasses\n+except ImportError:\n+    pass  # The modules don't actually have to exists for Cython to use them as annotations\n+\n+@cython.dataclasses.dataclass\n+cdef class MyDataclass:\n+    # fields can be declared using annotations\n+    a: cython.int = 0\n+    b: double = cython.dataclasses.field(default_factory = lambda: 10, repr=False)\n+\n+    # fields can also be declared using `cdef`:\n+    cdef str c\n+    c = \"hello\"  # assignment of default value on a separate line\n+\n+    # cython equivalents to InitVar and typing.ClassVar also work",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684250418",
            "id": 684250418,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1MDQxOA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 18,
            "original_position": 18,
            "original_start_line": null,
            "path": "docs/examples/userguide/extension_types/dataclass.pyx",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684250418/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684250418",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684251341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684251341"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\nspecial methods - for example if they cannot be converted to a Python\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:50:19Z",
            "diff_hunk": "@@ -1051,5 +1051,27 @@ generated containing declarations for its object struct and type object. By\n including the ``.h`` file in external C code that you write, that code can\n access the attributes of the extension type.\n \n+Dataclass extension types\n+=========================\n \n+Cython supports extension types that behave like the dataclasses defined in\n+the Python 3.7+ standard library. The main benefit of using a dataclass is\n+that it can auto-generate simple `__init__`, `__repr__` and comparison\n+functions. The Cython implementation behaves as much like the Python\n+standard library implementation as possible and therefore the documentation\n+here only briefly outlines the differences - if you plan on using them\n+then please read `the documentation for the standard library module\n+<https://docs.python.org/3/library/dataclasses.html>`_.\n+\n+Dataclasses can be declared using the `@cython.dataclass` decorator. If\n+you need to define special properties on a field then use `cython.field`\n+\n+.. literalinclude:: ../../examples/userguide/extension_types/dataclass.pyx    \n+\n+You may use C-level types such as structs, pointers, or C++ classes.\n+However, you may find these types are not compatible with the auto-generated\n+special methods - for example if they cannot be converted from a Python",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684251341",
            "id": 684251341,
            "line": 1076,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1MTM0MQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 1073,
            "original_position": 23,
            "original_start_line": null,
            "path": "docs/src/userguide/extension_types.rst",
            "position": 27,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684251341/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684251341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684251945"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684251945"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n`default_factory` to initialize them. Like with the Python implementation, you can also control\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:51:03Z",
            "diff_hunk": "@@ -1051,5 +1051,27 @@ generated containing declarations for its object struct and type object. By\n including the ``.h`` file in external C code that you write, that code can\n access the attributes of the extension type.\n \n+Dataclass extension types\n+=========================\n \n+Cython supports extension types that behave like the dataclasses defined in\n+the Python 3.7+ standard library. The main benefit of using a dataclass is\n+that it can auto-generate simple `__init__`, `__repr__` and comparison\n+functions. The Cython implementation behaves as much like the Python\n+standard library implementation as possible and therefore the documentation\n+here only briefly outlines the differences - if you plan on using them\n+then please read `the documentation for the standard library module\n+<https://docs.python.org/3/library/dataclasses.html>`_.\n+\n+Dataclasses can be declared using the `@cython.dataclass` decorator. If\n+you need to define special properties on a field then use `cython.field`\n+\n+.. literalinclude:: ../../examples/userguide/extension_types/dataclass.pyx    \n+\n+You may use C-level types such as structs, pointers, or C++ classes.\n+However, you may find these types are not compatible with the auto-generated\n+special methods - for example if they cannot be converted from a Python\n+type they cannot be passed to a constructor, and you must use a \n+`default_factory` to initialize them. As in Python, you can also control",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684251945",
            "id": 684251945,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1MTk0NQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 1075,
            "original_position": 25,
            "original_start_line": null,
            "path": "docs/src/userguide/extension_types.rst",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684251945/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684251945",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684253371"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684253371"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Should a class be marked as `cdef` class when using `@cython.dataclasses.dataclass`?\n\nHow does this work with Pure Python Mode? I think if a class is decorated `@cython.dataclasses.dataclass` it is assumed to be an extension type and there is no need to add `@cython.cclass`.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:52:47Z",
            "diff_hunk": "@@ -1051,5 +1051,27 @@ generated containing declarations for its object struct and type object. By\n including the ``.h`` file in external C code that you write, that code can\n access the attributes of the extension type.\n \n+Dataclass extension types\n+=========================",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684253371",
            "id": 684253371,
            "line": 1055,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1MzM3MQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 1055,
            "original_position": 5,
            "original_start_line": 1054,
            "path": "docs/src/userguide/extension_types.rst",
            "position": 5,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684253371/reactions"
            },
            "side": "RIGHT",
            "start_line": 1054,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684253371",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684256422"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684256422"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    \"\"\"Cython (and Python) normally treats\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:56:54Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684256422",
            "id": 684256422,
            "line": 37,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1NjQyMg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 37,
            "original_position": 37,
            "original_start_line": 36,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 37,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684256422/reactions"
            },
            "side": "RIGHT",
            "start_line": 36,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684256422",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684257124"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684257124"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The error should say which is the most recent that it is using.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:57:55Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684257124",
            "id": 684257124,
            "line": 66,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1NzEyNA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 66,
            "original_position": 66,
            "original_start_line": 65,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 66,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684257124/reactions"
            },
            "side": "RIGHT",
            "start_line": 65,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684257124",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684257516"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684257516"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "What is this commenting on?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:58:26Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684257516",
            "id": 684257516,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1NzUxNg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 72,
            "original_position": 72,
            "original_start_line": 71,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684257516/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684257516",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684257858"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684257858"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I thought Cython did doc-strings like the following:\n\n```suggestion\n    \"\"\"Field is based on the dataclasses.field class from the standard library module.\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T13:58:54Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684257858",
            "id": 684257858,
            "line": 85,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1Nzg1OA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": 84,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 85,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684257858/reactions"
            },
            "side": "RIGHT",
            "start_line": 84,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684257858",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684259358"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684259358"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n                          \" for a dataclass field.\")\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T14:00:55Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684259358",
            "id": 684259358,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDI1OTM1OA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 159,
            "original_position": 159,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 724334460,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684259358/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T14:03:00Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684259358",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684377348"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684377348"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think I decided that I found this version clearer (so left it as is)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T16:56:32Z",
            "diff_hunk": "@@ -450,3 +450,57 @@ def init_builtins():\n \n \n init_builtins()\n+\n+##############################\n+# Support for a few standard library modules that Cython understands (currently typing and dataclasses\n+##############################\n+_known_module_scopes = {}\n+\n+def get_known_standard_library_module_scope(module_name):\n+    from .StringEncoding import EncodedString\n+\n+    mod = _known_module_scopes.get(module_name, None)\n+    if not mod:\n+        if module_name == \"typing\":\n+            mod = ModuleScope(module_name, None, None)\n+            for name, tp in [('Dict', dict_type),\n+                             ('List', list_type),\n+                             ('Tuple', tuple_type),\n+                             ('Set', set_type),\n+                             ('FrozenSet', frozenset_type),\n+                             ('DefaultDict', dict_type),\n+                             ('OrderedDict', dict_type)]:\n+                name = EncodedString(name)\n+                if name == \"Tuple\":\n+                    indexed_type = PyrexTypes.PythonTupleTypeConstructor(EncodedString(\"typing.\"+name), tp)\n+                else:\n+                    indexed_type = PyrexTypes.PythonTypeConstructor(EncodedString(\"typing.\"+name), tp)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684377348",
            "id": 684377348,
            "in_reply_to_id": 683897185,
            "line": 477,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM3NzM0OA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 477,
            "original_position": 37,
            "original_start_line": 474,
            "path": "Cython/Compiler/Builtin.py",
            "position": 37,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684377348/reactions"
            },
            "side": "RIGHT",
            "start_line": 474,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684377348",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684378359"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684378359"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Most of the rest of Cython looks to have written their docstrings as\r\n\r\n```\r\n\"\"\"\r\nText goes here \r\n...\r\n```\r\n\r\nand I prefer it so I'll leave it unless forced",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T16:58:13Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684378359",
            "id": 684378359,
            "in_reply_to_id": 684256422,
            "line": 37,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM3ODM1OQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 37,
            "original_position": 37,
            "original_start_line": 36,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 37,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684378359/reactions"
            },
            "side": "RIGHT",
            "start_line": 36,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684378359",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684381192"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684381192"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I agree, although getting a good string representation of the most recent assignment is surprisingly hard. It does at least provide a position as part of the warning message.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:03:17Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684381192",
            "id": 684381192,
            "in_reply_to_id": 684257124,
            "line": 66,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM4MTE5Mg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 66,
            "original_position": 66,
            "original_start_line": 65,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 66,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684381192/reactions"
            },
            "side": "RIGHT",
            "start_line": 65,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684381192",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684383183"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684383183"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think it's commenting on the lack of a `visit_CascadedAssignmentNode`. I think I mean annotations rather than decorators though... I'll change the comment to make it clearer.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:07:11Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684383183",
            "id": 684383183,
            "in_reply_to_id": 684257516,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM4MzE4Mw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 72,
            "original_position": 72,
            "original_start_line": 71,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684383183/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684383183",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684384158"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684384158"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Partly because the idea was copied from the CPython implementation of dataclass and partly because the class name gives a slightly more obvious representation if you ever have to debug it. But `MISSING = object()` would work perfectly well too.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:09:01Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684384158",
            "id": 684384158,
            "in_reply_to_id": 683902552,
            "line": 80,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM4NDE1OA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 80,
            "original_position": 80,
            "original_start_line": 78,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 80,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684384158/reactions"
            },
            "side": "RIGHT",
            "start_line": 78,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684384158",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684384592"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684384592"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "As before, most of the ones I can find have a newline after the `\"\"\"`",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:09:48Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684384592",
            "id": 684384592,
            "in_reply_to_id": 684257858,
            "line": 85,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM4NDU5Mg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": 84,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 85,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684384592/reactions"
            },
            "side": "RIGHT",
            "start_line": 84,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684384592",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684386263"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684386263"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "This seemed the easiest place to detect them and raise the error to me. The `Field` constructor is just called with `Field(node.pos, **keyword_args)` so `additional_kwds` gets populated naturally with everything left over.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:12:47Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684386263",
            "id": 684386263,
            "in_reply_to_id": 683903251,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM4NjI2Mw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 114,
            "original_position": 114,
            "original_start_line": 112,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684386263/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684386263",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684388420"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684388420"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I'll change it to `\"cannot specify both default and default_factory\"` since that's the exact error message from the dataclasses standard library module.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:16:27Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684388420",
            "id": 684388420,
            "in_reply_to_id": 684259358,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM4ODQyMA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 159,
            "original_position": 159,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684388420/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684388420",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684390035"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684390035"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Yes I'll change it.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:19:33Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684390035",
            "id": 684390035,
            "in_reply_to_id": 683905594,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM5MDAzNQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 244,
            "original_position": 244,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684390035/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684390035",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684390987"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684390987"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "`placeholder_count[0]` isn't a string.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:21:14Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684390987",
            "id": 684390987,
            "in_reply_to_id": 683906687,
            "line": 307,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM5MDk4Nw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 301,
            "original_position": 301,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 307,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684390987/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684390987",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684391884"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684391884"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "That would also work (and probably be faster). I think the intent is a little clearer with string formatting though",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:22:46Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684391884",
            "id": 684391884,
            "in_reply_to_id": 683907255,
            "line": 327,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM5MTg4NA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 319,
            "original_position": 319,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 327,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684391884/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684391884",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684392460"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684392460"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "The error message is an exact copy of the CPython message so I'd rather leave it as is.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:23:48Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684392460",
            "id": 684392460,
            "in_reply_to_id": 683907555,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM5MjQ2MA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 332,
            "original_position": 332,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684392460/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684392460",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684395814"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684395814"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "```\r\ndef __init__(self, name=_PLACEHOLDER_VALUE):\r\n      self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\r\n```\r\n\r\nIt's an exact check for `_PLACEHOLDER_VALUE` which is just a unique default assignment for the argument. So `is` is correct. I've added a comment in the code to try to clarify.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:29:55Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        if field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684395814",
            "id": 684395814,
            "in_reply_to_id": 683908865,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM5NTgxNA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 354,
            "original_position": 354,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684395814/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684395814",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684396382"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684396382"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think the string formatting is slightly clearer to me (although probably a little less efficient).",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:30:51Z",
            "diff_hunk": "@@ -0,0 +1,685 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `=1` should be interpreted as\n+    default value to initialize an instance attribute.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with decorators\n+    # so can be ignored\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"'%s' is an invalid keyword argument for cython.dataclasses.field()\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [ entry.name for entry in var_entries ]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"You cannot specify both 'default' and 'default_factory'\"\n+                          \" for a dataclass member\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation\n+                    error(assignment.pos, \"Mutable default passed argument for '{0}' - \"\n+                          \"use 'default_factory' instead\".format(name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"Unrecognised keyword argument '{0}' to cython.dataclasses.dataclass\".format(k))\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats = stats.stats + code_tree.stats + extra_stats\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY\n+    # type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument %s follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684396382",
            "id": 684396382,
            "in_reply_to_id": 683907762,
            "line": 344,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM5NjM4Mg==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 336,
            "original_position": 336,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 344,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684396382/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684396382",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684397774"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684397774"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "The bit above is the \"doing the TODO\". But well-spotted; I've updated the text.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:33:21Z",
            "diff_hunk": "@@ -2030,13 +2039,26 @@ def declare_from_annotation(self, env, as_target=False):\n                           \"'%s' cannot be specialized since its type is not a fused argument to this function\" %\n                           self.name)\n                     atype = error_type\n+            visibility = 'private'\n+            if 'dataclasses.dataclass' in env.directives:\n+                # handle \"frozen\" directive - full inspection of the dataclass directives happens\n+                # in Dataclass.py\n+                frozen_directive = None\n+                dataclass_directive = env.directives['dataclasses.dataclass']\n+                if dataclass_directive:\n+                    dataclass_directive_kwds = dataclass_directive[1]\n+                    frozen_directive = dataclass_directive_kwds.get('frozen', None)\n+                is_frozen = frozen_directive and frozen_directive.is_literal and frozen_directive.value\n+                if atype.is_pyobject or atype.can_coerce_to_pyobject(env):\n+                    visibility = 'readonly' if is_frozen else 'public'\n+                    # If the object can't be coerced that's fine - we just don't create a property\n             if as_target and env.is_c_class_scope and not (atype.is_pyobject or atype.is_error):\n                 # TODO: this will need revising slightly if either cdef dataclasses or\n                 # annotated cdef attributes are implemented",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684397774",
            "id": 684397774,
            "in_reply_to_id": 684228860,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM5Nzc3NA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 2057,
            "original_position": 35,
            "original_start_line": 2056,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684397774/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684397774",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684398129"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684398129"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Run `analyse_declarations` twice.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:33:56Z",
            "diff_hunk": "@@ -9841,6 +9896,9 @@ class LambdaNode(InnerFunctionNode):\n     name = StringEncoding.EncodedString('<lambda>')\n \n     def analyse_declarations(self, env):\n+        if hasattr(self, \"lambda_name\"):\n+            # this if-statement makes it safe to run twice",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684398129",
            "id": 684398129,
            "in_reply_to_id": 684231469,
            "line": 9904,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDM5ODEyOQ==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 9900,
            "original_position": 146,
            "original_start_line": null,
            "path": "Cython/Compiler/ExprNodes.py",
            "position": 147,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684398129/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684398129",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684401164"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684401164"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Good suggestion - that is more explicit.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:39:09Z",
            "diff_hunk": "@@ -328,6 +328,11 @@ def normalise_encoding_name(option_name, encoding):\n     'c_string_encoding': normalise_encoding_name,\n     'trashcan': bool,\n     'total_ordering': bool,\n+    'dataclasses.dataclass': Ellipsis,  # use Ellipsis as a flag to defer analysis of the arguments\n+            # instead of analysing it in InterpretCompilerDirectives. The dataclass directives are quite\n+            # complicated and it's easier to deal with them at the point the dataclass is created\n+            # TODO this may not be the best way of flagging it?",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684401164",
            "id": 684401164,
            "in_reply_to_id": 684236006,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQwMTE2NA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 334,
            "original_position": 7,
            "original_start_line": null,
            "path": "Cython/Compiler/Options.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684401164/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684401164",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684402898"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684402898"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Some of the code predates the invention of the boolean (or at least the invention of a specific boolean type in Python). It's mostly an artefact which is left unchanged because it works. But there's no reason for new code not to be more explicit.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:42:07Z",
            "diff_hunk": "@@ -257,6 +259,8 @@ class PyrexType(BaseType):\n     is_struct_or_union = 0\n     is_cpp_class = 0\n     is_optional_cpp_class = 0\n+    is_python_type_constructor = False\n+    is_special_python_type_constructor = False",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684402898",
            "id": 684402898,
            "in_reply_to_id": 684218469,
            "line": 263,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQwMjg5OA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 263,
            "original_position": 14,
            "original_start_line": 262,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": 14,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684402898/reactions"
            },
            "side": "RIGHT",
            "start_line": 262,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684402898",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684404007"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684404007"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I'd thought it was a quirk for Python 2 but it doesn't look to be needed. I'll delete...",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:44:10Z",
            "diff_hunk": "@@ -4398,6 +4404,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyObjectType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if self.base_type:\n+            # for a lot of the typing classes it doesn't really matter what the template it\n+            # (i.e. typing.Dict[int] is really just a dict)\n+            return self.base_type\n+        return self\n+\n+    def __repr__(self):\n+        if self.base_type:\n+            return \"%s[%r]\" % (self.name, self.base_type)\n+        else:\n+            return self.name\n+\n+    def __str__(self):\n+        return self.__repr__()",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684404007",
            "id": 684404007,
            "in_reply_to_id": 684219666,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQwNDAwNw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 4430,
            "original_position": 69,
            "original_start_line": 4429,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": null,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684404007/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684404007",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684406054"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684406054"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Only for `ClassVar`, `Optional`, `InitVar`, maybe a few others...\r\n\r\n`Tuple` is special-cased in `PythonTupleTypeConstructor` because it can take multiple types, and Cython can actually use them to make a C-tuple.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:47:57Z",
            "diff_hunk": "@@ -4398,6 +4404,110 @@ def error_condition(self, result_code):\n         return \"dummy\"\n \n \n+class PythonTypeConstructor(PyObjectType):\n+    \"\"\"Used to help Cython interpret indexed types from the typing module (or similar)\n+    \"\"\"\n+    is_python_type_constructor = True\n+\n+    def __init__(self, name, base_type=None):\n+        self.name = name\n+        self.base_type = base_type\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if self.base_type:\n+            # for a lot of the typing classes it doesn't really matter what the template it\n+            # (i.e. typing.Dict[int] is really just a dict)\n+            return self.base_type\n+        return self\n+\n+    def __repr__(self):\n+        if self.base_type:\n+            return \"%s[%r]\" % (self.name, self.base_type)\n+        else:\n+            return self.name\n+\n+    def __str__(self):\n+        return self.__repr__()\n+\n+    def is_template_type(self):\n+        return True\n+\n+\n+class PythonTupleTypeConstructor(PythonTypeConstructor):\n+    def specialize_here(self, pos, env, template_values=None):\n+        if (template_values and None not in template_values and\n+                not any(v.is_pyobject for v in template_values)):\n+            entry = env.declare_tuple_type(pos, template_values)\n+            if entry:\n+                return entry.type\n+        return super(PythonTupleTypeConstructor, self).specialize_here(pos, env, template_values)\n+\n+\n+class SpecialPythonTypeConstructor(PythonTypeConstructor):\n+    \"\"\"\n+    For things like ClassVar, Optional, etc, which have extra features on top of being\n+    a \"templated\" type\n+    \"\"\"\n+    is_special_python_type_constructor = True\n+\n+    @property\n+    def is_python_type_constructor(self):\n+        return not bool(self.template_type)\n+\n+    def __init__(self, name, template_type=None):\n+        super(SpecialPythonTypeConstructor, self).__init__(name, None)\n+        if (name == \"typing.ClassVar\" and template_type\n+                and not template_type.is_pyobject):\n+            # because classvars end up essentially used as globals they have\n+            # to be PyObjects. Try to find the nearest suitable type (although\n+            # practically I doubt this matters).\n+            py_type_name = template_type.py_type_name()\n+            if py_type_name:\n+                from .Builtin import builtin_scope\n+                template_type = (builtin_scope.lookup_type(py_type_name)\n+                                        or py_object_type)\n+            else:\n+                template_type = py_object_types\n+        self.template_type = template_type\n+\n+    def __getattribute__(self, attr):\n+        # order of lookup is:\n+        # 1. specifically overridden in this class or PythonTypeConstructor\n+        # 2. template type (if it exists)\n+        # 3. PyrexType\n+        dict_ = super(PythonTypeConstructor, self).__getattribute__(\"__dict__\")\n+        if attr in dict_:\n+            return dict_[attr]\n+        cls = super(PythonTypeConstructor, self).__getattribute__(\"__class__\")\n+        while issubclass(cls, PythonTypeConstructor):\n+            if attr in cls.__dict__:\n+                return super(PythonTypeConstructor, self).__getattribute__(attr)\n+            cls = cls.__base__\n+\n+        tt = super(PythonTypeConstructor, self).__getattribute__(\"template_type\")\n+        if tt:\n+            return getattr(tt, attr)\n+\n+        return super(PythonTypeConstructor, self).__getattribute__(attr)  # fallback to looking like a PyrexType\n+\n+    def __repr__(self):\n+        if self.template_type:\n+            return \"%s[%r]\" % (self.name, self.template_type)\n+        else:\n+            return self.name\n+\n+    def is_template_type(self):\n+        return self.template_type is None\n+\n+    def specialize_here(self, pos, env, template_values=None):\n+        if not self.is_template_type():\n+            error(pos, \"'%r' has already been specialized\" % self )\n+            return error_type\n+        if len(template_values) != 1:\n+            error(pos, \"'%s' takes exactly one template argument.\" % self.name)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684406054",
            "id": 684406054,
            "in_reply_to_id": 684222219,
            "line": 4504,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQwNjA1NA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 4507,
            "original_position": 146,
            "original_start_line": null,
            "path": "Cython/Compiler/PyrexTypes.py",
            "position": 143,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684406054/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:47Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684406054",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684411843"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684411843"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think this was copy-pasted from the CPython dataclasses module. Realistically it's unlikely to end up called - Cython should call with a controlled set of arguments and it's quite hard for a user to get access to this function (but not impossible probably).",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T17:57:52Z",
            "diff_hunk": "@@ -0,0 +1,98 @@\n+################### Dataclasses_fallback ###############################\n+\n+# This is the fallback dataclass code if the stdlib module isn't available.\n+# It defines enough of the support types to be used with cdef classes\n+# and to fail if used on regular types.\n+\n+# (Intended to be included as py code - not compiled)\n+\n+from collections import namedtuple\n+try:\n+    from types import MappingProxyType\n+except ImportError:\n+    # mutable fallback if unavailable\n+    MappingProxyType = lambda x: x\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+_DataclassParams = namedtuple('_DataclassParams',\n+    [\"init\", \"repr\", \"eq\", \"order\", \"unsafe_hash\", \"frozen\"])\n+class Field(object):\n+    __slots__ = ('name',\n+                 'type',\n+                 'default',\n+                 'default_factory',\n+                 'repr',\n+                 'hash',\n+                 'init',\n+                 'compare',\n+                 'metadata',\n+                 '_field_type',  # Private: not to be used by user code.\n+                 )\n+\n+    def __init__(self, default, default_factory, init, repr, hash, compare,\n+                 metadata):\n+        self.name = None\n+        self.type = None\n+        self.default = default\n+        self.default_factory = default_factory\n+        self.init = init\n+        self.repr = repr\n+        self.hash = hash\n+        self.compare = compare\n+        # Be aware that if MappingProxyType is unavailable (i.e. py2?) then we\n+        # don't enforce non-mutability that the real module does\n+        self.metadata = (MappingProxyType({})\n+                         if metadata is None else\n+                         MappingTypesProxy(metadata))\n+        self._field_type = None\n+\n+    def __repr__(self):\n+        return ('Field('\n+                'name={0!r},'\n+                'type={1!r},'\n+                'default={2!r},'\n+                'default_factory={3!r},'\n+                'init={4!r},'\n+                'repr={5!r},'\n+                'hash={6!r},'\n+                'compare={7!r},'\n+                'metadata={8!r},'\n+                ')'.format(self.name, self.type, self.default,\n+                           self.default_factory, self.init,\n+                           self.repr, self.hash, self.compare,\n+                           self.metadata))\n+\n+# A sentinel object for default values to signal that a default\n+# factory will be used.  This is given a nice repr() which will appear\n+# in the function signature of dataclasses' constructors.\n+class _HAS_DEFAULT_FACTORY_CLASS:\n+    def __repr__(self):\n+        return '<factory>'\n+_HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()\n+\n+_DATACLASS_MODULE_UNAVAILABLE_ERROR = (\"Standard library 'dataclasses' module\"\n+    \"is unavailable, likely due to the version of Python you're using.\")\n+\n+def dataclass(*args, **kwds):\n+    raise NotImplementedError(_DATACLASS_MODULE_UNAVAILABLE_ERROR)\n+\n+def field(*ignore, **kwds):\n+    default = kwds.pop(\"default\", MISSING)\n+    default_factory = kwds.pop(\"default_factory\", MISSING)\n+    init = kwds.pop(\"init\", True)\n+    repr = kwds.pop(\"repr\", True)\n+    hash = kwds.pop(\"hash\", None)\n+    compare = kwds.pop(\"compare\", True)\n+    metadata = kwds.pop(\"metadata\", None)\n+\n+    if kwds:\n+        raise ValueError(\"field received unexpected keyword arguments: %s\"\n+                         % list(kwds.keys()))\n+    if default is not MISSING and default_factory is not MISSING:\n+        raise ValueError('cannot specify both default and default_factory')\n+    if ignore:\n+        raise ValueError(\"'field' does not take any positional arguments\")",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684411843",
            "id": 684411843,
            "in_reply_to_id": 684247925,
            "line": 105,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQxMTg0Mw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 97,
            "original_position": 97,
            "original_start_line": 96,
            "path": "Cython/Utility/Dataclasses.py",
            "position": 105,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684411843/reactions"
            },
            "side": "RIGHT",
            "start_line": 104,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684411843",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684414070"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684414070"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Currently `@cython.dataclasses.dataclass` requires it to be a `cdef class` but doesn't change it to one (that applies in both regular mode and pure-Python mode).\r\n\r\nI'm not convinced it should be assumed to be an extension type. I see why it might be nice, but for now I think it might be better left explicit.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T18:01:53Z",
            "diff_hunk": "@@ -1051,5 +1051,27 @@ generated containing declarations for its object struct and type object. By\n including the ``.h`` file in external C code that you write, that code can\n access the attributes of the extension type.\n \n+Dataclass extension types\n+=========================",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684414070",
            "id": 684414070,
            "in_reply_to_id": 684253371,
            "line": 1055,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQxNDA3MA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 1055,
            "original_position": 5,
            "original_start_line": 1054,
            "path": "docs/src/userguide/extension_types.rst",
            "position": 5,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684414070/reactions"
            },
            "side": "RIGHT",
            "start_line": 1054,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684414070",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684414938"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684414938"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "`from` is right here",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T18:03:34Z",
            "diff_hunk": "@@ -1051,5 +1051,27 @@ generated containing declarations for its object struct and type object. By\n including the ``.h`` file in external C code that you write, that code can\n access the attributes of the extension type.\n \n+Dataclass extension types\n+=========================\n \n+Cython supports extension types that behave like the dataclasses defined in\n+the Python 3.7+ standard library. The main benefit of using a dataclass is\n+that it can auto-generate simple `__init__`, `__repr__` and comparison\n+functions. The Cython implementation behaves as much like the Python\n+standard library implementation as possible and therefore the documentation\n+here only briefly outlines the differences - if you plan on using them\n+then please read `the documentation for the standard library module\n+<https://docs.python.org/3/library/dataclasses.html>`_.\n+\n+Dataclasses can be declared using the `@cython.dataclass` decorator. If\n+you need to define special properties on a field then use `cython.field`\n+\n+.. literalinclude:: ../../examples/userguide/extension_types/dataclass.pyx    \n+\n+You may use C-level types such as structs, pointers, or C++ classes.\n+However, you may find these types are not compatible with the auto-generated\n+special methods - for example if they cannot be converted from a Python",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684414938",
            "id": 684414938,
            "in_reply_to_id": 684251341,
            "line": 1076,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQxNDkzOA==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 1073,
            "original_position": 23,
            "original_start_line": null,
            "path": "docs/src/userguide/extension_types.rst",
            "position": 27,
            "pull_request_review_id": 724546934,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684414938/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684414938",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684431557"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684431557"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The reasoning being that if someone wanted a normal dataclass even when cythonized, they would use `@dataclasses.dataclass`. I can agree on the explicitness though this is good.\r\n\r\nCould you make a note of the answers to my questions in the documentation?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T18:34:51Z",
            "diff_hunk": "@@ -1051,5 +1051,27 @@ generated containing declarations for its object struct and type object. By\n including the ``.h`` file in external C code that you write, that code can\n access the attributes of the extension type.\n \n+Dataclass extension types\n+=========================",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684431557",
            "id": 684431557,
            "in_reply_to_id": 684253371,
            "line": 1055,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQzMTU1Nw==",
            "original_commit_id": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "original_line": 1055,
            "original_position": 5,
            "original_start_line": 1054,
            "path": "docs/src/userguide/extension_types.rst",
            "position": 5,
            "pull_request_review_id": 724617746,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684431557/reactions"
            },
            "side": "RIGHT",
            "start_line": 1054,
            "start_side": "RIGHT",
            "updated_at": "2021-08-06T18:34:51Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684431557",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r684432679"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/684432679"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "You actually don't need these parenthesis?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-06T18:36:42Z",
            "diff_hunk": "@@ -241,11 +240,11 @@ def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n     code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n                             ).substitute(placeholders)\n \n-    stats.stats = stats.stats + code_tree.stats + extra_stats\n+    stats.stats += (code_tree.stats + extra_stats)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r684432679",
            "id": 684432679,
            "line": 250,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NDQzMjY3OQ==",
            "original_commit_id": "0245526b349e313858e4faf4e3099fe4095917c2",
            "original_line": 243,
            "original_position": 55,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 250,
            "pull_request_review_id": 724618965,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/684432679/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-06T18:40:15Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/684432679",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686358016"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686358016"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "There's actually something I've been meaning to ask, when does this raise `ImportError`? Before Python 3.6?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-10T22:17:17Z",
            "diff_hunk": "@@ -0,0 +1,38 @@\n+# mode: run\n+\n+import cython\n+\n+try:\n+    import typing\n+    from typing import List\n+    from typing import Set as _SET_\n+except ImportError:\n+    pass  # this should allow Cython to interpret the directives even when the module doesn't exist",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686358016",
            "id": 686358016,
            "line": 10,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjM1ODAxNg==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 10,
            "original_position": 10,
            "original_start_line": null,
            "path": "tests/run/typing_module_cy.pyx",
            "position": 10,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686358016/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:30:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686358016",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686358899"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686358899"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Unnecessary to have it `_WARNINGS` like that.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-10T22:19:26Z",
            "diff_hunk": "@@ -161,13 +158,58 @@ def literal_list_ptr():\n     return a[3]\n \n \n+def test_subscripted_types():\n+    \"\"\"\n+    >>> test_subscripted_types()\n+    dict object\n+    list object\n+    set object\n+    \"\"\"\n+    a: typing.Dict[int, float] = {}\n+    b: List[int] = []\n+    c: _SET_[object] = set()\n+\n+    print(cython.typeof(a) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(b) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(c) + (\" object\" if not cython.compiled else \"\"))\n+\n+# because tuple is specifically special cased to go to ctuple where possible\n+def test_tuple(a : typing.Tuple[int, float], b : typing.Tuple[int, ...],\n+               c : Tuple[int, object]  # cannot be a ctuple\n+               ):\n+    \"\"\"\n+    >>> test_tuple((1, 1.0), (1, 1.0), (1, 1.0))\n+    int\n+    int\n+    tuple object\n+    tuple object\n+    \"\"\"\n+    x: typing.Tuple[int, float] = (a[0], a[1])\n+    y: Tuple[int, ...] = (1,2.)\n+    z = a[0]  # should infer to int\n+\n+    print(cython.typeof(z))\n+    print(cython.typeof(x[0]))\n+    print(cython.typeof(y) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(c) + (\" object\" if not cython.compiled else \"\"))\n+\n+\n+if cython.compiled:\n+    __doc__ = \"\"\"\n+    # passing non-dicts to variables declared as dict now fails\n+    >>> class D(object):\n+    ...     def __getitem__(self, x): return 2\n+    ...     def __iter__(self): return iter([1, 2, 3])\n+    >>> iter_declared_dict(D())  # doctest:+IGNORE_EXCEPTION_DETAIL\n+    Traceback (most recent call last):\n+    ...\n+    TypeError: Expected dict, got D\n+    >>> iter_declared_dict_arg(D())  # doctest:+IGNORE_EXCEPTION_DETAIL\n+    Traceback (most recent call last):\n+    ...\n+    TypeError: Expected dict, got D\n+    \"\"\"\n+\n+\n _WARNINGS = \"\"\"\n-37:19: Unknown type declaration in annotation, ignoring\n-38:12: Unknown type declaration in annotation, ignoring\n-39:18: Unknown type declaration in annotation, ignoring\n-73:11: Annotation ignored since class-level attributes must be Python objects. Were you trying to set up an instance attribute?\n-73:19: Unknown type declaration in annotation, ignoring\n-# FIXME: these are sort-of evaluated now, so the warning is misleading\n-126:21: Unknown type declaration in annotation, ignoring\n-137:35: Unknown type declaration in annotation, ignoring\n \"\"\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686358899",
            "id": 686358899,
            "line": 215,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjM1ODg5OQ==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 215,
            "original_position": 116,
            "original_start_line": 214,
            "path": "tests/run/pep526_variable_annotations.py",
            "position": 116,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686358899/reactions"
            },
            "side": "RIGHT",
            "start_line": 214,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T01:30:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686358899",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686420687"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686420687"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    names = [name for name, field in fields.items() if (field.compare.value and not field.is_initvar)]\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:09:54Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686420687",
            "id": 686420687,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyMDY4Nw==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 396,
            "original_position": 396,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686420687/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:30:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686420687",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686421110"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686421110"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "When you do it like this they look connected\n\n```suggestion\n            name, op, name))\n\n    if checks:\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:11:17Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686421110",
            "id": 686421110,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyMTExMA==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 424,
            "original_position": 424,
            "original_start_line": 423,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686421110/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T01:30:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686421110",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686421338"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686421338"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    strs = [u\"%s={self.%s}\" % (name, name)\n            for name, field in fields.items()\n            if field.repr.value and not field.is_initvar]\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:12:02Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686421338",
            "id": 686421338,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyMTMzOA==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 385,
            "original_position": 385,
            "original_start_line": 384,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686421338/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T01:30:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686421338",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686422883"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686422883"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n    elif not unsafe_hash:\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:16:51Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686422883",
            "id": 686422883,
            "line": 512,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyMjg4Mw==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 503,
            "original_position": 503,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 512,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686422883/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:30:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686422883",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686422958"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686422958"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n        elif not eq:\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:17:04Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686422958",
            "id": 686422958,
            "line": 517,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyMjk1OA==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 508,
            "original_position": 508,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 517,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686422958/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:30:48Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686422958",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686423461"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686423461"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n        if not field.is_initvar and (field.hash.value or field.compare.value)\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:18:44Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686423461",
            "id": 686423461,
            "line": 523,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyMzQ2MQ==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 514,
            "original_position": 514,
            "original_start_line": 513,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 523,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686423461/reactions"
            },
            "side": "RIGHT",
            "start_line": 522,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T01:30:49Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686423461",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686423734"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686423734"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Could remove this, or if anything move it up a few lines. After the `return`s.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:19:49Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686423734",
            "id": 686423734,
            "line": 531,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyMzczNA==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 522,
            "original_position": 522,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 531,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686423734/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:30:49Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686423734",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686424060"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686424060"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Do you mean `PyType_Type`?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:20:42Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686424060",
            "id": 686424060,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyNDA2MA==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 532,
            "original_position": 532,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686424060/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:30:49Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686424060",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686424278"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686424278"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n                names = [name.strip(\"() \") for name in py_name.split(\",\")]\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:21:18Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object.\n+    # Initialize with \"entry\".\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686424278",
            "id": 686424278,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyNDI3OA==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 552,
            "original_position": 552,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686424278/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:30:49Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686424278",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686424797"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686424797"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The if-statement isn't necessary, if the list is empty it simply won't loop at all.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:22:56Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object.\n+    # Initialize with \"entry\".\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    nn = nn.analyse_types(env)\n+                    if nn.entry:\n+                        return nn",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686424797",
            "id": 686424797,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyNDc5Nw==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 559,
            "original_position": 559,
            "original_start_line": 553,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686424797/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T01:30:49Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686424797",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686425093"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686425093"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Could this not be tidied up and used as a doc-string? (Do the same for GetTypeNode).",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:23:55Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object.\n+    # Initialize with \"entry\".\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    nn = nn.analyse_types(env)\n+                    if nn.entry:\n+                        return nn\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.annotation.string.value if self.entry.annotation else None\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686425093",
            "id": 686425093,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyNTA5Mw==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 570,
            "original_position": 570,
            "original_start_line": 569,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686425093/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T01:30:49Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686425093",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686426485"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686426485"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n            [(ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n               FieldsValueNode(node.pos, arg=v))\n              for k, v in field.__dict__.items() if k not in [\"is_initvar\", \"private\"]]\n```\n",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:28:13Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object.\n+    # Initialize with \"entry\".\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    nn = nn.analyse_types(env)\n+                    if nn.entry:\n+                        return nn\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.annotation.string.value if self.entry.annotation else None\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string\n+    subexprs = ['arg']\n+\n+    def __init__(self, pos, arg):\n+        super(FieldsValueNode, self).__init__(pos, arg=arg)\n+\n+    def analyse_types(self, env):\n+        self.arg.analyse_types(env)\n+        self.type = self.arg.type\n+        return self\n+\n+    def coerce_to_pyobject(self, env):\n+        if self.arg.type.can_coerce_to_pyobject(env):\n+            return self.arg.coerce_to_pyobject(env)\n+        else:\n+            # A string representation of the code that gave the field seems like a reasonable\n+            # fallback. This'll mostly happen for \"default\" and \"default_factory\" where the\n+            # type may be a C-type that can't be converted to Python.\n+            return self._make_string()\n+\n+    def _make_string(self):\n+        from .AutoDocTransforms import AnnotationWriter\n+        writer = AnnotationWriter(description=\"Dataclass field\")\n+        string = writer.write(self.arg)\n+        return ExprNodes.StringNode(self.pos, value=EncodedString(string))\n+\n+    def generate_evaluation_code(self, code):\n+        return self.arg.generate_evaluation_code(code)\n+\n+\n+def _set_up_dataclass_fields(node, fields, dataclass_module):\n+    # For defaults and default_factories containing things like lambda,\n+    # they're already declared in the class scope, and it creates a big\n+    # problem if multiple copies are floating around in both the __init__\n+    # function, and in the __dataclass_fields__ structure.\n+    # Therefore, create module-level constants holding these values and\n+    # pass those around instead\n+    #\n+    # If possible we use the `Field` class defined in the standard library\n+    # module so that the information stored here is as close to a regular\n+    # dataclass as is possible.\n+    variables_assignment_stats = []\n+    for name, field in fields.items():\n+        if field.private:\n+            continue  # doesn't appear in the public interface\n+        for attrname in [ \"default\", \"default_factory\" ]:\n+            f_def = getattr(field, attrname)\n+            if f_def is MISSING or f_def.is_literal or f_def.is_name:\n+                # some simple cases where we don't need to set up\n+                # the variable as a module-level constant\n+                continue\n+            global_scope = node.scope.global_scope()\n+            module_field_name = global_scope.mangle(\n+                global_scope.mangle(Naming.dataclass_field_default_cname, node.class_name),\n+                name)\n+            # create an entry in the global scope for this variable to live\n+            nn = ExprNodes.NameNode(f_def.pos, name=EncodedString(module_field_name))\n+            nn.entry = global_scope.declare_var(nn.name, type=f_def.type or PyrexTypes.unspecified_type,\n+                                                pos=f_def.pos, cname=nn.name, is_cdef=1)\n+            # replace the field so that future users just receive the namenode\n+            setattr(field, attrname, nn)\n+\n+            variables_assignment_stats.append(\n+                Nodes.SingleAssignmentNode(f_def.pos,\n+                                           lhs = nn,\n+                                           rhs = f_def))\n+\n+    placeholders = {}\n+    field_func = ExprNodes.AttributeNode(node.pos, obj = dataclass_module,\n+                                         attribute=EncodedString(\"field\"))\n+    dc_fields = ExprNodes.DictNode(node.pos, key_value_pairs=[])\n+    dc_fields_namevalue_assignments = []\n+    for name, field in fields.items():\n+        if field.private:\n+            continue  # doesn't appear in the public interface\n+        placeholder_name = \"PLACEHOLDER_%s\" % name\n+        placeholders[placeholder_name] = GetTypeNode(node.scope.entries[name])\n+\n+        if field.is_initvar:\n+            continue\n+\n+        dc_field_keywords = ExprNodes.DictNode.from_pairs(\n+            node.pos,\n+            [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+               FieldsValueNode(node.pos, arg=v))\n+              for k, v in field.__dict__.items() if k not in [\"is_initvar\", \"private\"] ]",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686426485",
            "id": 686426485,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyNjQ4NQ==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 655,
            "original_position": 655,
            "original_start_line": 653,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686426485/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T01:30:49Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686426485",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686427176"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686427176"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Is there a reason that we loop through twice? I assume that it is because the second loop depends on the first loop having done the work for each item, or that it's simply for sectioning?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:30:23Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object.\n+    # Initialize with \"entry\".\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    nn = nn.analyse_types(env)\n+                    if nn.entry:\n+                        return nn\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.annotation.string.value if self.entry.annotation else None\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string\n+    subexprs = ['arg']\n+\n+    def __init__(self, pos, arg):\n+        super(FieldsValueNode, self).__init__(pos, arg=arg)\n+\n+    def analyse_types(self, env):\n+        self.arg.analyse_types(env)\n+        self.type = self.arg.type\n+        return self\n+\n+    def coerce_to_pyobject(self, env):\n+        if self.arg.type.can_coerce_to_pyobject(env):\n+            return self.arg.coerce_to_pyobject(env)\n+        else:\n+            # A string representation of the code that gave the field seems like a reasonable\n+            # fallback. This'll mostly happen for \"default\" and \"default_factory\" where the\n+            # type may be a C-type that can't be converted to Python.\n+            return self._make_string()\n+\n+    def _make_string(self):\n+        from .AutoDocTransforms import AnnotationWriter\n+        writer = AnnotationWriter(description=\"Dataclass field\")\n+        string = writer.write(self.arg)\n+        return ExprNodes.StringNode(self.pos, value=EncodedString(string))\n+\n+    def generate_evaluation_code(self, code):\n+        return self.arg.generate_evaluation_code(code)\n+\n+\n+def _set_up_dataclass_fields(node, fields, dataclass_module):\n+    # For defaults and default_factories containing things like lambda,\n+    # they're already declared in the class scope, and it creates a big\n+    # problem if multiple copies are floating around in both the __init__\n+    # function, and in the __dataclass_fields__ structure.\n+    # Therefore, create module-level constants holding these values and\n+    # pass those around instead\n+    #\n+    # If possible we use the `Field` class defined in the standard library\n+    # module so that the information stored here is as close to a regular\n+    # dataclass as is possible.\n+    variables_assignment_stats = []\n+    for name, field in fields.items():\n+        if field.private:\n+            continue  # doesn't appear in the public interface\n+        for attrname in [ \"default\", \"default_factory\" ]:\n+            f_def = getattr(field, attrname)\n+            if f_def is MISSING or f_def.is_literal or f_def.is_name:\n+                # some simple cases where we don't need to set up\n+                # the variable as a module-level constant\n+                continue\n+            global_scope = node.scope.global_scope()\n+            module_field_name = global_scope.mangle(\n+                global_scope.mangle(Naming.dataclass_field_default_cname, node.class_name),\n+                name)\n+            # create an entry in the global scope for this variable to live\n+            nn = ExprNodes.NameNode(f_def.pos, name=EncodedString(module_field_name))\n+            nn.entry = global_scope.declare_var(nn.name, type=f_def.type or PyrexTypes.unspecified_type,\n+                                                pos=f_def.pos, cname=nn.name, is_cdef=1)\n+            # replace the field so that future users just receive the namenode\n+            setattr(field, attrname, nn)\n+\n+            variables_assignment_stats.append(\n+                Nodes.SingleAssignmentNode(f_def.pos,\n+                                           lhs = nn,\n+                                           rhs = f_def))\n+\n+    placeholders = {}\n+    field_func = ExprNodes.AttributeNode(node.pos, obj = dataclass_module,\n+                                         attribute=EncodedString(\"field\"))\n+    dc_fields = ExprNodes.DictNode(node.pos, key_value_pairs=[])\n+    dc_fields_namevalue_assignments = []\n+    for name, field in fields.items():",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686427176",
            "id": 686427176,
            "line": 655,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQyNzE3Ng==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 642,
            "original_position": 642,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 655,
            "pull_request_review_id": 726890936,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686427176/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:30:49Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686427176",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686435157"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686435157"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The Python standards say that in situation with `if ...: return x` the next should be `if` and not `elif`",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T01:55:11Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686435157",
            "id": 686435157,
            "in_reply_to_id": 686422883,
            "line": 512,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQzNTE1Nw==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 503,
            "original_position": 503,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 512,
            "pull_request_review_id": 726978708,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686435157/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T01:55:26Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686435157",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/52697657?v=4",
                "events_url": "https://api.github.com/users/0dminnimda/events{/privacy}",
                "followers_url": "https://api.github.com/users/0dminnimda/followers",
                "following_url": "https://api.github.com/users/0dminnimda/following{/other_user}",
                "gists_url": "https://api.github.com/users/0dminnimda/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/0dminnimda",
                "id": 52697657,
                "login": "0dminnimda",
                "node_id": "MDQ6VXNlcjUyNjk3NjU3",
                "organizations_url": "https://api.github.com/users/0dminnimda/orgs",
                "received_events_url": "https://api.github.com/users/0dminnimda/received_events",
                "repos_url": "https://api.github.com/users/0dminnimda/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/0dminnimda/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/0dminnimda/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/0dminnimda"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686436855"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686436855"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Same as [here](https://github.com/cython/cython/pull/3400/files/8b6c998c56013dab6178f795a5adbfbb34955f4b?file-filters%5B%5D=.c&file-filters%5B%5D=.pyx#r686435157)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T02:00:38Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686436855",
            "id": 686436855,
            "in_reply_to_id": 686422958,
            "line": 517,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQzNjg1NQ==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 508,
            "original_position": 508,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 517,
            "pull_request_review_id": 726980691,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686436855/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T02:00:55Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686436855",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/52697657?v=4",
                "events_url": "https://api.github.com/users/0dminnimda/events{/privacy}",
                "followers_url": "https://api.github.com/users/0dminnimda/followers",
                "following_url": "https://api.github.com/users/0dminnimda/following{/other_user}",
                "gists_url": "https://api.github.com/users/0dminnimda/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/0dminnimda",
                "id": 52697657,
                "login": "0dminnimda",
                "node_id": "MDQ6VXNlcjUyNjk3NjU3",
                "organizations_url": "https://api.github.com/users/0dminnimda/orgs",
                "received_events_url": "https://api.github.com/users/0dminnimda/received_events",
                "repos_url": "https://api.github.com/users/0dminnimda/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/0dminnimda/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/0dminnimda/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/0dminnimda"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686439319"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686439319"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "We have `names = None` several lines higher, and it's not always `py_name`, i.e. `names` not always becomes a list and stays None.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T02:08:40Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object.\n+    # Initialize with \"entry\".\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    nn = nn.analyse_types(env)\n+                    if nn.entry:\n+                        return nn",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686439319",
            "id": 686439319,
            "in_reply_to_id": 686424797,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQzOTMxOQ==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 559,
            "original_position": 559,
            "original_start_line": 553,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726983501,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686439319/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T02:09:15Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686439319",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/52697657?v=4",
                "events_url": "https://api.github.com/users/0dminnimda/events{/privacy}",
                "followers_url": "https://api.github.com/users/0dminnimda/followers",
                "following_url": "https://api.github.com/users/0dminnimda/following{/other_user}",
                "gists_url": "https://api.github.com/users/0dminnimda/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/0dminnimda",
                "id": 52697657,
                "login": "0dminnimda",
                "node_id": "MDQ6VXNlcjUyNjk3NjU3",
                "organizations_url": "https://api.github.com/users/0dminnimda/orgs",
                "received_events_url": "https://api.github.com/users/0dminnimda/received_events",
                "repos_url": "https://api.github.com/users/0dminnimda/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/0dminnimda/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/0dminnimda/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/0dminnimda"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686441065"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686441065"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Oh? PEP8?\n\nI always use `elif` as this is much clearer to the user. Even though you get the same result, with one of them you get a clear \"either this happens, or this happens\".",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T02:14:08Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686441065",
            "id": 686441065,
            "in_reply_to_id": 686422883,
            "line": 512,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQ0MTA2NQ==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 503,
            "original_position": 503,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 512,
            "pull_request_review_id": 726985572,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686441065/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T02:14:09Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686441065",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686441552"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686441552"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Oh right, I see now.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T02:15:33Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object.\n+    # Initialize with \"entry\".\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    nn = nn.analyse_types(env)\n+                    if nn.entry:\n+                        return nn",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686441552",
            "id": 686441552,
            "in_reply_to_id": 686424797,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjQ0MTU1Mg==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 559,
            "original_position": 559,
            "original_start_line": 553,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 726986105,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686441552/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "updated_at": "2021-08-11T02:15:34Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686441552",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686541573"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686541573"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The typing module was added on Cpython version 3.5, so this would be for all versions before that.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T06:41:23Z",
            "diff_hunk": "@@ -0,0 +1,38 @@\n+# mode: run\n+\n+import cython\n+\n+try:\n+    import typing\n+    from typing import List\n+    from typing import Set as _SET_\n+except ImportError:\n+    pass  # this should allow Cython to interpret the directives even when the module doesn't exist",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686541573",
            "id": 686541573,
            "in_reply_to_id": 686358016,
            "line": 10,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjU0MTU3Mw==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 10,
            "original_position": 10,
            "original_start_line": null,
            "path": "tests/run/typing_module_cy.pyx",
            "position": 10,
            "pull_request_review_id": 727104069,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686541573/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T06:41:23Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686541573",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/29100934?v=4",
                "events_url": "https://api.github.com/users/davfsa/events{/privacy}",
                "followers_url": "https://api.github.com/users/davfsa/followers",
                "following_url": "https://api.github.com/users/davfsa/following{/other_user}",
                "gists_url": "https://api.github.com/users/davfsa/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/davfsa",
                "id": 29100934,
                "login": "davfsa",
                "node_id": "MDQ6VXNlcjI5MTAwOTM0",
                "organizations_url": "https://api.github.com/users/davfsa/orgs",
                "received_events_url": "https://api.github.com/users/davfsa/received_events",
                "repos_url": "https://api.github.com/users/davfsa/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/davfsa/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/davfsa/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/davfsa"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r686542736"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/686542736"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "There is both a tiny speedup (the result of the last if isn't checked) and code looking nicer when using `if` after `return`",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-11T06:43:33Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r686542736",
            "id": 686542736,
            "in_reply_to_id": 686422883,
            "line": 512,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4NjU0MjczNg==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 503,
            "original_position": 503,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 512,
            "pull_request_review_id": 727105544,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/686542736/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-11T06:43:34Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/686542736",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/29100934?v=4",
                "events_url": "https://api.github.com/users/davfsa/events{/privacy}",
                "followers_url": "https://api.github.com/users/davfsa/followers",
                "following_url": "https://api.github.com/users/davfsa/following{/other_user}",
                "gists_url": "https://api.github.com/users/davfsa/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/davfsa",
                "id": 29100934,
                "login": "davfsa",
                "node_id": "MDQ6VXNlcjI5MTAwOTM0",
                "organizations_url": "https://api.github.com/users/davfsa/orgs",
                "received_events_url": "https://api.github.com/users/davfsa/received_events",
                "repos_url": "https://api.github.com/users/davfsa/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/davfsa/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/davfsa/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/davfsa"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r689459238"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/689459238"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I'll leave this (and the similar one) because I find the plain `if` version clearer.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-16T11:36:34Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r689459238",
            "id": 689459238,
            "in_reply_to_id": 686422883,
            "line": 512,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTQ1OTIzOA==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 503,
            "original_position": 503,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 512,
            "pull_request_review_id": 730611608,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/689459238/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-16T12:35:50Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/689459238",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r689460690"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/689460690"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I do. I'll change it when it I next have to push to the branch (I don't think it's likely to significantly mislead in the mean-time)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-16T11:39:05Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r689460690",
            "id": 689460690,
            "in_reply_to_id": 686424060,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTQ2MDY5MA==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 532,
            "original_position": 532,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 730611608,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/689460690/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-16T12:35:50Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/689460690",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r689468786"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/689468786"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I think it is possible to refactor into a single loop (so I've done that). I doubt it makes too much difference though",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-16T11:51:53Z",
            "diff_hunk": "@@ -0,0 +1,686 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+    args = u\", \".join(args)\n+    func_call = u\"def __init__(%s):\" % args\n+\n+    code_lines = [\n+        func_call,\n+        \"    pass\",  # just in-case it's an empty body\n+    ]\n+    for name, field in fields.items():\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [ u\"%s={self.%s}\" % (name, name)\n+            for name, field in fields.items() if field.repr.value and not field.is_initvar ]\n+    format_string = u\", \".join(strs)\n+    code_lines.append(u\"    return f'{type(self).__name__}(%s)'\" % format_string)\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_cmp_code(op, funcname, node, fields):\n+    if node.scope.lookup_here(funcname):\n+        return \"\", {}, []\n+\n+    names = [ name for name, field in fields.items() if (field.compare.value and not field.is_initvar) ]\n+\n+    if not names:\n+        return \"\", {}, []  # no comparable types\n+\n+    code_lines = [\n+        \"def %s(self, other):\" % funcname,\n+        \"    cdef %s other_cast\" % node.class_name,\n+        \"    if isinstance(other, %s):\" % node.class_name,\n+        \"        other_cast = <%s>other\" % node.class_name,\n+        \"    else:\",\n+        \"        return NotImplemented\"\n+    ]\n+\n+    # The Python implementation of dataclasses.py does a tuple comparison\n+    # (roughly):\n+    #  return self._attributes_to_tuple() {op} other._attributes_to_tuple()\n+    #\n+    # For the Cython implementation a tuple comparison isn't an option because\n+    # not all attributes can be converted to Python objects and stored in a tuple\n+    #\n+    # TODO - better diagnostics of whether the types support comparison before\n+    #    generating the code. Plus, do we want to convert C structs to dicts and\n+    #    compare them that way (I think not, but it might be in demand)?\n+    checks = []\n+    for name in names:\n+        checks.append(\"(self.%s %s other_cast.%s)\" % (\n+            name, op, name))\n+    if checks:\n+        code_lines.append(\"    return \" + \" and \".join(checks))\n+    else:\n+        if \"=\" in op:\n+            code_lines.append(\"    return True\")  # \"() == ()\" is True\n+        else:\n+            code_lines.append(\"    return False\")\n+\n+    code_lines = u\"\\n\".join(code_lines)\n+\n+    return code_lines, {}, []\n+\n+def generate_eq_code(eq, node, fields):\n+    if not eq:\n+        return code_lines, {}, []\n+    return generate_cmp_code(\"==\", \"__eq__\", node, fields)\n+\n+def generate_order_code(order, node, fields):\n+    if not order:\n+        return \"\", {}, []\n+    code_lines = []\n+    placeholders = {}\n+    stats = []\n+    for op, name in [(\"<\", \"__lt__\"),\n+                     (\"<=\", \"__le__\"),\n+                     (\">\", \"__gt__\"),\n+                     (\">=\", \"__ge__\")]:\n+        res = generate_cmp_code(op, name, node, fields)\n+        code_lines.append(res[0])\n+        placeholders.update(res[1])\n+        stats.extend(res[2])\n+    return \"\\n\".join(code_lines), placeholders, stats\n+\n+def generate_hash_code(unsafe_hash, eq, frozen, node, fields):\n+    \"\"\"\n+    Copied from CPython implementation - the intention is to follow this as far as\n+    is possible:\n+    #    +------------------- unsafe_hash= parameter\n+    #    |       +----------- eq= parameter\n+    #    |       |       +--- frozen= parameter\n+    #    |       |       |\n+    #    v       v       v    |        |        |\n+    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__\n+    # +=======+=======+=======+========+========+\n+    # | False | False | False |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | False | True  |        |        | No __eq__, use the base class __hash__\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | False | None   |        | <-- the default, not hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | False | True  | True  | add    |        | Frozen, so hashable, allows override\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | False | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | False | add    | raise  | Not frozen, but hashable\n+    # +-------+-------+-------+--------+--------+\n+    # | True  | True  | True  | add    | raise  | Frozen, so hashable\n+    # +=======+=======+=======+========+========+\n+    # For boxes that are blank, __hash__ is untouched and therefore\n+    # inherited from the base class.  If the base is object, then\n+    # id-based hashing is used.\n+\n+    The Python implementation creates a tuple of all the fields, then hashes them.\n+    This implementation creates a tuple of all the hashes of all the fields and hashes that.\n+    The reason for this slight difference is to avoid to-Python conversions for anything\n+    that Cython knows how to hash directly (It doesn't look like this currently applies to\n+    anything though...).\n+    \"\"\"\n+\n+    hash_entry = node.scope.lookup_here(\"__hash__\")\n+    if hash_entry:\n+        # TODO ideally assignment of __hash__ to None shouldn't trigger this\n+        # but difficult to get the right information here\n+        if unsafe_hash:\n+            # error message taken from CPython dataclasses module\n+            error(node.pos, \"Cannot overwrite attribute __hash__ in class %s\" % node.class_name)\n+        return \"\", {}, []\n+    if not unsafe_hash:\n+        if eq and not frozen:\n+            return \"\", {}, [ Nodes.SingleAssignmentNode(node.pos,\n+                             lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__hash__\")),\n+                             rhs = ExprNodes.NoneNode(node.pos)) ]\n+        if not eq:\n+            return\n+\n+    names = [\n+        name for name, field in fields.items()\n+        if (not field.is_initvar and\n+            (field.compare.value if field.hash.value is None else field.hash.value))\n+    ]\n+    if not names:\n+        return \"\", {}, []  # nothing to hash\n+\n+    # make a tuple of the hashes\n+    tpl = u\", \".join(u\"hash(self.%s)\" % name for name in names )\n+\n+    # if we're here we want to generate a hash\n+    code_lines = dedent(u\"\"\"\\\n+        def __hash__(self):\n+            return hash((%s))\n+        \"\"\") % tpl\n+\n+    return code_lines, {}, []\n+\n+\n+class GetTypeNode(ExprNodes.ExprNode):\n+    # Tries to return a pytype_type if possible. However contains\n+    # some fallback provision if it turns out not to resolve to a Python object.\n+    # Initialize with \"entry\".\n+\n+    subexprs = []\n+\n+    def __init__(self, entry):\n+        super(GetTypeNode, self).__init__(entry.pos, entry=entry)\n+\n+    def analyse_types(self, env):\n+        type = self.entry.type\n+\n+        if type.is_extension_type or type.is_builtin_type:\n+            return ExprNodes.RawCNameExprNode(\n+                self.pos, Builtin.type_type, type.typeptr_cname).analyse_types(env)\n+        else:\n+            names = None\n+            py_name = type.py_type_name()\n+            # int types can return \"(int, long)\"\n+            if py_name:\n+                names = [ name.strip(\"() \") for name in py_name.split(\",\") ]\n+            if names:\n+                for name in names:\n+                    name = EncodedString(name)\n+                    nn = ExprNodes.NameNode(self.pos, name=name)\n+                    nn = nn.analyse_types(env)\n+                    if nn.entry:\n+                        return nn\n+\n+        # otherwise we're left to return a string\n+        s = self.entry.annotation.string.value if self.entry.annotation else None\n+        if not s:\n+            s = self.entry.type.declaration_code(\"\", for_display=1)\n+        return ExprNodes.StringNode(self.pos, value=s).analyse_types(env)\n+\n+\n+class FieldsValueNode(ExprNodes.ExprNode):\n+    # largely just forwards arg. Allows it to be coerced to a Python object\n+    # if possible, and if not then generates a sensible backup string\n+    subexprs = ['arg']\n+\n+    def __init__(self, pos, arg):\n+        super(FieldsValueNode, self).__init__(pos, arg=arg)\n+\n+    def analyse_types(self, env):\n+        self.arg.analyse_types(env)\n+        self.type = self.arg.type\n+        return self\n+\n+    def coerce_to_pyobject(self, env):\n+        if self.arg.type.can_coerce_to_pyobject(env):\n+            return self.arg.coerce_to_pyobject(env)\n+        else:\n+            # A string representation of the code that gave the field seems like a reasonable\n+            # fallback. This'll mostly happen for \"default\" and \"default_factory\" where the\n+            # type may be a C-type that can't be converted to Python.\n+            return self._make_string()\n+\n+    def _make_string(self):\n+        from .AutoDocTransforms import AnnotationWriter\n+        writer = AnnotationWriter(description=\"Dataclass field\")\n+        string = writer.write(self.arg)\n+        return ExprNodes.StringNode(self.pos, value=EncodedString(string))\n+\n+    def generate_evaluation_code(self, code):\n+        return self.arg.generate_evaluation_code(code)\n+\n+\n+def _set_up_dataclass_fields(node, fields, dataclass_module):\n+    # For defaults and default_factories containing things like lambda,\n+    # they're already declared in the class scope, and it creates a big\n+    # problem if multiple copies are floating around in both the __init__\n+    # function, and in the __dataclass_fields__ structure.\n+    # Therefore, create module-level constants holding these values and\n+    # pass those around instead\n+    #\n+    # If possible we use the `Field` class defined in the standard library\n+    # module so that the information stored here is as close to a regular\n+    # dataclass as is possible.\n+    variables_assignment_stats = []\n+    for name, field in fields.items():\n+        if field.private:\n+            continue  # doesn't appear in the public interface\n+        for attrname in [ \"default\", \"default_factory\" ]:\n+            f_def = getattr(field, attrname)\n+            if f_def is MISSING or f_def.is_literal or f_def.is_name:\n+                # some simple cases where we don't need to set up\n+                # the variable as a module-level constant\n+                continue\n+            global_scope = node.scope.global_scope()\n+            module_field_name = global_scope.mangle(\n+                global_scope.mangle(Naming.dataclass_field_default_cname, node.class_name),\n+                name)\n+            # create an entry in the global scope for this variable to live\n+            nn = ExprNodes.NameNode(f_def.pos, name=EncodedString(module_field_name))\n+            nn.entry = global_scope.declare_var(nn.name, type=f_def.type or PyrexTypes.unspecified_type,\n+                                                pos=f_def.pos, cname=nn.name, is_cdef=1)\n+            # replace the field so that future users just receive the namenode\n+            setattr(field, attrname, nn)\n+\n+            variables_assignment_stats.append(\n+                Nodes.SingleAssignmentNode(f_def.pos,\n+                                           lhs = nn,\n+                                           rhs = f_def))\n+\n+    placeholders = {}\n+    field_func = ExprNodes.AttributeNode(node.pos, obj = dataclass_module,\n+                                         attribute=EncodedString(\"field\"))\n+    dc_fields = ExprNodes.DictNode(node.pos, key_value_pairs=[])\n+    dc_fields_namevalue_assignments = []\n+    for name, field in fields.items():",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r689468786",
            "id": 689468786,
            "in_reply_to_id": 686427176,
            "line": 655,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTQ2ODc4Ng==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 642,
            "original_position": 642,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": 655,
            "pull_request_review_id": 730611608,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/689468786/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-08-16T12:35:50Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/689468786",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r689473422"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/689473422"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "...except that it tests that no warnings are emitted. (The `werror` tag would do the same thing though)",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-08-16T11:59:06Z",
            "diff_hunk": "@@ -161,13 +158,58 @@ def literal_list_ptr():\n     return a[3]\n \n \n+def test_subscripted_types():\n+    \"\"\"\n+    >>> test_subscripted_types()\n+    dict object\n+    list object\n+    set object\n+    \"\"\"\n+    a: typing.Dict[int, float] = {}\n+    b: List[int] = []\n+    c: _SET_[object] = set()\n+\n+    print(cython.typeof(a) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(b) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(c) + (\" object\" if not cython.compiled else \"\"))\n+\n+# because tuple is specifically special cased to go to ctuple where possible\n+def test_tuple(a : typing.Tuple[int, float], b : typing.Tuple[int, ...],\n+               c : Tuple[int, object]  # cannot be a ctuple\n+               ):\n+    \"\"\"\n+    >>> test_tuple((1, 1.0), (1, 1.0), (1, 1.0))\n+    int\n+    int\n+    tuple object\n+    tuple object\n+    \"\"\"\n+    x: typing.Tuple[int, float] = (a[0], a[1])\n+    y: Tuple[int, ...] = (1,2.)\n+    z = a[0]  # should infer to int\n+\n+    print(cython.typeof(z))\n+    print(cython.typeof(x[0]))\n+    print(cython.typeof(y) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(c) + (\" object\" if not cython.compiled else \"\"))\n+\n+\n+if cython.compiled:\n+    __doc__ = \"\"\"\n+    # passing non-dicts to variables declared as dict now fails\n+    >>> class D(object):\n+    ...     def __getitem__(self, x): return 2\n+    ...     def __iter__(self): return iter([1, 2, 3])\n+    >>> iter_declared_dict(D())  # doctest:+IGNORE_EXCEPTION_DETAIL\n+    Traceback (most recent call last):\n+    ...\n+    TypeError: Expected dict, got D\n+    >>> iter_declared_dict_arg(D())  # doctest:+IGNORE_EXCEPTION_DETAIL\n+    Traceback (most recent call last):\n+    ...\n+    TypeError: Expected dict, got D\n+    \"\"\"\n+\n+\n _WARNINGS = \"\"\"\n-37:19: Unknown type declaration in annotation, ignoring\n-38:12: Unknown type declaration in annotation, ignoring\n-39:18: Unknown type declaration in annotation, ignoring\n-73:11: Annotation ignored since class-level attributes must be Python objects. Were you trying to set up an instance attribute?\n-73:19: Unknown type declaration in annotation, ignoring\n-# FIXME: these are sort-of evaluated now, so the warning is misleading\n-126:21: Unknown type declaration in annotation, ignoring\n-137:35: Unknown type declaration in annotation, ignoring\n \"\"\"",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r689473422",
            "id": 689473422,
            "in_reply_to_id": 686358899,
            "line": 215,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTQ3MzQyMg==",
            "original_commit_id": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "original_line": 215,
            "original_position": 116,
            "original_start_line": 214,
            "path": "tests/run/pep526_variable_annotations.py",
            "position": 116,
            "pull_request_review_id": 730611608,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/689473422/reactions"
            },
            "side": "RIGHT",
            "start_line": 214,
            "start_side": "RIGHT",
            "updated_at": "2021-08-16T12:35:50Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/689473422",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r762545543"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/762545543"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n                         MappingProxyType(metadata))\r\n```",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-12-05T11:05:30Z",
            "diff_hunk": "@@ -0,0 +1,96 @@\n+################### Dataclasses_fallback ###############################\n+\n+# This is the fallback dataclass code if the stdlib module isn't available.\n+# It defines enough of the support types to be used with cdef classes\n+# and to fail if used on regular types.\n+\n+# (Intended to be included as py code - not compiled)\n+\n+from collections import namedtuple\n+try:\n+    from types import MappingProxyType\n+except ImportError:\n+    # mutable fallback if unavailable\n+    MappingProxyType = lambda x: x\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+_DataclassParams = namedtuple('_DataclassParams',\n+    [\"init\", \"repr\", \"eq\", \"order\", \"unsafe_hash\", \"frozen\"])\n+class Field(object):\n+    __slots__ = ('name',\n+                 'type',\n+                 'default',\n+                 'default_factory',\n+                 'repr',\n+                 'hash',\n+                 'init',\n+                 'compare',\n+                 'metadata',\n+                 '_field_type',  # Private: not to be used by user code.\n+                 )\n+\n+    def __init__(self, default, default_factory, init, repr, hash, compare,\n+                 metadata):\n+        self.name = None\n+        self.type = None\n+        self.default = default\n+        self.default_factory = default_factory\n+        self.init = init\n+        self.repr = repr\n+        self.hash = hash\n+        self.compare = compare\n+        # Be aware that if MappingProxyType is unavailable (i.e. py2?) then we\n+        # don't enforce non-mutability that the real module does\n+        self.metadata = (MappingProxyType({})\n+                         if metadata is None else\n+                         MappingTypesProxy(metadata))",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r762545543",
            "id": 762545543,
            "line": null,
            "node_id": "PRRC_kwDOABDGAc4tc4WH",
            "original_commit_id": "bc469d6544c23e8e55b04cf6c305016ca5329a04",
            "original_line": 49,
            "original_position": 49,
            "original_start_line": null,
            "path": "Cython/Utility/Dataclasses.py",
            "position": null,
            "pull_request_review_id": 823377468,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/762545543/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-12-05T11:05:31Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/762545543",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6939968?v=4",
                "events_url": "https://api.github.com/users/anthrotype/events{/privacy}",
                "followers_url": "https://api.github.com/users/anthrotype/followers",
                "following_url": "https://api.github.com/users/anthrotype/following{/other_user}",
                "gists_url": "https://api.github.com/users/anthrotype/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/anthrotype",
                "id": 6939968,
                "login": "anthrotype",
                "node_id": "MDQ6VXNlcjY5Mzk5Njg=",
                "organizations_url": "https://api.github.com/users/anthrotype/orgs",
                "received_events_url": "https://api.github.com/users/anthrotype/received_events",
                "repos_url": "https://api.github.com/users/anthrotype/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/anthrotype/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/anthrotype/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/anthrotype"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r763209436"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/763209436"
                }
            },
            "author_association": "NONE",
            "body": "I think you shold use %r instead of %s here:\r\n\r\n```suggestion\r\n    strs = [u\"%s={self.%r}\" % (name, name)\r\n```\r\n\r\nThe original CPython implementation does `{{self.{f.name}!r}}` (notice the `!r` for the repr form, not the plain str).\r\n\r\nE.g. I have a a class like this\r\n\r\n```\r\n@dataclass\r\n@cython.cclass\r\nclass Point:\r\n    x: float\r\n    y: float\r\n    name: str\r\n```\r\n\r\nWhen I look at the cython-generated repr() I get the string attribute values without the quotes\r\n\r\n```\r\nPoint(x=1.0, y=2.0, name=abc)\r\n```\r\n\r\nwhich means I can't eval the repr (which I think it's the point of using `repr()` or `!r` instead of just str().",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-12-06T17:16:09Z",
            "diff_hunk": "@@ -0,0 +1,697 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    function_body_code_lines = []\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                function_body_code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                function_body_code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                function_body_code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+\n+    args = u\", \".join(args)\n+    func_def = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_def] + (function_body_code_lines or [\"pass\"])\n+\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [u\"%s={self.%s}\" % (name, name)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r763209436",
            "id": 763209436,
            "line": null,
            "node_id": "PRRC_kwDOABDGAc4tfabc",
            "original_commit_id": "bc469d6544c23e8e55b04cf6c305016ca5329a04",
            "original_line": 385,
            "original_position": 385,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 824235579,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/763209436/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-12-06T17:16:10Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/763209436",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6939968?v=4",
                "events_url": "https://api.github.com/users/anthrotype/events{/privacy}",
                "followers_url": "https://api.github.com/users/anthrotype/followers",
                "following_url": "https://api.github.com/users/anthrotype/following{/other_user}",
                "gists_url": "https://api.github.com/users/anthrotype/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/anthrotype",
                "id": 6939968,
                "login": "anthrotype",
                "node_id": "MDQ6VXNlcjY5Mzk5Njg=",
                "organizations_url": "https://api.github.com/users/anthrotype/orgs",
                "received_events_url": "https://api.github.com/users/anthrotype/received_events",
                "repos_url": "https://api.github.com/users/anthrotype/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/anthrotype/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/anthrotype/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/anthrotype"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r763282056"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/763282056"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Thanks - should be fixed now.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2021-12-06T18:47:58Z",
            "diff_hunk": "@@ -0,0 +1,697 @@\n+# functions to transform a c class into a dataclass\n+\n+from collections import OrderedDict\n+\n+from . import ExprNodes\n+from . import Nodes\n+from . import PyrexTypes\n+from . import UtilNodes\n+from . import Builtin\n+from . import Naming\n+from .Errors import error, warning\n+from .Code import UtilityCode, TempitaUtilityCode\n+from .Visitor import VisitorTransform\n+from .StringEncoding import BytesLiteral, EncodedString\n+from .TreeFragment import TreeFragment\n+from .ParseTreeTransforms import (NormalizeTree, SkipDeclarations, AnalyseDeclarationsTransform,\n+                                  MarkClosureVisitor)\n+from textwrap import dedent\n+\n+def make_dataclasses_module_callnode(pos):\n+    python_utility_code = UtilityCode.load_cached(\"Dataclasses_fallback\", \"Dataclasses.py\")\n+    python_utility_code = EncodedString(python_utility_code.impl)\n+    loader_utilitycode = TempitaUtilityCode.load_cached(\n+        \"SpecificModuleLoader\", \"Dataclasses.c\",\n+        context={'cname': \"dataclasses\", 'py_code': python_utility_code.as_c_string_literal()})\n+    return ExprNodes.PythonCapiCallNode(\n+        pos, \"__Pyx_Load_dataclasses_Module\",\n+        PyrexTypes.CFuncType(PyrexTypes.py_object_type, []),\n+        utility_code=loader_utilitycode,\n+        args=[],\n+    )\n+\n+_INTERNAL_DEFAULTSHOLDER_NAME = EncodedString('__pyx_dataclass_defaults')\n+\n+class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):\n+    \"\"\"\n+    Cython (and Python) normally treats\n+\n+    class A:\n+         x = 1\n+\n+    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as\n+    a default value to initialize an instance attribute with.\n+    This transform therefore removes the `x=1` assignment so that the class attribute isn't\n+    generated, while recording what it has removed so that it can be used in the initialization.\n+    \"\"\"\n+    def __init__(self, names):\n+        super(RemoveAssignmentsToNames, self).__init__()\n+        self.names = names\n+        self.removed_assignments = {}\n+\n+    def visit_CClassNode(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+    def visit_PyClassNode(self, node):\n+        return node  # go no further\n+\n+    def visit_FuncDefNode(self, node):\n+        return node  # go no further\n+\n+    def visit_SingleAssignmentNode(self, node):\n+        if node.lhs.is_name and node.lhs.name in self.names:\n+            if node.lhs.name in self.removed_assignments:\n+                warning(node.pos, (\"Multiple assignments for '%s' in dataclass; \"\n+                                   \"using most recent\") % node.lhs.name, 1)\n+            self.removed_assignments[node.lhs.name] = node.rhs\n+            return []\n+        return node\n+\n+    # I believe cascaded assignment is always a syntax error with annotations\n+    # so there's no need to define visit_CascadedAssignmentNode\n+\n+    def visit_Node(self, node):\n+        self.visitchildren(node)\n+        return node\n+\n+class _MISSING_TYPE(object):\n+    pass\n+MISSING = _MISSING_TYPE()\n+\n+\n+class Field(object):\n+    \"\"\"\n+    Field is based on the dataclasses.field class from the standard library module.\n+    It is used internally during the generation of Cython dataclasses to keep track\n+    of the settings for individual attributes.\n+\n+    Attributes of this class are stored as nodes so they can be used in code construction\n+    more readily (i.e. we store BoolNode rather than bool)\n+    \"\"\"\n+    default = MISSING\n+    default_factory = MISSING\n+    private = False\n+    # default values are defined by the CPython dataclasses.field\n+    def __init__(self, pos, default=MISSING, default_factory=MISSING,\n+                 repr=None, hash=None, init=None,\n+                 compare=None, metadata=None,\n+                 is_initvar=False,\n+                 **additional_kwds):\n+        if default is not MISSING:\n+            self.default = default\n+        if default_factory is not MISSING:\n+            self.default_factory = default_factory\n+        self.repr = repr or ExprNodes.BoolNode(pos, value=True)\n+        self.hash = hash or ExprNodes.NoneNode(pos)\n+        self.init = init or ExprNodes.BoolNode(pos, value=True)\n+        self.compare = compare or ExprNodes.BoolNode(pos, value=True)\n+        self.metadata = metadata or ExprNodes.NoneNode(pos)\n+        self.is_initvar = is_initvar\n+\n+        for k, v in additional_kwds.items():\n+            # There should not be any additional keywords!\n+            error(v.pos, \"cython.dataclasses.field() got an unexpected keyword argument '%s'\" % k)\n+\n+        for field_name in (\"repr\", \"hash\", \"init\", \"compare\", \"metadata\"):\n+            field_value = getattr(self, field_name)\n+            if not field_value.is_literal:\n+                error(field_value.pos,\n+                      \"cython.dataclasses.field parameter '%s' must be a literal value\" % field_name)\n+\n+\n+def process_class_get_fields(node):\n+    import operator\n+    var_entries = node.scope.var_entries\n+    # order of definition is used in the dataclass\n+    var_entries = sorted(var_entries, key=operator.attrgetter('pos'))\n+    var_names = [entry.name for entry in var_entries]\n+\n+    # don't treat `x = 1` as an assignment of a class attribute within the dataclass\n+    transform = RemoveAssignmentsToNames(var_names)\n+    transform(node)\n+\n+    if node.base_type and node.base_type.dataclass_fields:\n+        fields = node.base_type.dataclass_fields.copy()\n+    else:\n+        fields = OrderedDict()\n+\n+    for entry in var_entries:\n+        name = entry.name\n+        is_initvar = (entry.type.is_special_python_type_constructor and\n+                      entry.type.name == \"dataclasses.InitVar\")\n+        if name in transform.removed_assignments:\n+            assignment = transform.removed_assignments[name]\n+            if (isinstance(assignment, ExprNodes.CallNode)\n+                    and assignment.function.as_cython_attribute() == \"dataclasses.field\"):\n+                # I believe most of this is well-enforced when it's treated as a directive\n+                # but it doesn't hurt to make sure\n+                if (not isinstance(assignment, ExprNodes.GeneralCallNode)\n+                        or not isinstance(assignment.positional_args, ExprNodes.TupleNode)\n+                        or assignment.positional_args.args\n+                        or not isinstance(assignment.keyword_args, ExprNodes.DictNode)):\n+                    error(assignment.pos, \"Call to 'cython.dataclasses.field' must only consist \"\n+                          \"of compile-time keyword arguments\")\n+                    continue\n+                keyword_args = assignment.keyword_args.as_python_dict()\n+                if 'default' in keyword_args and 'default_factory' in keyword_args:\n+                    error(assignment.pos, \"cannot specify both default and default_factory\")\n+                    continue\n+                field = Field(node.pos, **keyword_args)\n+            else:\n+                if isinstance(assignment, ExprNodes.CallNode):\n+                    func = assignment.function\n+                    if ((func.is_name and func.name == \"field\")\n+                            or (func.is_attribute and func.attribute == \"field\")):\n+                        warning(assignment.pos, \"Do you mean cython.dataclasses.field instead?\", 1)\n+                if assignment.type in [Builtin.list_type, Builtin.dict_type, Builtin.set_type]:\n+                    # The standard library module generates a TypeError at runtime\n+                    # in this situation.\n+                    # Error message is copied from CPython\n+                    error(assignment.pos, \"mutable default <class '{0}'> for field {1} is not allowed: \"\n+                          \"use default_factory\".format(assignment.type.name, name))\n+\n+                field = Field(node.pos, default=assignment)\n+        else:\n+            field = Field(node.pos)\n+        field.is_initvar = is_initvar\n+        if entry.visibility == \"private\":\n+            field.private = True\n+        fields[name] = field\n+    node.entry.type.dataclass_fields = fields\n+    return fields\n+\n+def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform):\n+    # default argument values from https://docs.python.org/3/library/dataclasses.html\n+    kwargs = dict(init=True, repr=True, eq=True,\n+                  order=False, unsafe_hash=False, frozen=False)\n+    if dataclass_args is not None:\n+        if dataclass_args[0]:\n+            error(node.pos, \"cython.dataclasses.dataclass takes no positional arguments\")\n+        for k, v in dataclass_args[1].items():\n+            if k not in kwargs:\n+                error(node.pos,\n+                      \"cython.dataclasses.dataclass() got an unexpected keyword argument '%s'\" % k)\n+            if not isinstance(v, ExprNodes.BoolNode):\n+                error(node.pos,\n+                      \"Arguments passed to cython.dataclasses.dataclass must be True or False\")\n+            kwargs[k] = v\n+\n+    fields = process_class_get_fields(node)\n+\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+\n+    # create __dataclass_params__ attribute. I try to use the exact\n+    # `_DataclassParams` class defined in the standard library module if at all possible\n+    # for maximum duck-typing compatibility.\n+    dataclass_params_func = ExprNodes.AttributeNode(node.pos, obj=dataclass_module,\n+                                                    attribute=EncodedString(\"_DataclassParams\"))\n+    dataclass_params_keywords = ExprNodes.DictNode.from_pairs(\n+        node.pos,\n+        [ (ExprNodes.IdentifierStringNode(node.pos, value=EncodedString(k)),\n+           ExprNodes.BoolNode(node.pos, value=v))\n+          for k, v in kwargs.items() ])\n+    dataclass_params = ExprNodes.GeneralCallNode(node.pos,\n+                                                 function = dataclass_params_func,\n+                                                 positional_args = ExprNodes.TupleNode(node.pos, args=[]),\n+                                                 keyword_args = dataclass_params_keywords)\n+    dataclass_params_assignment = Nodes.SingleAssignmentNode(\n+        node.pos,\n+        lhs = ExprNodes.NameNode(node.pos, name=EncodedString(\"__dataclass_params__\")),\n+        rhs = dataclass_params)\n+\n+    dataclass_fields_stats = _set_up_dataclass_fields(node, fields, dataclass_module)\n+\n+    stats = Nodes.StatListNode(node.pos,\n+                               stats=[dataclass_params_assignment] + dataclass_fields_stats)\n+\n+    code_lines = []\n+    placeholders = {}\n+    extra_stats = []\n+    for cl, ph, es in [ generate_init_code(kwargs['init'], node, fields),\n+                        generate_repr_code(kwargs['repr'], node, fields),\n+                        generate_eq_code(kwargs['eq'], node, fields),\n+                        generate_order_code(kwargs['order'], node, fields),\n+                        generate_hash_code(kwargs['unsafe_hash'], kwargs['eq'], kwargs['frozen'], node, fields) ]:\n+        code_lines.append(cl)\n+        placeholders.update(ph)\n+        extra_stats.extend(extra_stats)\n+\n+    code_lines = \"\\n\".join(code_lines)\n+    code_tree = TreeFragment(code_lines, level='c_class', pipeline=[NormalizeTree(node.scope)]\n+                            ).substitute(placeholders)\n+\n+    stats.stats += (code_tree.stats + extra_stats)\n+\n+    # turn off annotation typing, so all arguments to __init__ are accepted as\n+    # generic objects and thus can accept _HAS_DEFAULT_FACTORY.\n+    # Type conversion comes later\n+    comp_directives = Nodes.CompilerDirectivesNode(node.pos,\n+        directives=node.scope.directives.copy(),\n+        body=stats)\n+    comp_directives.directives['annotation_typing'] = False\n+\n+    comp_directives.analyse_declarations(node.scope)\n+    # probably already in this scope, but it doesn't hurt to make sure\n+    analyse_decs_transform.enter_scope(node, node.scope)\n+    analyse_decs_transform.visit(comp_directives)\n+    analyse_decs_transform.exit_scope()\n+\n+    node.body.stats.append(comp_directives)\n+\n+def generate_init_code(init, node, fields):\n+    \"\"\"\n+    All of these \"generate_*_code\" functions return a tuple of:\n+    - code string\n+    - placeholder dict (often empty)\n+    - stat list (often empty)\n+    which can then be combined later and processed once.\n+\n+    Notes on CPython generated \"__init__\":\n+    * Implemented in `_init_fn`.\n+    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as\n+      the default argument for fields that need constructing with a factory\n+      function is copied from the CPython implementation. (`None` isn't\n+      suitable because it could also be a value for the user to pass.)\n+      There's no real reason why it needs importing from the dataclasses module\n+      though - it could equally be a value generated by Cython when the module loads.\n+    * seen_default and the associated error message are copied directly from Python\n+    * Call to user-defined __post_init__ function (if it exists) is copied from\n+      CPython.\n+    \"\"\"\n+    if not init or node.scope.lookup_here(\"__init__\"):\n+        return \"\", {}, []\n+    # selfname behaviour copied from the cpython module\n+    selfname = \"__dataclass_self__\" if \"self\" in fields else \"self\"\n+    args = [selfname]\n+\n+    placeholders = {}\n+    placeholder_count = [0]\n+\n+    # create a temp to get _HAS_DEFAULT_FACTORY\n+    dataclass_module = make_dataclasses_module_callnode(node.pos)\n+    has_default_factory = ExprNodes.AttributeNode(\n+        node.pos,\n+        obj=dataclass_module,\n+        attribute=EncodedString(\"_HAS_DEFAULT_FACTORY\")\n+    )\n+\n+    def get_placeholder_name():\n+        while True:\n+            name = \"INIT_PLACEHOLDER_%s\" % placeholder_count[0]\n+            if (name not in placeholders\n+                    and name not in fields):\n+                # make sure name isn't already used and doesn't\n+                # conflict with a variable name (which is unlikely but possible)\n+                break\n+            placeholder_count[0] += 1\n+        return name\n+\n+    default_factory_placeholder = get_placeholder_name()\n+    placeholders[default_factory_placeholder] = has_default_factory\n+\n+    function_body_code_lines = []\n+\n+    seen_default = False\n+    for name, field in fields.items():\n+        if not field.init.value:\n+            continue\n+        entry = node.scope.lookup(name)\n+        if entry.annotation:\n+            annotation = u\": %s\" % entry.annotation.string.value\n+        else:\n+            annotation = u\"\"\n+        assignment = u''\n+        if field.default is not MISSING or field.default_factory is not MISSING:\n+            seen_default = True\n+            if field.default_factory is not MISSING:\n+                ph_name = default_factory_placeholder\n+            else:\n+                ph_name = get_placeholder_name()\n+                placeholders[ph_name] = field.default  # should be a node\n+            assignment = u\" = %s\" % ph_name\n+        elif seen_default:\n+            error(entry.pos, (\"non-default argument '%s' follows default argument \"\n+                              \"in dataclass __init__\") % name)\n+            return \"\", {}, []\n+\n+        args.append(u\"%s%s%s\" % (name, annotation, assignment))\n+\n+        if field.is_initvar:\n+            continue\n+        elif field.default_factory is MISSING:\n+            if field.init.value:\n+                function_body_code_lines.append(u\"    %s.%s = %s\" % (selfname, name, name))\n+        else:\n+            ph_name = get_placeholder_name()\n+            placeholders[ph_name] = field.default_factory\n+            if field.init.value:\n+                # close to:\n+                # def __init__(self, name=_PLACEHOLDER_VALUE):\n+                #     self.name = name_default_factory() if name is _PLACEHOLDER_VALUE else name\n+                function_body_code_lines.append(u\"    %s.%s = %s() if %s is %s else %s\" % (\n+                    selfname, name, ph_name, name, default_factory_placeholder, name))\n+            else:\n+                # still need to use the default factory to initialize\n+                function_body_code_lines.append(u\"    %s.%s = %s()\"\n+                                  % (selfname, name, ph_name))\n+\n+    args = u\", \".join(args)\n+    func_def = u\"def __init__(%s):\" % args\n+\n+    code_lines = [func_def] + (function_body_code_lines or [\"pass\"])\n+\n+    if node.scope.lookup(\"__post_init__\"):\n+        post_init_vars = \", \".join(name for name, field in fields.items()\n+                                   if field.is_initvar)\n+        code_lines.append(\"    %s.__post_init__(%s)\" % (selfname, post_init_vars))\n+    return u\"\\n\".join(code_lines), placeholders, []\n+\n+\n+def generate_repr_code(repr, node, fields):\n+    \"\"\"\n+    The CPython implementation is just:\n+    ['return self.__class__.__qualname__ + f\"(' +\n+                     ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n+                                for f in fields]) +\n+                     ')\"'],\n+\n+    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__\n+    which is because Cython currently supports Python 2.\n+    \"\"\"\n+    if not repr or node.scope.lookup(\"__repr__\"):\n+        return \"\", {}, []\n+    code_lines = [\"def __repr__(self):\"]\n+    strs = [u\"%s={self.%s}\" % (name, name)",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r763282056",
            "id": 763282056,
            "in_reply_to_id": 763209436,
            "line": null,
            "node_id": "PRRC_kwDOABDGAc4tfsKI",
            "original_commit_id": "bc469d6544c23e8e55b04cf6c305016ca5329a04",
            "original_line": 385,
            "original_position": 385,
            "original_start_line": null,
            "path": "Cython/Compiler/Dataclass.py",
            "position": null,
            "pull_request_review_id": 824334801,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/763282056/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2021-12-06T18:47:59Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/763282056",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r778433527"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/778433527"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Isn't this formatted weirdly?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2022-01-04T22:37:16Z",
            "diff_hunk": "@@ -161,13 +158,58 @@ def literal_list_ptr():\n     return a[3]\n \n \n+def test_subscripted_types():\n+    \"\"\"\n+    >>> test_subscripted_types()\n+    dict object\n+    list object\n+    set object\n+    \"\"\"\n+    a: typing.Dict[int, float] = {}\n+    b: List[int] = []\n+    c: _SET_[object] = set()\n+\n+    print(cython.typeof(a) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(b) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(c) + (\" object\" if not cython.compiled else \"\"))\n+\n+# because tuple is specifically special cased to go to ctuple where possible\n+def test_tuple(a : typing.Tuple[int, float], b : typing.Tuple[int, ...],\n+               c : Tuple[int, object]  # cannot be a ctuple\n+               ):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r778433527",
            "id": 778433527,
            "line": 179,
            "node_id": "PRRC_kwDOABDGAc4uZfP3",
            "original_commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "original_line": 179,
            "original_position": 72,
            "original_start_line": 177,
            "path": "tests/run/pep526_variable_annotations.py",
            "position": 72,
            "pull_request_review_id": 844069145,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/778433527/reactions"
            },
            "side": "RIGHT",
            "start_line": 177,
            "start_side": "RIGHT",
            "updated_at": "2022-01-04T23:11:46Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/778433527",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r778445755"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/778445755"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Maybe want to close this parenthesis 😅",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2022-01-04T23:05:58Z",
            "diff_hunk": "@@ -450,3 +450,57 @@ def init_builtins():\n \n \n init_builtins()\n+\n+##############################\n+# Support for a few standard library modules that Cython understands (currently typing and dataclasses",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r778445755",
            "id": 778445755,
            "line": 455,
            "node_id": "PRRC_kwDOABDGAc4uZiO7",
            "original_commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "original_line": 455,
            "original_position": 15,
            "original_start_line": null,
            "path": "Cython/Compiler/Builtin.py",
            "position": 15,
            "pull_request_review_id": 844069145,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/778445755/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2022-01-04T23:11:46Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/778445755",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r779103420"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/779103420"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I've fixed this locally - thanks. Don't think it's worth pushing it and forcing the tests to be rerun until I have some more substantial changes (especially given that master is currently broken).\r\n\r\nBut it'll be sorted in the next proper update!",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2022-01-05T20:04:42Z",
            "diff_hunk": "@@ -450,3 +450,57 @@ def init_builtins():\n \n \n init_builtins()\n+\n+##############################\n+# Support for a few standard library modules that Cython understands (currently typing and dataclasses",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r779103420",
            "id": 779103420,
            "in_reply_to_id": 778445755,
            "line": 455,
            "node_id": "PRRC_kwDOABDGAc4ucCy8",
            "original_commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "original_line": 455,
            "original_position": 15,
            "original_start_line": null,
            "path": "Cython/Compiler/Builtin.py",
            "position": 15,
            "pull_request_review_id": 845014587,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/779103420/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "updated_at": "2022-01-05T20:04:42Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/779103420",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r779104965"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/779104965"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "I'm arguing that this is covered by\r\n\r\n> The closing brace/bracket/parenthesis on multiline constructs may either line up under the first non-whitespace character of the last line of list [...]\r\n\r\nof [PEP 8](https://www.python.org/dev/peps/pep-0008/).\r\n\r\nI agree it's a little odd though - I think this was the best option that let me have a comment immediately following the argument.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2022-01-05T20:07:30Z",
            "diff_hunk": "@@ -161,13 +158,58 @@ def literal_list_ptr():\n     return a[3]\n \n \n+def test_subscripted_types():\n+    \"\"\"\n+    >>> test_subscripted_types()\n+    dict object\n+    list object\n+    set object\n+    \"\"\"\n+    a: typing.Dict[int, float] = {}\n+    b: List[int] = []\n+    c: _SET_[object] = set()\n+\n+    print(cython.typeof(a) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(b) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(c) + (\" object\" if not cython.compiled else \"\"))\n+\n+# because tuple is specifically special cased to go to ctuple where possible\n+def test_tuple(a : typing.Tuple[int, float], b : typing.Tuple[int, ...],\n+               c : Tuple[int, object]  # cannot be a ctuple\n+               ):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r779104965",
            "id": 779104965,
            "in_reply_to_id": 778433527,
            "line": 179,
            "node_id": "PRRC_kwDOABDGAc4ucDLF",
            "original_commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "original_line": 179,
            "original_position": 72,
            "original_start_line": 177,
            "path": "tests/run/pep526_variable_annotations.py",
            "position": 72,
            "pull_request_review_id": 845016878,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/779104965/reactions"
            },
            "side": "RIGHT",
            "start_line": 177,
            "start_side": "RIGHT",
            "updated_at": "2022-01-05T20:07:31Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/779104965",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r779148009"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/779148009"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The indent itself is fine - that's a visual indent (not my preference but it works) - what I am referring to is the spaces around the colon. Should it not be `a: XYZ` instead of `a : XYZ`?",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2022-01-05T21:27:21Z",
            "diff_hunk": "@@ -161,13 +158,58 @@ def literal_list_ptr():\n     return a[3]\n \n \n+def test_subscripted_types():\n+    \"\"\"\n+    >>> test_subscripted_types()\n+    dict object\n+    list object\n+    set object\n+    \"\"\"\n+    a: typing.Dict[int, float] = {}\n+    b: List[int] = []\n+    c: _SET_[object] = set()\n+\n+    print(cython.typeof(a) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(b) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(c) + (\" object\" if not cython.compiled else \"\"))\n+\n+# because tuple is specifically special cased to go to ctuple where possible\n+def test_tuple(a : typing.Tuple[int, float], b : typing.Tuple[int, ...],\n+               c : Tuple[int, object]  # cannot be a ctuple\n+               ):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r779148009",
            "id": 779148009,
            "in_reply_to_id": 778433527,
            "line": 179,
            "node_id": "PRRC_kwDOABDGAc4ucNrp",
            "original_commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "original_line": 179,
            "original_position": 72,
            "original_start_line": 177,
            "path": "tests/run/pep526_variable_annotations.py",
            "position": 72,
            "pull_request_review_id": 845079541,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/779148009/reactions"
            },
            "side": "RIGHT",
            "start_line": 177,
            "start_side": "RIGHT",
            "updated_at": "2022-01-05T21:27:55Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/779148009",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38372706?v=4",
                "events_url": "https://api.github.com/users/Bluenix2/events{/privacy}",
                "followers_url": "https://api.github.com/users/Bluenix2/followers",
                "following_url": "https://api.github.com/users/Bluenix2/following{/other_user}",
                "gists_url": "https://api.github.com/users/Bluenix2/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Bluenix2",
                "id": 38372706,
                "login": "Bluenix2",
                "node_id": "MDQ6VXNlcjM4MzcyNzA2",
                "organizations_url": "https://api.github.com/users/Bluenix2/orgs",
                "received_events_url": "https://api.github.com/users/Bluenix2/received_events",
                "repos_url": "https://api.github.com/users/Bluenix2/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Bluenix2/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Bluenix2/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Bluenix2"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/cython/cython/pull/3400#discussion_r779150700"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/3400"
                },
                "self": {
                    "href": "https://api.github.com/repos/cython/cython/pulls/comments/779150700"
                }
            },
            "author_association": "COLLABORATOR",
            "body": "Yes - you're right. Thanks.\r\n\r\nI'll fix that too locally and push it next time I properly update it.",
            "commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "created_at": "2022-01-05T21:32:11Z",
            "diff_hunk": "@@ -161,13 +158,58 @@ def literal_list_ptr():\n     return a[3]\n \n \n+def test_subscripted_types():\n+    \"\"\"\n+    >>> test_subscripted_types()\n+    dict object\n+    list object\n+    set object\n+    \"\"\"\n+    a: typing.Dict[int, float] = {}\n+    b: List[int] = []\n+    c: _SET_[object] = set()\n+\n+    print(cython.typeof(a) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(b) + (\" object\" if not cython.compiled else \"\"))\n+    print(cython.typeof(c) + (\" object\" if not cython.compiled else \"\"))\n+\n+# because tuple is specifically special cased to go to ctuple where possible\n+def test_tuple(a : typing.Tuple[int, float], b : typing.Tuple[int, ...],\n+               c : Tuple[int, object]  # cannot be a ctuple\n+               ):",
            "html_url": "https://github.com/cython/cython/pull/3400#discussion_r779150700",
            "id": 779150700,
            "in_reply_to_id": 778433527,
            "line": 179,
            "node_id": "PRRC_kwDOABDGAc4ucOVs",
            "original_commit_id": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "original_line": 179,
            "original_position": 72,
            "original_start_line": 177,
            "path": "tests/run/pep526_variable_annotations.py",
            "position": 72,
            "pull_request_review_id": 845083201,
            "pull_request_url": "https://api.github.com/repos/cython/cython/pulls/3400",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/pulls/comments/779150700/reactions"
            },
            "side": "RIGHT",
            "start_line": 177,
            "start_side": "RIGHT",
            "updated_at": "2022-01-05T21:32:11Z",
            "url": "https://api.github.com/repos/cython/cython/pulls/comments/779150700",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/cython/cython/issues/3400/comments",
    "commit_data": [
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/1298172e6348b8719ef10f39faf9fcec611f6c13/comments",
            "commit": {
                "author": {
                    "date": "2020-03-07T22:10:48Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-03-07T22:14:48Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "cdef dataclasses\n\nUsed cython.dataclass and cython.field to mark dataclasses and their fields.\n\nTries to match the interface provided by a regular dataclass as much as possible.\nThis means taking the types from the dataclasses module if available (so they\nmatch exactly) or a fallback Python version that just implements the core\nparts (obtained with PyRun_SimpleString in the C source).\n\nDoesn't try to handle ClassVar or InitVar at this stage. Otherwise\npretty complete.\n\nI don't really have a good idea of how to handle non-Python-compatible types\nhere and haven't hugely tested it. Bits will rpobably work to an extent\n\nUse of placeholders in generated __init__ code means the code in the C file\nisn't hugely readable. Probably not a huge issue, but don't really see a\nway round that\n\nTODO: frozen? - when set it either needs to set attributes to readonly\nand/or at least enforce readonlyness\n\n----------------------------------\n\nWhen finished closes https://github.com/cython/cython/issues/2903 -\nhowever, some design decisions pending before it's finished",
                "tree": {
                    "sha": "7c026401df016abe8fd10a42cf71b92e5cd2414a",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/7c026401df016abe8fd10a42cf71b92e5cd2414a"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/1298172e6348b8719ef10f39faf9fcec611f6c13",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/1298172e6348b8719ef10f39faf9fcec611f6c13",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MTI5ODE3MmU2MzQ4Yjg3MTllZjEwZjM5ZmFmOWZjZWM2MTFmNmMxMw==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/a8cb127df0cb970b00a8f58797740ef571dc8817",
                    "sha": "a8cb127df0cb970b00a8f58797740ef571dc8817",
                    "url": "https://api.github.com/repos/cython/cython/commits/a8cb127df0cb970b00a8f58797740ef571dc8817"
                }
            ],
            "sha": "1298172e6348b8719ef10f39faf9fcec611f6c13",
            "url": "https://api.github.com/repos/cython/cython/commits/1298172e6348b8719ef10f39faf9fcec611f6c13"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/153f18af041f9e21a094ff80a72b9fff363fd4aa/comments",
            "commit": {
                "author": {
                    "date": "2020-03-08T18:42:49Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-03-08T18:42:49Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fixed bug, added more tests documentation\n\nAlso removed some dead code",
                "tree": {
                    "sha": "8bd39103bd3f78755ec475916edd78ecd9b668d1",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/8bd39103bd3f78755ec475916edd78ecd9b668d1"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/153f18af041f9e21a094ff80a72b9fff363fd4aa",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/153f18af041f9e21a094ff80a72b9fff363fd4aa",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MTUzZjE4YWYwNDFmOWUyMWEwOTRmZjgwYTcyYjlmZmYzNjNmZDRhYQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/1298172e6348b8719ef10f39faf9fcec611f6c13",
                    "sha": "1298172e6348b8719ef10f39faf9fcec611f6c13",
                    "url": "https://api.github.com/repos/cython/cython/commits/1298172e6348b8719ef10f39faf9fcec611f6c13"
                }
            ],
            "sha": "153f18af041f9e21a094ff80a72b9fff363fd4aa",
            "url": "https://api.github.com/repos/cython/cython/commits/153f18af041f9e21a094ff80a72b9fff363fd4aa"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/2d6de5a2596802dcc769936f29c61f8e81781abe/comments",
            "commit": {
                "author": {
                    "date": "2020-03-08T20:48:05Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-03-08T20:48:05Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "py2 test\n\narray.array didn't define the buffer interface. So used\nthe standard cythonarrayutil for the test",
                "tree": {
                    "sha": "c88307ff3bc857530b04f63ced768fabd31ac16f",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/c88307ff3bc857530b04f63ced768fabd31ac16f"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/2d6de5a2596802dcc769936f29c61f8e81781abe",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/2d6de5a2596802dcc769936f29c61f8e81781abe",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MmQ2ZGU1YTI1OTY4MDJkY2M3Njk5MzZmMjljNjFmOGU4MTc4MWFiZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/153f18af041f9e21a094ff80a72b9fff363fd4aa",
                    "sha": "153f18af041f9e21a094ff80a72b9fff363fd4aa",
                    "url": "https://api.github.com/repos/cython/cython/commits/153f18af041f9e21a094ff80a72b9fff363fd4aa"
                }
            ],
            "sha": "2d6de5a2596802dcc769936f29c61f8e81781abe",
            "url": "https://api.github.com/repos/cython/cython/commits/2d6de5a2596802dcc769936f29c61f8e81781abe"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/5cd5885fcbeb2429be84890f4782030ba1d6e361/comments",
            "commit": {
                "author": {
                    "date": "2020-03-09T09:26:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-03-09T09:28:01Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Added InitVar and ClassVar",
                "tree": {
                    "sha": "27e19c5a1b611cf50a49f0aa49433704e2823724",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/27e19c5a1b611cf50a49f0aa49433704e2823724"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/5cd5885fcbeb2429be84890f4782030ba1d6e361",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/5cd5885fcbeb2429be84890f4782030ba1d6e361",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NWNkNTg4NWZjYmViMjQyOWJlODQ4OTBmNDc4MjAzMGJhMWQ2ZTM2MQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/2d6de5a2596802dcc769936f29c61f8e81781abe",
                    "sha": "2d6de5a2596802dcc769936f29c61f8e81781abe",
                    "url": "https://api.github.com/repos/cython/cython/commits/2d6de5a2596802dcc769936f29c61f8e81781abe"
                }
            ],
            "sha": "5cd5885fcbeb2429be84890f4782030ba1d6e361",
            "url": "https://api.github.com/repos/cython/cython/commits/5cd5885fcbeb2429be84890f4782030ba1d6e361"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/f1aceb752d2c250d9b55d15ace4ea18cefe59f3a/comments",
            "commit": {
                "author": {
                    "date": "2020-03-10T09:34:29Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-03-10T18:06:16Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Version using module-level globals to store default/default_factory\n\nAvoids lambda nodes/etc being duplicated in __init__\nand __dataclass_fields__ - simplest solution to this problem",
                "tree": {
                    "sha": "3af74af8f02f82d84bbe5217a26e85b22b556ce6",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/3af74af8f02f82d84bbe5217a26e85b22b556ce6"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/f1aceb752d2c250d9b55d15ace4ea18cefe59f3a",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/f1aceb752d2c250d9b55d15ace4ea18cefe59f3a",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZjFhY2ViNzUyZDJjMjUwZDliNTVkMTVhY2U0ZWExOGNlZmU1OWYzYQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/5cd5885fcbeb2429be84890f4782030ba1d6e361",
                    "sha": "5cd5885fcbeb2429be84890f4782030ba1d6e361",
                    "url": "https://api.github.com/repos/cython/cython/commits/5cd5885fcbeb2429be84890f4782030ba1d6e361"
                }
            ],
            "sha": "f1aceb752d2c250d9b55d15ace4ea18cefe59f3a",
            "url": "https://api.github.com/repos/cython/cython/commits/f1aceb752d2c250d9b55d15ace4ea18cefe59f3a"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/491bd771ea752d64b385470f84b36c31d7259b8b/comments",
            "commit": {
                "author": {
                    "date": "2020-03-10T20:16:34Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-03-10T20:16:34Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fixed py2 module-getting issues (and refcount)",
                "tree": {
                    "sha": "4be9ddc7b01cc8939ca9b857236de3ed9972f91d",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/4be9ddc7b01cc8939ca9b857236de3ed9972f91d"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/491bd771ea752d64b385470f84b36c31d7259b8b",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/491bd771ea752d64b385470f84b36c31d7259b8b",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NDkxYmQ3NzFlYTc1MmQ2NGIzODU0NzBmODRiMzZjMzFkNzI1OWI4Yg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/f1aceb752d2c250d9b55d15ace4ea18cefe59f3a",
                    "sha": "f1aceb752d2c250d9b55d15ace4ea18cefe59f3a",
                    "url": "https://api.github.com/repos/cython/cython/commits/f1aceb752d2c250d9b55d15ace4ea18cefe59f3a"
                }
            ],
            "sha": "491bd771ea752d64b385470f84b36c31d7259b8b",
            "url": "https://api.github.com/repos/cython/cython/commits/491bd771ea752d64b385470f84b36c31d7259b8b"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/cc1d0002b315a3f1c8f78abcfe558c393102ce3e/comments",
            "commit": {
                "author": {
                    "date": "2020-08-27T18:51:15Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-08-27T18:51:15Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "54f9598a12bdde60a56adc5e495f2df3b81ba768",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/54f9598a12bdde60a56adc5e495f2df3b81ba768"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/cc1d0002b315a3f1c8f78abcfe558c393102ce3e",
                "verification": {
                    "payload": "tree 54f9598a12bdde60a56adc5e495f2df3b81ba768\nparent 491bd771ea752d64b385470f84b36c31d7259b8b\nparent 4d54aeff34753551cf0ac9977d50c292dbf9d5d5\nauthor da-woods <dw-git@d-woods.co.uk> 1598554275 +0100\ncommitter GitHub <noreply@github.com> 1598554275 +0100\n\nMerge branch 'master' into dataclass",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfSACjCRBK7hj4Ov3rIwAAdHIIAH6jjqD6GVCoZ4DIy182KZGa\noK2NKfAzrcxiEKE+HmsCQcicv93GvAuZwRxxhp8zUaCBfwL+9CJQCbdBjpr7Jl3Z\ntHuBt8l8QRHGvv+/gwDqd/wrSKzfIwy4D7t8mVIIN4nz7hv03oqqmUVhNUMD5lDe\nNAwY3pCavEKxoMi49OoZI4Olm/LLW0v1Gqox6Q34ZwIamk0uSoQB25Fx8495tOqR\nMu8l0PFGQ4DGWW6+sPOII0c59GOeKWRRjja7hdkcxG2A9huBqabHlux09ohBvQg+\n2m4RWl43a+GGltrB+xmGPg8AKg78cYzj58a0vCpHLtvmmMhM5fR1g80KHXb62mQ=\n=Bh4f\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/cc1d0002b315a3f1c8f78abcfe558c393102ce3e",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6Y2MxZDAwMDJiMzE1YTNmMWM4Zjc4YWJjZmU1NThjMzkzMTAyY2UzZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/491bd771ea752d64b385470f84b36c31d7259b8b",
                    "sha": "491bd771ea752d64b385470f84b36c31d7259b8b",
                    "url": "https://api.github.com/repos/cython/cython/commits/491bd771ea752d64b385470f84b36c31d7259b8b"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/4d54aeff34753551cf0ac9977d50c292dbf9d5d5",
                    "sha": "4d54aeff34753551cf0ac9977d50c292dbf9d5d5",
                    "url": "https://api.github.com/repos/cython/cython/commits/4d54aeff34753551cf0ac9977d50c292dbf9d5d5"
                }
            ],
            "sha": "cc1d0002b315a3f1c8f78abcfe558c393102ce3e",
            "url": "https://api.github.com/repos/cython/cython/commits/cc1d0002b315a3f1c8f78abcfe558c393102ce3e"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/603b0399979be20cd93931cdfc9bc6a67f6428ee/comments",
            "commit": {
                "author": {
                    "date": "2020-08-28T07:16:08Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-08-28T07:16:08Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fixed code-style and pypy tests\n\n(I think - pypy compilation currently seems broken on my pc)",
                "tree": {
                    "sha": "e6cd576e1f338a0b99e124783d5e65978dc9652e",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/e6cd576e1f338a0b99e124783d5e65978dc9652e"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/603b0399979be20cd93931cdfc9bc6a67f6428ee",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/603b0399979be20cd93931cdfc9bc6a67f6428ee",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NjAzYjAzOTk5NzliZTIwY2Q5MzkzMWNkZmM5YmM2YTY3ZjY0MjhlZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/cc1d0002b315a3f1c8f78abcfe558c393102ce3e",
                    "sha": "cc1d0002b315a3f1c8f78abcfe558c393102ce3e",
                    "url": "https://api.github.com/repos/cython/cython/commits/cc1d0002b315a3f1c8f78abcfe558c393102ce3e"
                }
            ],
            "sha": "603b0399979be20cd93931cdfc9bc6a67f6428ee",
            "url": "https://api.github.com/repos/cython/cython/commits/603b0399979be20cd93931cdfc9bc6a67f6428ee"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/043a102296c9949e1924c783c0b0d061810d85e9/comments",
            "commit": {
                "author": {
                    "date": "2020-08-28T16:46:01Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-08-28T16:46:01Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fixed PyPy3\n\nIt doesn't have PyImport_AddModuleObject",
                "tree": {
                    "sha": "4d56dcf8d6b5a18b17beff55cf516584ca5f4f76",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/4d56dcf8d6b5a18b17beff55cf516584ca5f4f76"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/043a102296c9949e1924c783c0b0d061810d85e9",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/043a102296c9949e1924c783c0b0d061810d85e9",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MDQzYTEwMjI5NmM5OTQ5ZTE5MjRjNzgzYzBiMGQwNjE4MTBkODVlOQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/603b0399979be20cd93931cdfc9bc6a67f6428ee",
                    "sha": "603b0399979be20cd93931cdfc9bc6a67f6428ee",
                    "url": "https://api.github.com/repos/cython/cython/commits/603b0399979be20cd93931cdfc9bc6a67f6428ee"
                }
            ],
            "sha": "043a102296c9949e1924c783c0b0d061810d85e9",
            "url": "https://api.github.com/repos/cython/cython/commits/043a102296c9949e1924c783c0b0d061810d85e9"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/3449117240c87f7746fbb3bf0dbf79d96d5841f2/comments",
            "commit": {
                "author": {
                    "date": "2020-09-10T07:41:45Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-09-10T07:41:45Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Avoid name loading hack\n\nFix typo in documentation\n\nDon't make utilitycode CYTHON_UNUSED",
                "tree": {
                    "sha": "040c7c35e32d81c5cf4d24421c78e83acb2cdcd6",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/040c7c35e32d81c5cf4d24421c78e83acb2cdcd6"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/3449117240c87f7746fbb3bf0dbf79d96d5841f2",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/3449117240c87f7746fbb3bf0dbf79d96d5841f2",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MzQ0OTExNzI0MGM4N2Y3NzQ2ZmJiM2JmMGRiZjc5ZDk2ZDU4NDFmMg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/043a102296c9949e1924c783c0b0d061810d85e9",
                    "sha": "043a102296c9949e1924c783c0b0d061810d85e9",
                    "url": "https://api.github.com/repos/cython/cython/commits/043a102296c9949e1924c783c0b0d061810d85e9"
                }
            ],
            "sha": "3449117240c87f7746fbb3bf0dbf79d96d5841f2",
            "url": "https://api.github.com/repos/cython/cython/commits/3449117240c87f7746fbb3bf0dbf79d96d5841f2"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/4adb73a5ebd7b8986c87d3cdf85e716a24305e86/comments",
            "commit": {
                "author": {
                    "date": "2020-09-10T17:38:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-09-10T17:38:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Improved comments, handled \"annotation_typing\" directive better",
                "tree": {
                    "sha": "2134618fe6be158261d5ea52b8469534dc4a5e24",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/2134618fe6be158261d5ea52b8469534dc4a5e24"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/4adb73a5ebd7b8986c87d3cdf85e716a24305e86",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/4adb73a5ebd7b8986c87d3cdf85e716a24305e86",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NGFkYjczYTVlYmQ3Yjg5ODZjODdkM2NkZjg1ZTcxNmEyNDMwNWU4Ng==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/3449117240c87f7746fbb3bf0dbf79d96d5841f2",
                    "sha": "3449117240c87f7746fbb3bf0dbf79d96d5841f2",
                    "url": "https://api.github.com/repos/cython/cython/commits/3449117240c87f7746fbb3bf0dbf79d96d5841f2"
                }
            ],
            "sha": "4adb73a5ebd7b8986c87d3cdf85e716a24305e86",
            "url": "https://api.github.com/repos/cython/cython/commits/4adb73a5ebd7b8986c87d3cdf85e716a24305e86"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3/comments",
            "commit": {
                "author": {
                    "date": "2020-09-14T16:27:11Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-09-26T17:01:10Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Move cython.dataclass -> cython.dataclasses.dataclass\n\nfrozen should also work as an option",
                "tree": {
                    "sha": "286d0cbdc8db85d06d4db73ea94e7b52a8ebfc53",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/286d0cbdc8db85d06d4db73ea94e7b52a8ebfc53"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OGI4MTM4YTMwMmQzMDllNDFkMGE2YjBjZGJjYzUxZmM2M2U4NmZjMw==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/4adb73a5ebd7b8986c87d3cdf85e716a24305e86",
                    "sha": "4adb73a5ebd7b8986c87d3cdf85e716a24305e86",
                    "url": "https://api.github.com/repos/cython/cython/commits/4adb73a5ebd7b8986c87d3cdf85e716a24305e86"
                }
            ],
            "sha": "8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3",
            "url": "https://api.github.com/repos/cython/cython/commits/8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/9b2ae3ba72ebe693bd4a27a2d54b4ebe03d5da34/comments",
            "commit": {
                "author": {
                    "date": "2020-09-26T17:10:33Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-09-26T17:10:33Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "104959ff19d77e8fe4fce3f2b5c2d5c9e4696011",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/104959ff19d77e8fe4fce3f2b5c2d5c9e4696011"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/9b2ae3ba72ebe693bd4a27a2d54b4ebe03d5da34",
                "verification": {
                    "payload": "tree 104959ff19d77e8fe4fce3f2b5c2d5c9e4696011\nparent 8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3\nparent cf89182f8181a58bd9102034566856e7280f443c\nauthor da-woods <dw-git@d-woods.co.uk> 1601140233 +0100\ncommitter GitHub <noreply@github.com> 1601140233 +0100\n\nMerge branch 'master' into dataclass",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfb3YJCRBK7hj4Ov3rIwAAdHIIAA0de/wCD6Fs3qHbZjYY1H60\nvkVTKKm18lJuu8PO3BdYHEPnJzSTMBzD6l+tsTJItCzWioD40FBPL6do18J1ITEm\nKW4TvHBumbYs31ovP6hYG1B4SM3ZhjLQVHdwvmfPVub77Sjf87nAN4e4sxj3TVmK\nYBiK/hyHf2NNG/QM2a0CZ0maWLX1gjGaLCHZnCoaZG19Oizxia2rET9vBpks3PHb\nGCXMGTFGbMSGwixxFT1PHc56DbGDp/thOHnf7cMR+ecbYnIIk0hjqekwYlW98lbv\n+xMXqGq2KU7vJ9G8HjOXkDyO2+yhMbkguFP+2IO/MyTkCYVuF6+Pob+diLM80ns=\n=CCFC\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/9b2ae3ba72ebe693bd4a27a2d54b4ebe03d5da34",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OWIyYWUzYmE3MmViZTY5M2JkNGEyN2EyZDU0YjRlYmUwM2Q1ZGEzNA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3",
                    "sha": "8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3",
                    "url": "https://api.github.com/repos/cython/cython/commits/8b8138a302d309e41d0a6b0cdbcc51fc63e86fc3"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/cf89182f8181a58bd9102034566856e7280f443c",
                    "sha": "cf89182f8181a58bd9102034566856e7280f443c",
                    "url": "https://api.github.com/repos/cython/cython/commits/cf89182f8181a58bd9102034566856e7280f443c"
                }
            ],
            "sha": "9b2ae3ba72ebe693bd4a27a2d54b4ebe03d5da34",
            "url": "https://api.github.com/repos/cython/cython/commits/9b2ae3ba72ebe693bd4a27a2d54b4ebe03d5da34"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/6956615ac956190a819fbf0c493adba20f3cd39a/comments",
            "commit": {
                "author": {
                    "date": "2020-10-04T19:47:21Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-10-04T19:47:21Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "320b554e5ea136b85df79ab6b293e93c4951b9ce",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/320b554e5ea136b85df79ab6b293e93c4951b9ce"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/6956615ac956190a819fbf0c493adba20f3cd39a",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/6956615ac956190a819fbf0c493adba20f3cd39a",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6Njk1NjYxNWFjOTU2MTkwYTgxOWZiZjBjNDkzYWRiYTIwZjNjZDM5YQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/9b2ae3ba72ebe693bd4a27a2d54b4ebe03d5da34",
                    "sha": "9b2ae3ba72ebe693bd4a27a2d54b4ebe03d5da34",
                    "url": "https://api.github.com/repos/cython/cython/commits/9b2ae3ba72ebe693bd4a27a2d54b4ebe03d5da34"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/883f8f5bd6e2dc095529ad5a33c766f73a9ff413",
                    "sha": "883f8f5bd6e2dc095529ad5a33c766f73a9ff413",
                    "url": "https://api.github.com/repos/cython/cython/commits/883f8f5bd6e2dc095529ad5a33c766f73a9ff413"
                }
            ],
            "sha": "6956615ac956190a819fbf0c493adba20f3cd39a",
            "url": "https://api.github.com/repos/cython/cython/commits/6956615ac956190a819fbf0c493adba20f3cd39a"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/76ebcf2922b946bcc3dcbbf984d1eac4c281f64d/comments",
            "commit": {
                "author": {
                    "date": "2020-10-11T09:00:12Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-10-11T09:00:12Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Apply suggestions from code review\n\nCo-authored-by: scoder <stefan_ml@behnel.de>",
                "tree": {
                    "sha": "9efc5dbeb0f9187489ce54a964c2d0d760e1e966",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/9efc5dbeb0f9187489ce54a964c2d0d760e1e966"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/76ebcf2922b946bcc3dcbbf984d1eac4c281f64d",
                "verification": {
                    "payload": "tree 9efc5dbeb0f9187489ce54a964c2d0d760e1e966\nparent 6956615ac956190a819fbf0c493adba20f3cd39a\nauthor da-woods <dw-git@d-woods.co.uk> 1602406812 +0100\ncommitter GitHub <noreply@github.com> 1602406812 +0100\n\nApply suggestions from code review\n\nCo-authored-by: scoder <stefan_ml@behnel.de>",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfgsmcCRBK7hj4Ov3rIwAAdHIIAEuEqkR0Qqi1qJm8tpWBVQiV\n0H372+XPINJJ8sdASXNh8KaVUu90OAt6tkd4Q4hvIP7vZLKwKXL7O7dgo3QaQT11\n0txWLgHjan00Gv88j91/67JnYIa/aaTsd+Rg/rO6Ye0n2Lx4Z2o43EQHRDtFtGgU\nX7MgEe0whGUXTwNaQmgR7z4aAPlGrgvUBAJPrXgUpvcuz+gE3FpbJtUcRP3MIQm0\nMzhgKfqGEUAJ8ox8Nak9esAwY/7W9ROA0VRdcQfRYsWzItB51pBv9bEZWNh2Ww0o\nxDgf7cC5sO6FCTl0JjNnweVdEpvnTaJ6f8da177HY7n7L2jx7dmpXS2scAdEDjk=\n=FFXe\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/76ebcf2922b946bcc3dcbbf984d1eac4c281f64d",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NzZlYmNmMjkyMmI5NDZiY2MzZGNiYmY5ODRkMWVhYzRjMjgxZjY0ZA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/6956615ac956190a819fbf0c493adba20f3cd39a",
                    "sha": "6956615ac956190a819fbf0c493adba20f3cd39a",
                    "url": "https://api.github.com/repos/cython/cython/commits/6956615ac956190a819fbf0c493adba20f3cd39a"
                }
            ],
            "sha": "76ebcf2922b946bcc3dcbbf984d1eac4c281f64d",
            "url": "https://api.github.com/repos/cython/cython/commits/76ebcf2922b946bcc3dcbbf984d1eac4c281f64d"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/70057d6bb00176b5975733e49e86a0758d734bba/comments",
            "commit": {
                "author": {
                    "date": "2020-10-14T17:34:24Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-10-14T17:34:24Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "90c1b82b082d6575fc41dda6fc50f207fd59ecec",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/90c1b82b082d6575fc41dda6fc50f207fd59ecec"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/70057d6bb00176b5975733e49e86a0758d734bba",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/70057d6bb00176b5975733e49e86a0758d734bba",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NzAwNTdkNmJiMDAxNzZiNTk3NTczM2U0OWU4NmEwNzU4ZDczNGJiYQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/76ebcf2922b946bcc3dcbbf984d1eac4c281f64d",
                    "sha": "76ebcf2922b946bcc3dcbbf984d1eac4c281f64d",
                    "url": "https://api.github.com/repos/cython/cython/commits/76ebcf2922b946bcc3dcbbf984d1eac4c281f64d"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/ba6cbed8193775c80402bc5112cbaf16246ee6bd",
                    "sha": "ba6cbed8193775c80402bc5112cbaf16246ee6bd",
                    "url": "https://api.github.com/repos/cython/cython/commits/ba6cbed8193775c80402bc5112cbaf16246ee6bd"
                }
            ],
            "sha": "70057d6bb00176b5975733e49e86a0758d734bba",
            "url": "https://api.github.com/repos/cython/cython/commits/70057d6bb00176b5975733e49e86a0758d734bba"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/f23fb742511e361bbc5cb8c3cc19a6ccbadc91f2/comments",
            "commit": {
                "author": {
                    "date": "2020-10-16T16:56:45Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-15T16:02:23Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "WIP mess\n\nWIP\n\nMore WIP",
                "tree": {
                    "sha": "94c5cbe4ce0c1171e6727c0f544659d0a7a48f3a",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/94c5cbe4ce0c1171e6727c0f544659d0a7a48f3a"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/f23fb742511e361bbc5cb8c3cc19a6ccbadc91f2",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/f23fb742511e361bbc5cb8c3cc19a6ccbadc91f2",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZjIzZmI3NDI1MTFlMzYxYmJjNWNiOGMzY2MxOWE2Y2NiYWRjOTFmMg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/70057d6bb00176b5975733e49e86a0758d734bba",
                    "sha": "70057d6bb00176b5975733e49e86a0758d734bba",
                    "url": "https://api.github.com/repos/cython/cython/commits/70057d6bb00176b5975733e49e86a0758d734bba"
                }
            ],
            "sha": "f23fb742511e361bbc5cb8c3cc19a6ccbadc91f2",
            "url": "https://api.github.com/repos/cython/cython/commits/f23fb742511e361bbc5cb8c3cc19a6ccbadc91f2"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/f5951c0cd7252f209a7dc819628b4da0b0bca6e4/comments",
            "commit": {
                "author": {
                    "date": "2020-10-16T16:56:45Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-15T18:26:14Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Largely seems to work for finding typing module and using names\n\nAdded a mechanism to track where names are imported from (where\npossible) and used that to identify the typing module",
                "tree": {
                    "sha": "3900fbf5f5b2ac8f57238ca0385c35cdc0d3f5e4",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/3900fbf5f5b2ac8f57238ca0385c35cdc0d3f5e4"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/f5951c0cd7252f209a7dc819628b4da0b0bca6e4",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/f5951c0cd7252f209a7dc819628b4da0b0bca6e4",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZjU5NTFjMGNkNzI1MmYyMDlhN2RjODE5NjI4YjRkYTBiMGJjYTZlNA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/ba6cbed8193775c80402bc5112cbaf16246ee6bd",
                    "sha": "ba6cbed8193775c80402bc5112cbaf16246ee6bd",
                    "url": "https://api.github.com/repos/cython/cython/commits/ba6cbed8193775c80402bc5112cbaf16246ee6bd"
                }
            ],
            "sha": "f5951c0cd7252f209a7dc819628b4da0b0bca6e4",
            "url": "https://api.github.com/repos/cython/cython/commits/f5951c0cd7252f209a7dc819628b4da0b0bca6e4"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/7178732d15958fc0fc1a285406e4090387577b85/comments",
            "commit": {
                "author": {
                    "date": "2020-11-15T18:16:55Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-15T18:26:14Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Optional seems to work",
                "tree": {
                    "sha": "f42a8226fd0d7d790d72d5bc7b44bd5ae071dd38",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/f42a8226fd0d7d790d72d5bc7b44bd5ae071dd38"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/7178732d15958fc0fc1a285406e4090387577b85",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/7178732d15958fc0fc1a285406e4090387577b85",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NzE3ODczMmQxNTk1OGZjMGZjMWEyODU0MDZlNDA5MDM4NzU3N2I4NQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/f5951c0cd7252f209a7dc819628b4da0b0bca6e4",
                    "sha": "f5951c0cd7252f209a7dc819628b4da0b0bca6e4",
                    "url": "https://api.github.com/repos/cython/cython/commits/f5951c0cd7252f209a7dc819628b4da0b0bca6e4"
                }
            ],
            "sha": "7178732d15958fc0fc1a285406e4090387577b85",
            "url": "https://api.github.com/repos/cython/cython/commits/7178732d15958fc0fc1a285406e4090387577b85"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/5564953d20aa9089896021c50d2f5c1d64532b48/comments",
            "commit": {
                "author": {
                    "date": "2020-11-15T20:41:58Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-15T20:43:38Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fixed tests hopefully",
                "tree": {
                    "sha": "5081ec373d2a0d96b8075f40518bb3d1060902eb",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/5081ec373d2a0d96b8075f40518bb3d1060902eb"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/5564953d20aa9089896021c50d2f5c1d64532b48",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/5564953d20aa9089896021c50d2f5c1d64532b48",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NTU2NDk1M2QyMGFhOTA4OTg5NjAyMWM1MGQyZjVjMWQ2NDUzMmI0OA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/7178732d15958fc0fc1a285406e4090387577b85",
                    "sha": "7178732d15958fc0fc1a285406e4090387577b85",
                    "url": "https://api.github.com/repos/cython/cython/commits/7178732d15958fc0fc1a285406e4090387577b85"
                }
            ],
            "sha": "5564953d20aa9089896021c50d2f5c1d64532b48",
            "url": "https://api.github.com/repos/cython/cython/commits/5564953d20aa9089896021c50d2f5c1d64532b48"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/bf42809d16afae30627dc5a1edb30c2f3d124d8d/comments",
            "commit": {
                "author": {
                    "date": "2020-11-15T20:47:35Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-15T20:47:35Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Another fix (cimport check must be last)",
                "tree": {
                    "sha": "1da2c2aeeb2562e5644eafd71a4f1f0160b642a0",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/1da2c2aeeb2562e5644eafd71a4f1f0160b642a0"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/bf42809d16afae30627dc5a1edb30c2f3d124d8d",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/bf42809d16afae30627dc5a1edb30c2f3d124d8d",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YmY0MjgwOWQxNmFmYWUzMDYyN2RjNWExZWRiMzBjMmYzZDEyNGQ4ZA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/5564953d20aa9089896021c50d2f5c1d64532b48",
                    "sha": "5564953d20aa9089896021c50d2f5c1d64532b48",
                    "url": "https://api.github.com/repos/cython/cython/commits/5564953d20aa9089896021c50d2f5c1d64532b48"
                }
            ],
            "sha": "bf42809d16afae30627dc5a1edb30c2f3d124d8d",
            "url": "https://api.github.com/repos/cython/cython/commits/bf42809d16afae30627dc5a1edb30c2f3d124d8d"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/b78eb1eac8f908a40cacde9597c53e0f89b1c86e/comments",
            "commit": {
                "author": {
                    "date": "2020-11-16T19:21:16Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-16T19:21:16Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Tidying, tuples work, annotations become \"not None\"",
                "tree": {
                    "sha": "f3126fbe970d0dc100b870528b6e136627e10d28",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/f3126fbe970d0dc100b870528b6e136627e10d28"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/b78eb1eac8f908a40cacde9597c53e0f89b1c86e",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/b78eb1eac8f908a40cacde9597c53e0f89b1c86e",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6Yjc4ZWIxZWFjOGY5MDhhNDBjYWNkZTk1OTdjNTNlMGY4OWIxYzg2ZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/bf42809d16afae30627dc5a1edb30c2f3d124d8d",
                    "sha": "bf42809d16afae30627dc5a1edb30c2f3d124d8d",
                    "url": "https://api.github.com/repos/cython/cython/commits/bf42809d16afae30627dc5a1edb30c2f3d124d8d"
                }
            ],
            "sha": "b78eb1eac8f908a40cacde9597c53e0f89b1c86e",
            "url": "https://api.github.com/repos/cython/cython/commits/b78eb1eac8f908a40cacde9597c53e0f89b1c86e"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/bda031eea8f182c297afb12d0fc32b7ae3a178f6/comments",
            "commit": {
                "author": {
                    "date": "2020-11-16T20:53:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-16T20:53:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Added missing none check",
                "tree": {
                    "sha": "570da17704a1cf9022fc3fdd399ade007077f06b",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/570da17704a1cf9022fc3fdd399ade007077f06b"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/bda031eea8f182c297afb12d0fc32b7ae3a178f6",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/bda031eea8f182c297afb12d0fc32b7ae3a178f6",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YmRhMDMxZWVhOGYxODJjMjk3YWZiMTJkMGZjMzJiN2FlM2ExNzhmNg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/b78eb1eac8f908a40cacde9597c53e0f89b1c86e",
                    "sha": "b78eb1eac8f908a40cacde9597c53e0f89b1c86e",
                    "url": "https://api.github.com/repos/cython/cython/commits/b78eb1eac8f908a40cacde9597c53e0f89b1c86e"
                }
            ],
            "sha": "bda031eea8f182c297afb12d0fc32b7ae3a178f6",
            "url": "https://api.github.com/repos/cython/cython/commits/bda031eea8f182c297afb12d0fc32b7ae3a178f6"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/529f57c96e3df51d842b1ad436a6152be5ca06d5/comments",
            "commit": {
                "author": {
                    "date": "2020-11-17T18:59:08Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-17T18:59:08Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Change function name, fix for Py2",
                "tree": {
                    "sha": "18606f21b3d096aaa01decbcb5ab0f24c1d5ffbb",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/18606f21b3d096aaa01decbcb5ab0f24c1d5ffbb"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/529f57c96e3df51d842b1ad436a6152be5ca06d5",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/529f57c96e3df51d842b1ad436a6152be5ca06d5",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NTI5ZjU3Yzk2ZTNkZjUxZDg0MmIxYWQ0MzZhNjE1MmJlNWNhMDZkNQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/bda031eea8f182c297afb12d0fc32b7ae3a178f6",
                    "sha": "bda031eea8f182c297afb12d0fc32b7ae3a178f6",
                    "url": "https://api.github.com/repos/cython/cython/commits/bda031eea8f182c297afb12d0fc32b7ae3a178f6"
                }
            ],
            "sha": "529f57c96e3df51d842b1ad436a6152be5ca06d5",
            "url": "https://api.github.com/repos/cython/cython/commits/529f57c96e3df51d842b1ad436a6152be5ca06d5"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/04392ce4e2047e6715820104acc699d4518ffe7f/comments",
            "commit": {
                "author": {
                    "date": "2020-11-18T08:02:48Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-11-18T08:02:48Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Code style",
                "tree": {
                    "sha": "1cb77df27a7e4559e4131c9fc1ffa1ac559f7a46",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/1cb77df27a7e4559e4131c9fc1ffa1ac559f7a46"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/04392ce4e2047e6715820104acc699d4518ffe7f",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/04392ce4e2047e6715820104acc699d4518ffe7f",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MDQzOTJjZTRlMjA0N2U2NzE1ODIwMTA0YWNjNjk5ZDQ1MThmZmU3Zg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/529f57c96e3df51d842b1ad436a6152be5ca06d5",
                    "sha": "529f57c96e3df51d842b1ad436a6152be5ca06d5",
                    "url": "https://api.github.com/repos/cython/cython/commits/529f57c96e3df51d842b1ad436a6152be5ca06d5"
                }
            ],
            "sha": "04392ce4e2047e6715820104acc699d4518ffe7f",
            "url": "https://api.github.com/repos/cython/cython/commits/04392ce4e2047e6715820104acc699d4518ffe7f"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/f3bd1fa61049f9be7777b0c0b76521239b55d965/comments",
            "commit": {
                "author": {
                    "date": "2020-12-20T11:01:29Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-20T11:01:29Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'typing_support' into dataclasses2",
                "tree": {
                    "sha": "441d9b70c2e7316fa906c7ff64c058883ba43927",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/441d9b70c2e7316fa906c7ff64c058883ba43927"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/f3bd1fa61049f9be7777b0c0b76521239b55d965",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/f3bd1fa61049f9be7777b0c0b76521239b55d965",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZjNiZDFmYTYxMDQ5ZjliZTc3NzdiMGMwYjc2NTIxMjM5YjU1ZDk2NQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/f23fb742511e361bbc5cb8c3cc19a6ccbadc91f2",
                    "sha": "f23fb742511e361bbc5cb8c3cc19a6ccbadc91f2",
                    "url": "https://api.github.com/repos/cython/cython/commits/f23fb742511e361bbc5cb8c3cc19a6ccbadc91f2"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/04392ce4e2047e6715820104acc699d4518ffe7f",
                    "sha": "04392ce4e2047e6715820104acc699d4518ffe7f",
                    "url": "https://api.github.com/repos/cython/cython/commits/04392ce4e2047e6715820104acc699d4518ffe7f"
                }
            ],
            "sha": "f3bd1fa61049f9be7777b0c0b76521239b55d965",
            "url": "https://api.github.com/repos/cython/cython/commits/f3bd1fa61049f9be7777b0c0b76521239b55d965"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/46e10f250ae157d2abc3fc470a8141a6431e2c32/comments",
            "commit": {
                "author": {
                    "date": "2020-12-20T17:13:59Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-20T17:23:52Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Made \"import as\" work with cdef defined variables",
                "tree": {
                    "sha": "af625b5838f5cc1d9842d57854e8aff19218c492",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/af625b5838f5cc1d9842d57854e8aff19218c492"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/46e10f250ae157d2abc3fc470a8141a6431e2c32",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/46e10f250ae157d2abc3fc470a8141a6431e2c32",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NDZlMTBmMjUwYWUxNTdkMmFiYzNmYzQ3MGE4MTQxYTY0MzFlMmMzMg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/04392ce4e2047e6715820104acc699d4518ffe7f",
                    "sha": "04392ce4e2047e6715820104acc699d4518ffe7f",
                    "url": "https://api.github.com/repos/cython/cython/commits/04392ce4e2047e6715820104acc699d4518ffe7f"
                }
            ],
            "sha": "46e10f250ae157d2abc3fc470a8141a6431e2c32",
            "url": "https://api.github.com/repos/cython/cython/commits/46e10f250ae157d2abc3fc470a8141a6431e2c32"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/fca51437167ff0cf11e6888848f8c63dab69b979/comments",
            "commit": {
                "author": {
                    "date": "2020-12-20T17:25:36Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-20T17:25:36Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'typing_support' into dataclasses3",
                "tree": {
                    "sha": "91a6aa72a1e4bdbcf9001e6a03642119a9899dab",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/91a6aa72a1e4bdbcf9001e6a03642119a9899dab"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/fca51437167ff0cf11e6888848f8c63dab69b979",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/fca51437167ff0cf11e6888848f8c63dab69b979",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZmNhNTE0MzcxNjdmZjBjZjExZTY4ODg4NDhmOGM2M2RhYjY5Yjk3OQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/f3bd1fa61049f9be7777b0c0b76521239b55d965",
                    "sha": "f3bd1fa61049f9be7777b0c0b76521239b55d965",
                    "url": "https://api.github.com/repos/cython/cython/commits/f3bd1fa61049f9be7777b0c0b76521239b55d965"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/46e10f250ae157d2abc3fc470a8141a6431e2c32",
                    "sha": "46e10f250ae157d2abc3fc470a8141a6431e2c32",
                    "url": "https://api.github.com/repos/cython/cython/commits/46e10f250ae157d2abc3fc470a8141a6431e2c32"
                }
            ],
            "sha": "fca51437167ff0cf11e6888848f8c63dab69b979",
            "url": "https://api.github.com/repos/cython/cython/commits/fca51437167ff0cf11e6888848f8c63dab69b979"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/4c6354f0540bee982541d975344b0228d8693781/comments",
            "commit": {
                "author": {
                    "date": "2020-12-20T10:52:06Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-20T17:29:22Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Made InitVar and ClassVar work from their python modules\n\nRather than declaring them inside the cython cimport module",
                "tree": {
                    "sha": "de4262e01979a908395db2f4199af06bcdedc70e",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/de4262e01979a908395db2f4199af06bcdedc70e"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/4c6354f0540bee982541d975344b0228d8693781",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/4c6354f0540bee982541d975344b0228d8693781",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NGM2MzU0ZjA1NDBiZWU5ODI1NDFkOTc1MzQ0YjAyMjhkODY5Mzc4MQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/fca51437167ff0cf11e6888848f8c63dab69b979",
                    "sha": "fca51437167ff0cf11e6888848f8c63dab69b979",
                    "url": "https://api.github.com/repos/cython/cython/commits/fca51437167ff0cf11e6888848f8c63dab69b979"
                }
            ],
            "sha": "4c6354f0540bee982541d975344b0228d8693781",
            "url": "https://api.github.com/repos/cython/cython/commits/4c6354f0540bee982541d975344b0228d8693781"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/1f424ddc8dc6abcfadc13c685f63e92474201508/comments",
            "commit": {
                "author": {
                    "date": "2020-12-20T17:38:36Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-20T17:41:16Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Trivial suggestions from code review",
                "tree": {
                    "sha": "5938a8a73794ab26b17f42d08db09e90deb64239",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/5938a8a73794ab26b17f42d08db09e90deb64239"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/1f424ddc8dc6abcfadc13c685f63e92474201508",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/1f424ddc8dc6abcfadc13c685f63e92474201508",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MWY0MjRkZGM4ZGM2YWJjZmFkYzEzYzY4NWY2M2U5MjQ3NDIwMTUwOA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/4c6354f0540bee982541d975344b0228d8693781",
                    "sha": "4c6354f0540bee982541d975344b0228d8693781",
                    "url": "https://api.github.com/repos/cython/cython/commits/4c6354f0540bee982541d975344b0228d8693781"
                }
            ],
            "sha": "1f424ddc8dc6abcfadc13c685f63e92474201508",
            "url": "https://api.github.com/repos/cython/cython/commits/1f424ddc8dc6abcfadc13c685f63e92474201508"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/b9f079ef3843ab267b99f15b948b33063b523c86/comments",
            "commit": {
                "author": {
                    "date": "2020-12-20T18:02:20Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-20T18:02:20Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Simplified loading of std-lib and fallback (a bit)",
                "tree": {
                    "sha": "8ebec3e39d2a2505d6992d8301f3eb1b4756895c",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/8ebec3e39d2a2505d6992d8301f3eb1b4756895c"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/b9f079ef3843ab267b99f15b948b33063b523c86",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/b9f079ef3843ab267b99f15b948b33063b523c86",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YjlmMDc5ZWYzODQzYWIyNjdiOTlmMTViOTQ4YjMzMDYzYjUyM2M4Ng==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/1f424ddc8dc6abcfadc13c685f63e92474201508",
                    "sha": "1f424ddc8dc6abcfadc13c685f63e92474201508",
                    "url": "https://api.github.com/repos/cython/cython/commits/1f424ddc8dc6abcfadc13c685f63e92474201508"
                }
            ],
            "sha": "b9f079ef3843ab267b99f15b948b33063b523c86",
            "url": "https://api.github.com/repos/cython/cython/commits/b9f079ef3843ab267b99f15b948b33063b523c86"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/764e138ae4aae544a9eaa0a5da8127416f7bcc85/comments",
            "commit": {
                "author": {
                    "date": "2020-12-21T19:46:31Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-21T19:46:31Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Remove pep563_annotation addition to entry\n\nAnd other changes from review",
                "tree": {
                    "sha": "d7e1be5240334388bdc0cd3f1a47df056e62fb02",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/d7e1be5240334388bdc0cd3f1a47df056e62fb02"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/764e138ae4aae544a9eaa0a5da8127416f7bcc85",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/764e138ae4aae544a9eaa0a5da8127416f7bcc85",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NzY0ZTEzOGFlNGFhZTU0NGE5ZWFhMGE1ZGE4MTI3NDE2ZjdiY2M4NQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/b9f079ef3843ab267b99f15b948b33063b523c86",
                    "sha": "b9f079ef3843ab267b99f15b948b33063b523c86",
                    "url": "https://api.github.com/repos/cython/cython/commits/b9f079ef3843ab267b99f15b948b33063b523c86"
                }
            ],
            "sha": "764e138ae4aae544a9eaa0a5da8127416f7bcc85",
            "url": "https://api.github.com/repos/cython/cython/commits/764e138ae4aae544a9eaa0a5da8127416f7bcc85"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd/comments",
            "commit": {
                "author": {
                    "date": "2020-12-21T19:49:29Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-21T19:49:29Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Remove unneeded dummy entries",
                "tree": {
                    "sha": "30a4a08fe35e7e1fb4ccce3be4e59069861780e8",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/30a4a08fe35e7e1fb4ccce3be4e59069861780e8"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MDZjNTcwODA0ZDhmN2Y2MjZkNGNjMmM2MmU1NDZhN2Y2YmNmYzRjZA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/46e10f250ae157d2abc3fc470a8141a6431e2c32",
                    "sha": "46e10f250ae157d2abc3fc470a8141a6431e2c32",
                    "url": "https://api.github.com/repos/cython/cython/commits/46e10f250ae157d2abc3fc470a8141a6431e2c32"
                }
            ],
            "sha": "06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd",
            "url": "https://api.github.com/repos/cython/cython/commits/06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/719bf1d50edb3badb9484f02ffc5443183a934ce/comments",
            "commit": {
                "author": {
                    "date": "2020-12-21T19:49:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-21T19:49:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'typing_support' into dataclass",
                "tree": {
                    "sha": "4f625c7be740e11a5e80687aacb2b22a12acc450",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/4f625c7be740e11a5e80687aacb2b22a12acc450"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/719bf1d50edb3badb9484f02ffc5443183a934ce",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/719bf1d50edb3badb9484f02ffc5443183a934ce",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NzE5YmYxZDUwZWRiM2JhZGI5NDg0ZjAyZmZjNTQ0MzE4M2E5MzRjZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/764e138ae4aae544a9eaa0a5da8127416f7bcc85",
                    "sha": "764e138ae4aae544a9eaa0a5da8127416f7bcc85",
                    "url": "https://api.github.com/repos/cython/cython/commits/764e138ae4aae544a9eaa0a5da8127416f7bcc85"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd",
                    "sha": "06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd",
                    "url": "https://api.github.com/repos/cython/cython/commits/06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd"
                }
            ],
            "sha": "719bf1d50edb3badb9484f02ffc5443183a934ce",
            "url": "https://api.github.com/repos/cython/cython/commits/719bf1d50edb3badb9484f02ffc5443183a934ce"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/2b0ae30f2288c861d06ba1e0d40b8e2e8040f14d/comments",
            "commit": {
                "author": {
                    "date": "2020-12-27T08:55:01Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-27T08:55:01Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Change Ellipsis comment",
                "tree": {
                    "sha": "cea93033369978b962163573150ad8a067f42307",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/cea93033369978b962163573150ad8a067f42307"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/2b0ae30f2288c861d06ba1e0d40b8e2e8040f14d",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/2b0ae30f2288c861d06ba1e0d40b8e2e8040f14d",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MmIwYWUzMGYyMjg4Yzg2MWQwNmJhMWUwZDQwYjhlMmU4MDQwZjE0ZA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/719bf1d50edb3badb9484f02ffc5443183a934ce",
                    "sha": "719bf1d50edb3badb9484f02ffc5443183a934ce",
                    "url": "https://api.github.com/repos/cython/cython/commits/719bf1d50edb3badb9484f02ffc5443183a934ce"
                }
            ],
            "sha": "2b0ae30f2288c861d06ba1e0d40b8e2e8040f14d",
            "url": "https://api.github.com/repos/cython/cython/commits/2b0ae30f2288c861d06ba1e0d40b8e2e8040f14d"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/1a9e996779e80b4a70f95cc82115e0133b6cffe4/comments",
            "commit": {
                "author": {
                    "date": "2020-12-27T09:13:11Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-27T09:13:11Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Pick visibility in ExprNodes",
                "tree": {
                    "sha": "304ce0f1868d3457b39278ced5dc0618949c48ca",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/304ce0f1868d3457b39278ced5dc0618949c48ca"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/1a9e996779e80b4a70f95cc82115e0133b6cffe4",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/1a9e996779e80b4a70f95cc82115e0133b6cffe4",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MWE5ZTk5Njc3OWU4MGI0YTcwZjk1Y2M4MjExNWUwMTMzYjZjZmZlNA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/2b0ae30f2288c861d06ba1e0d40b8e2e8040f14d",
                    "sha": "2b0ae30f2288c861d06ba1e0d40b8e2e8040f14d",
                    "url": "https://api.github.com/repos/cython/cython/commits/2b0ae30f2288c861d06ba1e0d40b8e2e8040f14d"
                }
            ],
            "sha": "1a9e996779e80b4a70f95cc82115e0133b6cffe4",
            "url": "https://api.github.com/repos/cython/cython/commits/1a9e996779e80b4a70f95cc82115e0133b6cffe4"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/de0ff9e6da6dad8a774c33a88ff9273aad7813e0/comments",
            "commit": {
                "author": {
                    "date": "2020-12-27T09:57:15Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2020-12-27T09:57:15Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Remove \"DontReanalyseDeclarationsNode\"\n\ninstead make it safe to call \"analyse_declarations\" twice on\nLambdaNode",
                "tree": {
                    "sha": "589350ec185c5686d20730fc6b009496797bbb40",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/589350ec185c5686d20730fc6b009496797bbb40"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZGUwZmY5ZTZkYTZkYWQ4YTc3NGMzM2E4OGZmOTI3M2FhZDc4MTNlMA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/1a9e996779e80b4a70f95cc82115e0133b6cffe4",
                    "sha": "1a9e996779e80b4a70f95cc82115e0133b6cffe4",
                    "url": "https://api.github.com/repos/cython/cython/commits/1a9e996779e80b4a70f95cc82115e0133b6cffe4"
                }
            ],
            "sha": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
            "url": "https://api.github.com/repos/cython/cython/commits/de0ff9e6da6dad8a774c33a88ff9273aad7813e0"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/63fd8405aacfe26120e44ea324828dd03ece39e1/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T10:24:59Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T10:24:59Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Apply suggestions from code review\n\nCo-authored-by: scoder <stefan_ml@behnel.de>",
                "tree": {
                    "sha": "55ec747ce2a1226ab8eb58fb7f206fb367ac1efd",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/55ec747ce2a1226ab8eb58fb7f206fb367ac1efd"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/63fd8405aacfe26120e44ea324828dd03ece39e1",
                "verification": {
                    "payload": "tree 55ec747ce2a1226ab8eb58fb7f206fb367ac1efd\nparent de0ff9e6da6dad8a774c33a88ff9273aad7813e0\nauthor da-woods <dw-git@d-woods.co.uk> 1613903099 +0000\ncommitter GitHub <noreply@github.com> 1613903099 +0000\n\nApply suggestions from code review\n\nCo-authored-by: scoder <stefan_ml@behnel.de>",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgMjT8CRBK7hj4Ov3rIwAAdHIIACoHm543UAJJ9OKLL+IrcYGZ\nYygyskbU3HnodUe1Jon9TI3n2rSW8QMm+Z6w4jdNouqf/g+wdL1UK8UImP43qLFD\nEdV9fQ9ysfxFM/G+SFpY+rBevXyQBGrRcaRkKOujW5V2AO5Pwl5GPgBgK2ZZtSlS\nrI/giRJPpTmTak2U2x5YILRgRASOJCPL4IOrBMgkB47qfFgFlQlJRdcOqW61p7Wy\nG4fnu7eUbdlrJM3dL0y37AYM39uIoJobqSaX9ciT6uqTTyLVl1zcy+CsnjVzZt9y\n2gdhtRL7bhGQWHytO8yL+pq1hRbLSSQfgsavig5xgMlT2Gxp3SJToLliiuql9TM=\n=Ksnx\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/63fd8405aacfe26120e44ea324828dd03ece39e1",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NjNmZDg0MDVhYWNmZTI2MTIwZTQ0ZWEzMjQ4MjhkZDAzZWNlMzllMQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
                    "sha": "de0ff9e6da6dad8a774c33a88ff9273aad7813e0",
                    "url": "https://api.github.com/repos/cython/cython/commits/de0ff9e6da6dad8a774c33a88ff9273aad7813e0"
                }
            ],
            "sha": "63fd8405aacfe26120e44ea324828dd03ece39e1",
            "url": "https://api.github.com/repos/cython/cython/commits/63fd8405aacfe26120e44ea324828dd03ece39e1"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/72bdef2926846745574e4af0cebaf5c5fbc834ce/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T12:34:05Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T12:34:05Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "More (manual) changes from review",
                "tree": {
                    "sha": "e6ea24b18ad7fa7afe462b26787024570ab85d71",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/e6ea24b18ad7fa7afe462b26787024570ab85d71"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/72bdef2926846745574e4af0cebaf5c5fbc834ce",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/72bdef2926846745574e4af0cebaf5c5fbc834ce",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NzJiZGVmMjkyNjg0Njc0NTU3NGU0YWYwY2ViYWY1YzVmYmM4MzRjZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/63fd8405aacfe26120e44ea324828dd03ece39e1",
                    "sha": "63fd8405aacfe26120e44ea324828dd03ece39e1",
                    "url": "https://api.github.com/repos/cython/cython/commits/63fd8405aacfe26120e44ea324828dd03ece39e1"
                }
            ],
            "sha": "72bdef2926846745574e4af0cebaf5c5fbc834ce",
            "url": "https://api.github.com/repos/cython/cython/commits/72bdef2926846745574e4af0cebaf5c5fbc834ce"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/6d4d0d68cc189759de82ac506186e10de930d048/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T10:24:59Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T12:38:58Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Apply suggestions from code review\n\nCo-authored-by: scoder <stefan_ml@behnel.de>",
                "tree": {
                    "sha": "9769070da42f56252f96c6d30bc81b1ae0d30c53",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/9769070da42f56252f96c6d30bc81b1ae0d30c53"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/6d4d0d68cc189759de82ac506186e10de930d048",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/6d4d0d68cc189759de82ac506186e10de930d048",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NmQ0ZDBkNjhjYzE4OTc1OWRlODJhYzUwNjE4NmUxMGRlOTMwZDA0OA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd",
                    "sha": "06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd",
                    "url": "https://api.github.com/repos/cython/cython/commits/06c570804d8f7f626d4cc2c62e546a7f6bcfc4cd"
                }
            ],
            "sha": "6d4d0d68cc189759de82ac506186e10de930d048",
            "url": "https://api.github.com/repos/cython/cython/commits/6d4d0d68cc189759de82ac506186e10de930d048"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/9355b28f9a06d2b32ce96334d1064a404ec89094/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T12:34:05Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T12:43:23Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "More (manual) changes from review",
                "tree": {
                    "sha": "e7acda387a45c3b165916a012ce050c926a9ed8a",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/e7acda387a45c3b165916a012ce050c926a9ed8a"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/9355b28f9a06d2b32ce96334d1064a404ec89094",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/9355b28f9a06d2b32ce96334d1064a404ec89094",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OTM1NWIyOGY5YTA2ZDJiMzJjZTk2MzM0ZDEwNjRhNDA0ZWM4OTA5NA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/6d4d0d68cc189759de82ac506186e10de930d048",
                    "sha": "6d4d0d68cc189759de82ac506186e10de930d048",
                    "url": "https://api.github.com/repos/cython/cython/commits/6d4d0d68cc189759de82ac506186e10de930d048"
                }
            ],
            "sha": "9355b28f9a06d2b32ce96334d1064a404ec89094",
            "url": "https://api.github.com/repos/cython/cython/commits/9355b28f9a06d2b32ce96334d1064a404ec89094"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/d86a9ec844e1f6ccaeb0df0c55d4a973508c795b/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T14:53:56Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T14:59:16Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Tests that should have been part of typing_support",
                "tree": {
                    "sha": "8b6678f7db0ded03cc8566d62cd4a6d65a7c2a80",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/8b6678f7db0ded03cc8566d62cd4a6d65a7c2a80"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/d86a9ec844e1f6ccaeb0df0c55d4a973508c795b",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/d86a9ec844e1f6ccaeb0df0c55d4a973508c795b",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZDg2YTllYzg0NGUxZjZjY2FlYjBkZjBjNTVkNGE5NzM1MDhjNzk1Yg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/9355b28f9a06d2b32ce96334d1064a404ec89094",
                    "sha": "9355b28f9a06d2b32ce96334d1064a404ec89094",
                    "url": "https://api.github.com/repos/cython/cython/commits/9355b28f9a06d2b32ce96334d1064a404ec89094"
                }
            ],
            "sha": "d86a9ec844e1f6ccaeb0df0c55d4a973508c795b",
            "url": "https://api.github.com/repos/cython/cython/commits/d86a9ec844e1f6ccaeb0df0c55d4a973508c795b"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/d1b0c999725b458cb1cf804a8647e808ac44b4f6/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T15:18:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T15:18:53Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Updated documentation",
                "tree": {
                    "sha": "95e0f0deda4fec4e02b47cfc1b8498e684b6d622",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/95e0f0deda4fec4e02b47cfc1b8498e684b6d622"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/d1b0c999725b458cb1cf804a8647e808ac44b4f6",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/d1b0c999725b458cb1cf804a8647e808ac44b4f6",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZDFiMGM5OTk3MjViNDU4Y2IxY2Y4MDRhODY0N2U4MDhhYzQ0YjRmNg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/d86a9ec844e1f6ccaeb0df0c55d4a973508c795b",
                    "sha": "d86a9ec844e1f6ccaeb0df0c55d4a973508c795b",
                    "url": "https://api.github.com/repos/cython/cython/commits/d86a9ec844e1f6ccaeb0df0c55d4a973508c795b"
                }
            ],
            "sha": "d1b0c999725b458cb1cf804a8647e808ac44b4f6",
            "url": "https://api.github.com/repos/cython/cython/commits/d1b0c999725b458cb1cf804a8647e808ac44b4f6"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/9abf841b84e190159885622069dd1cbfc061d25c/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T15:24:51Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T15:24:51Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'typing_support' into dataclass",
                "tree": {
                    "sha": "40505c9c6618f05540d34ad4a5646d4db69370ea",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/40505c9c6618f05540d34ad4a5646d4db69370ea"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/9abf841b84e190159885622069dd1cbfc061d25c",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/9abf841b84e190159885622069dd1cbfc061d25c",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OWFiZjg0MWI4NGUxOTAxNTk4ODU2MjIwNjlkZDFjYmZjMDYxZDI1Yw==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/72bdef2926846745574e4af0cebaf5c5fbc834ce",
                    "sha": "72bdef2926846745574e4af0cebaf5c5fbc834ce",
                    "url": "https://api.github.com/repos/cython/cython/commits/72bdef2926846745574e4af0cebaf5c5fbc834ce"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/d1b0c999725b458cb1cf804a8647e808ac44b4f6",
                    "sha": "d1b0c999725b458cb1cf804a8647e808ac44b4f6",
                    "url": "https://api.github.com/repos/cython/cython/commits/d1b0c999725b458cb1cf804a8647e808ac44b4f6"
                }
            ],
            "sha": "9abf841b84e190159885622069dd1cbfc061d25c",
            "url": "https://api.github.com/repos/cython/cython/commits/9abf841b84e190159885622069dd1cbfc061d25c"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/055e87a144043018d266c951983e7d34ee9cfd36/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T15:25:28Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T15:25:28Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Description in changelog",
                "tree": {
                    "sha": "ec965b7b3fe3044d0ca4ef1619081fd4b5dd2792",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/ec965b7b3fe3044d0ca4ef1619081fd4b5dd2792"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/055e87a144043018d266c951983e7d34ee9cfd36",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/055e87a144043018d266c951983e7d34ee9cfd36",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MDU1ZTg3YTE0NDA0MzAxOGQyNjZjOTUxOTgzZTdkMzRlZTljZmQzNg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/9abf841b84e190159885622069dd1cbfc061d25c",
                    "sha": "9abf841b84e190159885622069dd1cbfc061d25c",
                    "url": "https://api.github.com/repos/cython/cython/commits/9abf841b84e190159885622069dd1cbfc061d25c"
                }
            ],
            "sha": "055e87a144043018d266c951983e7d34ee9cfd36",
            "url": "https://api.github.com/repos/cython/cython/commits/055e87a144043018d266c951983e7d34ee9cfd36"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/d8f3186729a861ad459bf999d74ae6ba051f2dc1/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T15:31:19Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T15:31:19Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fixed typing_module test merge",
                "tree": {
                    "sha": "4552b5a96a38033e18ce63dc1daa38d9076afba1",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/4552b5a96a38033e18ce63dc1daa38d9076afba1"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/d8f3186729a861ad459bf999d74ae6ba051f2dc1",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/d8f3186729a861ad459bf999d74ae6ba051f2dc1",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZDhmMzE4NjcyOWE4NjFhZDQ1OWJmOTk5ZDc0YWU2YmEwNTFmMmRjMQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/055e87a144043018d266c951983e7d34ee9cfd36",
                    "sha": "055e87a144043018d266c951983e7d34ee9cfd36",
                    "url": "https://api.github.com/repos/cython/cython/commits/055e87a144043018d266c951983e7d34ee9cfd36"
                }
            ],
            "sha": "d8f3186729a861ad459bf999d74ae6ba051f2dc1",
            "url": "https://api.github.com/repos/cython/cython/commits/d8f3186729a861ad459bf999d74ae6ba051f2dc1"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/46d0c66a9e629e3db610da2efbc299f75bd114c1/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T18:08:24Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T18:09:22Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Version for pure Python test",
                "tree": {
                    "sha": "2ab8b83bab255c6b582a8eedd6b24e5eaf81af50",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/2ab8b83bab255c6b582a8eedd6b24e5eaf81af50"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/46d0c66a9e629e3db610da2efbc299f75bd114c1",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/46d0c66a9e629e3db610da2efbc299f75bd114c1",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NDZkMGM2NmE5ZTYyOWUzZGI2MTBkYTJlZmJjMjk5Zjc1YmQxMTRjMQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/d1b0c999725b458cb1cf804a8647e808ac44b4f6",
                    "sha": "d1b0c999725b458cb1cf804a8647e808ac44b4f6",
                    "url": "https://api.github.com/repos/cython/cython/commits/d1b0c999725b458cb1cf804a8647e808ac44b4f6"
                }
            ],
            "sha": "46d0c66a9e629e3db610da2efbc299f75bd114c1",
            "url": "https://api.github.com/repos/cython/cython/commits/46d0c66a9e629e3db610da2efbc299f75bd114c1"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/25898ab19058cb1c9610e59922f9fb6e91f7d82b/comments",
            "commit": {
                "author": {
                    "date": "2021-02-21T18:09:39Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-02-21T18:09:39Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'typing_support' into dataclass",
                "tree": {
                    "sha": "12373c38f8385271ecc17678baa6ab5b528f3801",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/12373c38f8385271ecc17678baa6ab5b528f3801"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/25898ab19058cb1c9610e59922f9fb6e91f7d82b",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/25898ab19058cb1c9610e59922f9fb6e91f7d82b",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MjU4OThhYjE5MDU4Y2IxYzk2MTBlNTk5MjJmOWZiNmU5MWY3ZDgyYg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/d8f3186729a861ad459bf999d74ae6ba051f2dc1",
                    "sha": "d8f3186729a861ad459bf999d74ae6ba051f2dc1",
                    "url": "https://api.github.com/repos/cython/cython/commits/d8f3186729a861ad459bf999d74ae6ba051f2dc1"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/46d0c66a9e629e3db610da2efbc299f75bd114c1",
                    "sha": "46d0c66a9e629e3db610da2efbc299f75bd114c1",
                    "url": "https://api.github.com/repos/cython/cython/commits/46d0c66a9e629e3db610da2efbc299f75bd114c1"
                }
            ],
            "sha": "25898ab19058cb1c9610e59922f9fb6e91f7d82b",
            "url": "https://api.github.com/repos/cython/cython/commits/25898ab19058cb1c9610e59922f9fb6e91f7d82b"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/c78720e87e8547c1edfa8537cc4810cff3143ee8/comments",
            "commit": {
                "author": {
                    "date": "2021-05-25T16:32:49Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-25T16:32:49Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "2dbcd091376d745995c0cfeb7026f1e48b1a6eab",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/2dbcd091376d745995c0cfeb7026f1e48b1a6eab"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/c78720e87e8547c1edfa8537cc4810cff3143ee8",
                "verification": {
                    "payload": "tree 2dbcd091376d745995c0cfeb7026f1e48b1a6eab\nparent 25898ab19058cb1c9610e59922f9fb6e91f7d82b\nparent 28c35f432f73b0b710cc5f6a823e11bca53265b0\nauthor da-woods <dw-git@d-woods.co.uk> 1621960369 +0100\ncommitter GitHub <noreply@github.com> 1621960369 +0100\n\nMerge branch 'master' into dataclass",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgrSaxCRBK7hj4Ov3rIwAAaNwIAF7qCAoKCF7m3QWxVHiGjgn1\nliMXKOFaO8+y3nuM0eKpDhhM/82WZqLsKMpiLlUNIBtMeWZxYYtj3hWjoYgjDV8T\noofXyg0TsR4jVJM9ZUpsa+I/r4uW3fLpTObGTNpEDRh/vIkhEgkgUJyh12atOSuq\nQAWAhkhFZiYW4Yl6MskRgjkWkyeWfxFHCiSVcb3rg42fF6DJxeg8LARrh/B6ml9V\nmP4hiPmsJ+lu3ZDykCSLYVb9/dcqti3uAKv+5CBG+F9jX+PLl6Ces3ayehVqnuz5\nbr4eG+6Se/Zp6BghwISbBXsYZckLEoVndy06i/Dd73YoNRwGyODRARSIoPdclPA=\n=cyVk\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/c78720e87e8547c1edfa8537cc4810cff3143ee8",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6Yzc4NzIwZTg3ZTg1NDdjMWVkZmE4NTM3Y2M0ODEwY2ZmMzE0M2VlOA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/25898ab19058cb1c9610e59922f9fb6e91f7d82b",
                    "sha": "25898ab19058cb1c9610e59922f9fb6e91f7d82b",
                    "url": "https://api.github.com/repos/cython/cython/commits/25898ab19058cb1c9610e59922f9fb6e91f7d82b"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/28c35f432f73b0b710cc5f6a823e11bca53265b0",
                    "sha": "28c35f432f73b0b710cc5f6a823e11bca53265b0",
                    "url": "https://api.github.com/repos/cython/cython/commits/28c35f432f73b0b710cc5f6a823e11bca53265b0"
                }
            ],
            "sha": "c78720e87e8547c1edfa8537cc4810cff3143ee8",
            "url": "https://api.github.com/repos/cython/cython/commits/c78720e87e8547c1edfa8537cc4810cff3143ee8"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/a630420caed996b1c4cba40fcf084eaa75e4fc15/comments",
            "commit": {
                "author": {
                    "date": "2021-05-25T16:34:47Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-25T16:34:47Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'master' into typing_support",
                "tree": {
                    "sha": "446ceb0e7d54bd9c1a52897de65cea2c470bb965",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/446ceb0e7d54bd9c1a52897de65cea2c470bb965"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/a630420caed996b1c4cba40fcf084eaa75e4fc15",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/a630420caed996b1c4cba40fcf084eaa75e4fc15",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YTYzMDQyMGNhZWQ5OTZiMWM0Y2JhNDBmY2YwODRlYWE3NWU0ZmMxNQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/46d0c66a9e629e3db610da2efbc299f75bd114c1",
                    "sha": "46d0c66a9e629e3db610da2efbc299f75bd114c1",
                    "url": "https://api.github.com/repos/cython/cython/commits/46d0c66a9e629e3db610da2efbc299f75bd114c1"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/c6571f327e8e4e14e98eaa492967721ccdbe2952",
                    "sha": "c6571f327e8e4e14e98eaa492967721ccdbe2952",
                    "url": "https://api.github.com/repos/cython/cython/commits/c6571f327e8e4e14e98eaa492967721ccdbe2952"
                }
            ],
            "sha": "a630420caed996b1c4cba40fcf084eaa75e4fc15",
            "url": "https://api.github.com/repos/cython/cython/commits/a630420caed996b1c4cba40fcf084eaa75e4fc15"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/a204b770316c25ae64b9d04b8ce8f8bb4fa5d3de/comments",
            "commit": {
                "author": {
                    "date": "2021-05-25T18:09:45Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-25T18:09:45Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Simplified lookup, fixed code-style in tests",
                "tree": {
                    "sha": "bd50f05d3e80dadb49b27cf071210453a08348c5",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/bd50f05d3e80dadb49b27cf071210453a08348c5"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/a204b770316c25ae64b9d04b8ce8f8bb4fa5d3de",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/a204b770316c25ae64b9d04b8ce8f8bb4fa5d3de",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YTIwNGI3NzAzMTZjMjVhZTY0YjlkMDRiOGNlOGY4YmI0ZmE1ZDNkZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/a630420caed996b1c4cba40fcf084eaa75e4fc15",
                    "sha": "a630420caed996b1c4cba40fcf084eaa75e4fc15",
                    "url": "https://api.github.com/repos/cython/cython/commits/a630420caed996b1c4cba40fcf084eaa75e4fc15"
                }
            ],
            "sha": "a204b770316c25ae64b9d04b8ce8f8bb4fa5d3de",
            "url": "https://api.github.com/repos/cython/cython/commits/a204b770316c25ae64b9d04b8ce8f8bb4fa5d3de"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/73016be7bc1b247ff0e5b309793db50779047141/comments",
            "commit": {
                "author": {
                    "date": "2021-05-25T19:16:52Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-25T19:16:52Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Hopefully better fix for lookup",
                "tree": {
                    "sha": "db1aa1174e69df578ba676fc68f9ed8497cfb0dd",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/db1aa1174e69df578ba676fc68f9ed8497cfb0dd"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/73016be7bc1b247ff0e5b309793db50779047141",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/73016be7bc1b247ff0e5b309793db50779047141",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NzMwMTZiZTdiYzFiMjQ3ZmYwZTViMzA5NzkzZGI1MDc3OTA0NzE0MQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/a204b770316c25ae64b9d04b8ce8f8bb4fa5d3de",
                    "sha": "a204b770316c25ae64b9d04b8ce8f8bb4fa5d3de",
                    "url": "https://api.github.com/repos/cython/cython/commits/a204b770316c25ae64b9d04b8ce8f8bb4fa5d3de"
                }
            ],
            "sha": "73016be7bc1b247ff0e5b309793db50779047141",
            "url": "https://api.github.com/repos/cython/cython/commits/73016be7bc1b247ff0e5b309793db50779047141"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/fa49c5cd1323a4da4ad2d2c99ad7bc0ff06665d1/comments",
            "commit": {
                "author": {
                    "date": "2021-05-25T19:51:14Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-25T19:51:14Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Split lookup function into entry and module version\n\nAlso rename it",
                "tree": {
                    "sha": "b046753a78258e458c0a691f0dde11eb51fa512c",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/b046753a78258e458c0a691f0dde11eb51fa512c"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/fa49c5cd1323a4da4ad2d2c99ad7bc0ff06665d1",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/fa49c5cd1323a4da4ad2d2c99ad7bc0ff06665d1",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZmE0OWM1Y2QxMzIzYTRkYTRhZDJkMmM5OWFkN2JjMGZmMDY2NjVkMQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/73016be7bc1b247ff0e5b309793db50779047141",
                    "sha": "73016be7bc1b247ff0e5b309793db50779047141",
                    "url": "https://api.github.com/repos/cython/cython/commits/73016be7bc1b247ff0e5b309793db50779047141"
                }
            ],
            "sha": "fa49c5cd1323a4da4ad2d2c99ad7bc0ff06665d1",
            "url": "https://api.github.com/repos/cython/cython/commits/fa49c5cd1323a4da4ad2d2c99ad7bc0ff06665d1"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/38297161e4d160a1074df743888fb61c220aec0f/comments",
            "commit": {
                "author": {
                    "date": "2021-05-25T20:27:55Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-25T20:27:55Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Lookup module instead of entry",
                "tree": {
                    "sha": "0b92eb7cc40cf861e2c66152649de1b195b4fb77",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/0b92eb7cc40cf861e2c66152649de1b195b4fb77"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/38297161e4d160a1074df743888fb61c220aec0f",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/38297161e4d160a1074df743888fb61c220aec0f",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MzgyOTcxNjFlNGQxNjBhMTA3NGRmNzQzODg4ZmI2MWMyMjBhZWMwZg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/fa49c5cd1323a4da4ad2d2c99ad7bc0ff06665d1",
                    "sha": "fa49c5cd1323a4da4ad2d2c99ad7bc0ff06665d1",
                    "url": "https://api.github.com/repos/cython/cython/commits/fa49c5cd1323a4da4ad2d2c99ad7bc0ff06665d1"
                }
            ],
            "sha": "38297161e4d160a1074df743888fb61c220aec0f",
            "url": "https://api.github.com/repos/cython/cython/commits/38297161e4d160a1074df743888fb61c220aec0f"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e/comments",
            "commit": {
                "author": {
                    "date": "2021-05-26T06:12:48Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-26T06:12:48Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'typing_support' into dataclass",
                "tree": {
                    "sha": "02459e2fb94f565c8adecd5cc2e7852b32acbfcc",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/02459e2fb94f565c8adecd5cc2e7852b32acbfcc"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YTNkN2M2ZjE5ZmYxM2VhZDRlNzE1MGYwMDZkODQ4M2E4ZTlkYWY1ZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/c78720e87e8547c1edfa8537cc4810cff3143ee8",
                    "sha": "c78720e87e8547c1edfa8537cc4810cff3143ee8",
                    "url": "https://api.github.com/repos/cython/cython/commits/c78720e87e8547c1edfa8537cc4810cff3143ee8"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/38297161e4d160a1074df743888fb61c220aec0f",
                    "sha": "38297161e4d160a1074df743888fb61c220aec0f",
                    "url": "https://api.github.com/repos/cython/cython/commits/38297161e4d160a1074df743888fb61c220aec0f"
                }
            ],
            "sha": "a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e",
            "url": "https://api.github.com/repos/cython/cython/commits/a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/9ada9207f3eeae712fd1150bbb2e877cd11bac55/comments",
            "commit": {
                "author": {
                    "date": "2021-05-26T18:02:50Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-26T18:02:50Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "b0d849d299f8547f62068697e4264defaae233d3",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/b0d849d299f8547f62068697e4264defaae233d3"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/9ada9207f3eeae712fd1150bbb2e877cd11bac55",
                "verification": {
                    "payload": "tree b0d849d299f8547f62068697e4264defaae233d3\nparent a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e\nparent 565ba94e883e9bff328ade1e1cdefc70355d2b54\nauthor da-woods <dw-git@d-woods.co.uk> 1622052170 +0100\ncommitter GitHub <noreply@github.com> 1622052170 +0100\n\nMerge branch 'master' into dataclass",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgro1KCRBK7hj4Ov3rIwAAymIIAJg/YwGXIApM7A1a9f7kM2g3\nwe1dy8m+jk5wq3VwxLMm3TIvd9dW/tMxiXndvdvP5NOQ8XnLN5+46V+46Hr+7AzO\nkJTX2c5+XWzHNaX4sq8PySaALVeEu/9c0Ys1q8IwxgifNj28pemDpL5HpRQh9OKl\nDczzNVo1ChVHUFYcpEGJj11DiVu0Q5WB5r1dkGpjKVXPxeItb3dly5MP7JSykWfx\nacMh+WDY2mpQJYX62cxmVwRf7dw69RJM58waSOkGP6/OjVBKOtlRzjSmID6cyYT7\n3q7Xw9Abr58uRRZr6p7b8v0RZw6TrlZvpxp1Zx/yn86w8R/FeZT2zTHDRIyWxII=\n=Onjq\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/9ada9207f3eeae712fd1150bbb2e877cd11bac55",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OWFkYTkyMDdmM2VlYWU3MTJmZDExNTBiYmIyZTg3N2NkMTFiYWM1NQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e",
                    "sha": "a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e",
                    "url": "https://api.github.com/repos/cython/cython/commits/a3d7c6f19ff13ead4e7150f006d8483a8e9daf5e"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/565ba94e883e9bff328ade1e1cdefc70355d2b54",
                    "sha": "565ba94e883e9bff328ade1e1cdefc70355d2b54",
                    "url": "https://api.github.com/repos/cython/cython/commits/565ba94e883e9bff328ade1e1cdefc70355d2b54"
                }
            ],
            "sha": "9ada9207f3eeae712fd1150bbb2e877cd11bac55",
            "url": "https://api.github.com/repos/cython/cython/commits/9ada9207f3eeae712fd1150bbb2e877cd11bac55"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/67287e48cf538845fc90a2deac907917b1594600/comments",
            "commit": {
                "author": {
                    "date": "2021-05-26T18:05:50Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-05-26T18:05:50Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Try to fix differing PyPy error messages",
                "tree": {
                    "sha": "73213f3528cc4273547d328ef064312f17dc3ba2",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/73213f3528cc4273547d328ef064312f17dc3ba2"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/67287e48cf538845fc90a2deac907917b1594600",
                "verification": {
                    "payload": "tree 73213f3528cc4273547d328ef064312f17dc3ba2\nparent 9ada9207f3eeae712fd1150bbb2e877cd11bac55\nauthor da-woods <dw-git@d-woods.co.uk> 1622052350 +0100\ncommitter GitHub <noreply@github.com> 1622052350 +0100\n\nTry to fix differing PyPy error messages",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgro3+CRBK7hj4Ov3rIwAAxIkIABH1xoyxs7LIaqYIRG4CyD4P\nsQSNOhFcMq/3dpySIH5IulM8AlPEuhGeqrsPAY8FndLIMAnC3dknYYZ3oEG2sk8X\n8HyTMHpg/YVscyMio/TrpZozOuHRWoAEXHhWDJ791dNasAsr27R5IyQ8PdW2pgi4\nZzFY25pQ4MkCXa8QlyZ0Xhpz+aQy8sMTUNYtOrjK9HTVFVi2DTdtJyIKKgsOUoFQ\n7bl9MTx0lGlOMKpu0CzdasC2dSQtGLpGZA7k3TFyPz3zHa3VWRHgCxwtGLO71YQf\nJk1FZdmLWNSVJ3/XcQ+FCkXk+Jd2VVwfsCwzXbUKv+GVDvM2GNWrPVKP7hn3nyA=\n=RYg0\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/67287e48cf538845fc90a2deac907917b1594600",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NjcyODdlNDhjZjUzODg0NWZjOTBhMmRlYWM5MDc5MTdiMTU5NDYwMA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/9ada9207f3eeae712fd1150bbb2e877cd11bac55",
                    "sha": "9ada9207f3eeae712fd1150bbb2e877cd11bac55",
                    "url": "https://api.github.com/repos/cython/cython/commits/9ada9207f3eeae712fd1150bbb2e877cd11bac55"
                }
            ],
            "sha": "67287e48cf538845fc90a2deac907917b1594600",
            "url": "https://api.github.com/repos/cython/cython/commits/67287e48cf538845fc90a2deac907917b1594600"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/e8439ca94986e70cdfa4ef5c00da3042280a86bf/comments",
            "commit": {
                "author": {
                    "date": "2021-06-27T07:46:10Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-27T07:46:10Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'master' into typing_support",
                "tree": {
                    "sha": "a6adcf7a52b997fd2133d1a8d07e662720086680",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/a6adcf7a52b997fd2133d1a8d07e662720086680"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/e8439ca94986e70cdfa4ef5c00da3042280a86bf",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/e8439ca94986e70cdfa4ef5c00da3042280a86bf",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZTg0MzljYTk0OTg2ZTcwY2RmYTRlZjVjMDBkYTMwNDIyODBhODZiZg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/38297161e4d160a1074df743888fb61c220aec0f",
                    "sha": "38297161e4d160a1074df743888fb61c220aec0f",
                    "url": "https://api.github.com/repos/cython/cython/commits/38297161e4d160a1074df743888fb61c220aec0f"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/c74e08a0e4a92ac6bbe3d3b9284eefa685e5c409",
                    "sha": "c74e08a0e4a92ac6bbe3d3b9284eefa685e5c409",
                    "url": "https://api.github.com/repos/cython/cython/commits/c74e08a0e4a92ac6bbe3d3b9284eefa685e5c409"
                }
            ],
            "sha": "e8439ca94986e70cdfa4ef5c00da3042280a86bf",
            "url": "https://api.github.com/repos/cython/cython/commits/e8439ca94986e70cdfa4ef5c00da3042280a86bf"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/31790a151f40dcea142ab423dcc341038db3cc99/comments",
            "commit": {
                "author": {
                    "date": "2021-06-27T07:46:36Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-27T07:46:36Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'typing_support' into dataclass",
                "tree": {
                    "sha": "c1a4758bb61a08ec5b06a5ebed05a4b06822a480",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/c1a4758bb61a08ec5b06a5ebed05a4b06822a480"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/31790a151f40dcea142ab423dcc341038db3cc99",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/31790a151f40dcea142ab423dcc341038db3cc99",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MzE3OTBhMTUxZjQwZGNlYTE0MmFiNDIzZGNjMzQxMDM4ZGIzY2M5OQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/67287e48cf538845fc90a2deac907917b1594600",
                    "sha": "67287e48cf538845fc90a2deac907917b1594600",
                    "url": "https://api.github.com/repos/cython/cython/commits/67287e48cf538845fc90a2deac907917b1594600"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/e8439ca94986e70cdfa4ef5c00da3042280a86bf",
                    "sha": "e8439ca94986e70cdfa4ef5c00da3042280a86bf",
                    "url": "https://api.github.com/repos/cython/cython/commits/e8439ca94986e70cdfa4ef5c00da3042280a86bf"
                }
            ],
            "sha": "31790a151f40dcea142ab423dcc341038db3cc99",
            "url": "https://api.github.com/repos/cython/cython/commits/31790a151f40dcea142ab423dcc341038db3cc99"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/9b9cfa4fbfb7470ea42f726a49d6011e9c02c376/comments",
            "commit": {
                "author": {
                    "date": "2021-06-28T19:51:05Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-28T19:51:05Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Apply suggestions from code review\n\nCo-authored-by: scoder <stefan_ml@behnel.de>",
                "tree": {
                    "sha": "b4b7f5a614f0c26b9ec36c588bde1b2d3a984baa",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/b4b7f5a614f0c26b9ec36c588bde1b2d3a984baa"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/9b9cfa4fbfb7470ea42f726a49d6011e9c02c376",
                "verification": {
                    "payload": "tree b4b7f5a614f0c26b9ec36c588bde1b2d3a984baa\nparent 31790a151f40dcea142ab423dcc341038db3cc99\nauthor da-woods <dw-git@d-woods.co.uk> 1624909865 +0100\ncommitter GitHub <noreply@github.com> 1624909865 +0100\n\nApply suggestions from code review\n\nCo-authored-by: scoder <stefan_ml@behnel.de>",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg2igpCRBK7hj4Ov3rIwAABiIIAIiubarVNHlzZ/YsSk3ads1M\ndUllPGGcgAtO/ytZnnAuODK48nxbVOojQfKlJp79gbvHjrrgF2tDdYsawbbZuzaq\nvkjom5hc4+XK4LL9+ZqgCTOnrvGyT1OiV9/qU+gyW/ZFkXRaoRAOgBlNVUQgDs+3\ngw6is3S5r91TavVsvcBSNRIh6RgcllxyTv3tO+sRF1+GjSgnYvULuqYLr05+RxOU\nfd+Wh95r2x7Nf6tw7132ZQqIPunLyNxBHyTCsttf50T3/a2tzPmWOJFgGeMcuX3v\ng2xsOVbzQHtQVgbLjBmi6mJxIqOKogPbfolXyk94a3fFIaZK2TY2LwmcJ0AdeEg=\n=J7ZK\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/9b9cfa4fbfb7470ea42f726a49d6011e9c02c376",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OWI5Y2ZhNGZiZmI3NDcwZWE0MmY3MjZhNDlkNjAxMWU5YzAyYzM3Ng==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/31790a151f40dcea142ab423dcc341038db3cc99",
                    "sha": "31790a151f40dcea142ab423dcc341038db3cc99",
                    "url": "https://api.github.com/repos/cython/cython/commits/31790a151f40dcea142ab423dcc341038db3cc99"
                }
            ],
            "sha": "9b9cfa4fbfb7470ea42f726a49d6011e9c02c376",
            "url": "https://api.github.com/repos/cython/cython/commits/9b9cfa4fbfb7470ea42f726a49d6011e9c02c376"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/1831d6df5c1bb9158a437ffa7b5d23253f8fb0c8/comments",
            "commit": {
                "author": {
                    "date": "2021-06-28T20:07:54Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-28T20:10:45Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Use \"\" rather than False for known_standard_library_import",
                "tree": {
                    "sha": "c3bccf2f2ac4a5714dd01812e24075205e65edd1",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/c3bccf2f2ac4a5714dd01812e24075205e65edd1"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/1831d6df5c1bb9158a437ffa7b5d23253f8fb0c8",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/1831d6df5c1bb9158a437ffa7b5d23253f8fb0c8",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MTgzMWQ2ZGY1YzFiYjkxNThhNDM3ZmZhN2I1ZDIzMjUzZjhmYjBjOA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/e8439ca94986e70cdfa4ef5c00da3042280a86bf",
                    "sha": "e8439ca94986e70cdfa4ef5c00da3042280a86bf",
                    "url": "https://api.github.com/repos/cython/cython/commits/e8439ca94986e70cdfa4ef5c00da3042280a86bf"
                }
            ],
            "sha": "1831d6df5c1bb9158a437ffa7b5d23253f8fb0c8",
            "url": "https://api.github.com/repos/cython/cython/commits/1831d6df5c1bb9158a437ffa7b5d23253f8fb0c8"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/dc9794d1278d20dea0ac4e29b7b9e4727afa198a/comments",
            "commit": {
                "author": {
                    "date": "2021-06-28T20:12:01Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-28T20:12:01Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'typing_support' into dataclass",
                "tree": {
                    "sha": "f480d5026ea90fa8fdec1298a805acd03155c412",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/f480d5026ea90fa8fdec1298a805acd03155c412"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/dc9794d1278d20dea0ac4e29b7b9e4727afa198a",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/dc9794d1278d20dea0ac4e29b7b9e4727afa198a",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZGM5Nzk0ZDEyNzhkMjBkZWEwYWM0ZTI5YjdiOWU0NzI3YWZhMTk4YQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/9b9cfa4fbfb7470ea42f726a49d6011e9c02c376",
                    "sha": "9b9cfa4fbfb7470ea42f726a49d6011e9c02c376",
                    "url": "https://api.github.com/repos/cython/cython/commits/9b9cfa4fbfb7470ea42f726a49d6011e9c02c376"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/1831d6df5c1bb9158a437ffa7b5d23253f8fb0c8",
                    "sha": "1831d6df5c1bb9158a437ffa7b5d23253f8fb0c8",
                    "url": "https://api.github.com/repos/cython/cython/commits/1831d6df5c1bb9158a437ffa7b5d23253f8fb0c8"
                }
            ],
            "sha": "dc9794d1278d20dea0ac4e29b7b9e4727afa198a",
            "url": "https://api.github.com/repos/cython/cython/commits/dc9794d1278d20dea0ac4e29b7b9e4727afa198a"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/c98087dfb27d4277ee505f2533732ed600d6651c/comments",
            "commit": {
                "author": {
                    "date": "2021-06-30T21:05:14Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-30T21:05:14Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Remove annotation special case\r\n\r\nFixed elsewhere",
                "tree": {
                    "sha": "87252aba2eebc2bfe11bdbc7ebd5841f630d3e05",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/87252aba2eebc2bfe11bdbc7ebd5841f630d3e05"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/c98087dfb27d4277ee505f2533732ed600d6651c",
                "verification": {
                    "payload": "tree 87252aba2eebc2bfe11bdbc7ebd5841f630d3e05\nparent dc9794d1278d20dea0ac4e29b7b9e4727afa198a\nauthor da-woods <dw-git@d-woods.co.uk> 1625087114 +0100\ncommitter GitHub <noreply@github.com> 1625087114 +0100\n\nRemove annotation special case\r\n\r\nFixed elsewhere",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg3NyKCRBK7hj4Ov3rIwAAuC0IAH8z+V3KSzm3gPBaBNIjfmMC\njn9+Op60QrbOc4leLoYEL+JkRykeIZ2Lr51IB/6coxi8CuuiW73HHuaQbE6Iscpt\n879ZR4q5lQQudGvJvHTGCD9iPdmySOd6ysAxhG7Hv2/jLpsqOLECEPCrEm0nQLUp\nbI+77zJORJ9QE25gN1n4iU1JT+b/uA9Djp1yJSvUr/mk421TpFUDpx3IxJGrwkFy\nv58DdjD6JJg+M3qYpC43YMpGMb2sOFCFEefqH7X8ThDMSPuErnI+q01wwYJ80AfG\nGXgpiydZHTgFlTwHlBiNBNWcTxHoh8XLUNBzUEx5ZBER0eCv3+kJ8425Hz2pu08=\n=8EH7\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/c98087dfb27d4277ee505f2533732ed600d6651c",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6Yzk4MDg3ZGZiMjdkNDI3N2VlNTA1ZjI1MzM3MzJlZDYwMGQ2NjUxYw==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/dc9794d1278d20dea0ac4e29b7b9e4727afa198a",
                    "sha": "dc9794d1278d20dea0ac4e29b7b9e4727afa198a",
                    "url": "https://api.github.com/repos/cython/cython/commits/dc9794d1278d20dea0ac4e29b7b9e4727afa198a"
                }
            ],
            "sha": "c98087dfb27d4277ee505f2533732ed600d6651c",
            "url": "https://api.github.com/repos/cython/cython/commits/c98087dfb27d4277ee505f2533732ed600d6651c"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/314689f40ab509bb6d96a8380ae19ea4a3070045/comments",
            "commit": {
                "author": {
                    "date": "2021-06-30T21:11:01Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-30T21:11:01Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "491ae86684ff523a030a6fbea45c7135633d3a99",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/491ae86684ff523a030a6fbea45c7135633d3a99"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/314689f40ab509bb6d96a8380ae19ea4a3070045",
                "verification": {
                    "payload": "tree 491ae86684ff523a030a6fbea45c7135633d3a99\nparent c98087dfb27d4277ee505f2533732ed600d6651c\nparent f42b6eeb78e8ffd6c1a01383958381715a5a244a\nauthor da-woods <dw-git@d-woods.co.uk> 1625087461 +0100\ncommitter GitHub <noreply@github.com> 1625087461 +0100\n\nMerge branch 'master' into dataclass",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg3N3lCRBK7hj4Ov3rIwAAqTcIAJx3UNd1nxt3PuU5sC2OMCgU\n8V1QBpmT+hRpvbdVx4FyeD+t/+JYskRvEHPMjdtZB6p1g4CDXk4skdIe0Te8HvA0\n0Vmjg4+R6WR9JuFKz3s0fqn+7qzwNPUtUZHYUkkqRfT2Xeoh/oV/IlpWN8+NrsIj\nvzho1/TjTTS+pOZQo/Wnjf21MJIO0Ok6YoQmKy73BDmL8dfSvJUxTsoQtyWHEqJH\nttP6C4RFEv3DZtmiy1yw3HolIvk0G6w4JUVeMei/GJtz/qGnX+WiZOjjkHWEuk3v\nxAodgheRD3Zw8Kg1qCNoo//sgnga8vLXJSCotGOuRPt+IgUi/2PcizI9BWRD+Gg=\n=EPTq\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/314689f40ab509bb6d96a8380ae19ea4a3070045",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MzE0Njg5ZjQwYWI1MDliYjZkOTZhODM4MGFlMTllYTRhMzA3MDA0NQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/c98087dfb27d4277ee505f2533732ed600d6651c",
                    "sha": "c98087dfb27d4277ee505f2533732ed600d6651c",
                    "url": "https://api.github.com/repos/cython/cython/commits/c98087dfb27d4277ee505f2533732ed600d6651c"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/f42b6eeb78e8ffd6c1a01383958381715a5a244a",
                    "sha": "f42b6eeb78e8ffd6c1a01383958381715a5a244a",
                    "url": "https://api.github.com/repos/cython/cython/commits/f42b6eeb78e8ffd6c1a01383958381715a5a244a"
                }
            ],
            "sha": "314689f40ab509bb6d96a8380ae19ea4a3070045",
            "url": "https://api.github.com/repos/cython/cython/commits/314689f40ab509bb6d96a8380ae19ea4a3070045"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/801f96c039296a09d83f1c69b3d82ea7711e6cfe/comments",
            "commit": {
                "author": {
                    "date": "2021-06-30T21:17:04Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-30T21:17:04Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Missing comma",
                "tree": {
                    "sha": "faea72536fb3cb0b6a5f69848688701812d32ce7",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/faea72536fb3cb0b6a5f69848688701812d32ce7"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/801f96c039296a09d83f1c69b3d82ea7711e6cfe",
                "verification": {
                    "payload": "tree faea72536fb3cb0b6a5f69848688701812d32ce7\nparent 314689f40ab509bb6d96a8380ae19ea4a3070045\nauthor da-woods <dw-git@d-woods.co.uk> 1625087824 +0100\ncommitter GitHub <noreply@github.com> 1625087824 +0100\n\nMissing comma",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg3N9QCRBK7hj4Ov3rIwAAuGYIADl5cs/l0Dop+LNrBRA6T2CR\n5tkzhM9wV/hWOsDfSB1C9EHEeZWpg/nyEVruVXNpMwuoRweLHhSRfKc+Z/Yt6ihl\nbb+hSFYi8J/8QCkfdJcxLCB8iwTplwRIMpZt4eImcWQPrg7XmZ6bzQmowksKAmYR\nWkm+TRd177LBTWdzh4ff7DB/VJ7BAHixzisZNqmmho0J+pX9E2l6P+eCEc/pdodh\n1BttqrKHaEbkwBqIgi5kYG9PsAW87MSQfWKM6ZGF/torKCC9CpMoRmDL5hxuAYSI\nXgGL/JuSkaP231HuyEC5Z16pOrsoYSnFhbcO5hwAcKVulhO+vuYF7PwnWdEfzNg=\n=+cxF\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/801f96c039296a09d83f1c69b3d82ea7711e6cfe",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ODAxZjk2YzAzOTI5NmEwOWQ4M2YxYzY5YjNkODJlYTc3MTFlNmNmZQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/314689f40ab509bb6d96a8380ae19ea4a3070045",
                    "sha": "314689f40ab509bb6d96a8380ae19ea4a3070045",
                    "url": "https://api.github.com/repos/cython/cython/commits/314689f40ab509bb6d96a8380ae19ea4a3070045"
                }
            ],
            "sha": "801f96c039296a09d83f1c69b3d82ea7711e6cfe",
            "url": "https://api.github.com/repos/cython/cython/commits/801f96c039296a09d83f1c69b3d82ea7711e6cfe"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/a34ed274b76c2c167afe9918ebacbd42c63d6d8b/comments",
            "commit": {
                "author": {
                    "date": "2021-06-30T22:05:16Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-06-30T22:05:16Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "try to fix sys.module contents in Shadow.py\n\nNot at all confident because I can't reproduce the issue locally.",
                "tree": {
                    "sha": "d5d9b45e281e861108fcc74566cb3586a975548c",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/d5d9b45e281e861108fcc74566cb3586a975548c"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/a34ed274b76c2c167afe9918ebacbd42c63d6d8b",
                "verification": {
                    "payload": "tree d5d9b45e281e861108fcc74566cb3586a975548c\nparent 801f96c039296a09d83f1c69b3d82ea7711e6cfe\nauthor da-woods <dw-git@d-woods.co.uk> 1625090716 +0100\ncommitter GitHub <noreply@github.com> 1625090716 +0100\n\ntry to fix sys.module contents in Shadow.py\n\nNot at all confident because I can't reproduce the issue locally.",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg3OqcCRBK7hj4Ov3rIwAAehcIAAeJ6YcC3Lw1029ohLi7sr3G\nfHb4lTuAX0zrvU1rCqd2c9P7eRjEUG55tuisSL0l/m0/X9vWGaVODo8zE0wcyrw+\ne5oxnfNkaTwVvumNcz7tD5EXGuJJ4tKHC1nkgiJrWoKmgLHXCwLvgwuCjrb26sbY\nYd/81vMpGlCfFPo9pkUw3H5HwIrVP7IkP8jrLwIUywGOPgOuUK+n97efpZDInbEz\n8IHiZmECq0JTgyGwJlKG41QZGU7jrCzZyfbjeEHBKnTfs2IMwNeuqitwwq900XeV\nTUW4Z40iBmYyePkZ+cI1zx/ECuTyu+az5hvUsJu0/lvL7nVSBQtkGy9M1cTIRdg=\n=npDo\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/a34ed274b76c2c167afe9918ebacbd42c63d6d8b",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YTM0ZWQyNzRiNzZjMmMxNjdhZmU5OTE4ZWJhY2JkNDJjNjNkNmQ4Yg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/801f96c039296a09d83f1c69b3d82ea7711e6cfe",
                    "sha": "801f96c039296a09d83f1c69b3d82ea7711e6cfe",
                    "url": "https://api.github.com/repos/cython/cython/commits/801f96c039296a09d83f1c69b3d82ea7711e6cfe"
                }
            ],
            "sha": "a34ed274b76c2c167afe9918ebacbd42c63d6d8b",
            "url": "https://api.github.com/repos/cython/cython/commits/a34ed274b76c2c167afe9918ebacbd42c63d6d8b"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/0c6bc75e1e786726add59a3c5d97687586591036/comments",
            "commit": {
                "author": {
                    "date": "2021-07-01T06:42:15Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-01T06:42:15Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fix Shadow.py",
                "tree": {
                    "sha": "66c79aa688e2e794a4de65547290886ce6067ba5",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/66c79aa688e2e794a4de65547290886ce6067ba5"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/0c6bc75e1e786726add59a3c5d97687586591036",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/0c6bc75e1e786726add59a3c5d97687586591036",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MGM2YmM3NWUxZTc4NjcyNmFkZDU5YTNjNWQ5NzY4NzU4NjU5MTAzNg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/a34ed274b76c2c167afe9918ebacbd42c63d6d8b",
                    "sha": "a34ed274b76c2c167afe9918ebacbd42c63d6d8b",
                    "url": "https://api.github.com/repos/cython/cython/commits/a34ed274b76c2c167afe9918ebacbd42c63d6d8b"
                }
            ],
            "sha": "0c6bc75e1e786726add59a3c5d97687586591036",
            "url": "https://api.github.com/repos/cython/cython/commits/0c6bc75e1e786726add59a3c5d97687586591036"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/ffff42cbaa22ff204cb6e8ac57dea681436e0e25/comments",
            "commit": {
                "author": {
                    "date": "2021-07-01T18:20:22Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-01T18:20:22Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fixed type of ABI module name of Python3",
                "tree": {
                    "sha": "5afa21a00fe04acf9d0a145aeffc4f099b3c6156",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/5afa21a00fe04acf9d0a145aeffc4f099b3c6156"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZmZmZjQyY2JhYTIyZmYyMDRjYjZlOGFjNTdkZWE2ODE0MzZlMGUyNQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/0c6bc75e1e786726add59a3c5d97687586591036",
                    "sha": "0c6bc75e1e786726add59a3c5d97687586591036",
                    "url": "https://api.github.com/repos/cython/cython/commits/0c6bc75e1e786726add59a3c5d97687586591036"
                }
            ],
            "sha": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
            "url": "https://api.github.com/repos/cython/cython/commits/ffff42cbaa22ff204cb6e8ac57dea681436e0e25"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/9283a8537d9e4a6b982a395fd83cd52341b58cd3/comments",
            "commit": {
                "author": {
                    "date": "2021-07-19T10:55:50Z",
                    "email": "stefan_ml@behnel.de",
                    "name": "scoder"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-19T10:55:50Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Apply trivial suggestions from code review",
                "tree": {
                    "sha": "f173aa0a423b39541dfeffbfcac57153c5f6c668",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/f173aa0a423b39541dfeffbfcac57153c5f6c668"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/9283a8537d9e4a6b982a395fd83cd52341b58cd3",
                "verification": {
                    "payload": "tree f173aa0a423b39541dfeffbfcac57153c5f6c668\nparent ffff42cbaa22ff204cb6e8ac57dea681436e0e25\nauthor scoder <stefan_ml@behnel.de> 1626692150 +0200\ncommitter GitHub <noreply@github.com> 1626692150 +0200\n\nApply trivial suggestions from code review",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9Vo2CRBK7hj4Ov3rIwAAp3sIAGpwY7BQFNaAvSWviMnZoTho\nwmKFqq+pWGsapQhTNxhovRLKYBLlHhYH5eamyJ89mA5bWlou0namO4D+pAzUTGAt\n/IwKE7wodHWxnuwWSaJKHG5Y3RHZWS1kp0nxGgZmlpbMk/O0zVnVBH3qXImTxlKt\nt/8kEYbbhqz1j5ek2oQgjhEFccXfaiAsseshfI4ukFJ97Ye65NrIAkIieMct1iG4\nPUhFur1tjXVs5hBPEptbhhPEFwZ3gSYgqY+CoWWs/kVEjvE6VhnQseG40jdDKq3w\nBB/UDj9OtUYAEfbBNR+FeQoSX/RzylhZGY9i045ABH2Pvl84DCFlu9vGfFdC+8Y=\n=QOSi\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/9283a8537d9e4a6b982a395fd83cd52341b58cd3",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OTI4M2E4NTM3ZDllNGE2Yjk4MmEzOTVmZDgzY2Q1MjM0MWI1OGNkMw==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
                    "sha": "ffff42cbaa22ff204cb6e8ac57dea681436e0e25",
                    "url": "https://api.github.com/repos/cython/cython/commits/ffff42cbaa22ff204cb6e8ac57dea681436e0e25"
                }
            ],
            "sha": "9283a8537d9e4a6b982a395fd83cd52341b58cd3",
            "url": "https://api.github.com/repos/cython/cython/commits/9283a8537d9e4a6b982a395fd83cd52341b58cd3"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/e071f5de4c2e3fda8ad1c2540299c3d1a238f7c5/comments",
            "commit": {
                "author": {
                    "date": "2021-07-20T07:01:47Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-20T08:02:51Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fixed indentation and some review comments",
                "tree": {
                    "sha": "73d72b58469cedb5971b6f2caf1f5dfd65f24648",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/73d72b58469cedb5971b6f2caf1f5dfd65f24648"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/e071f5de4c2e3fda8ad1c2540299c3d1a238f7c5",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/e071f5de4c2e3fda8ad1c2540299c3d1a238f7c5",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZTA3MWY1ZGU0YzJlM2ZkYThhZDFjMjU0MDI5OWMzZDFhMjM4ZjdjNQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/9283a8537d9e4a6b982a395fd83cd52341b58cd3",
                    "sha": "9283a8537d9e4a6b982a395fd83cd52341b58cd3",
                    "url": "https://api.github.com/repos/cython/cython/commits/9283a8537d9e4a6b982a395fd83cd52341b58cd3"
                }
            ],
            "sha": "e071f5de4c2e3fda8ad1c2540299c3d1a238f7c5",
            "url": "https://api.github.com/repos/cython/cython/commits/e071f5de4c2e3fda8ad1c2540299c3d1a238f7c5"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/adab594e1314b4fdb33b6fb162cf0a1d61a0ad9d/comments",
            "commit": {
                "author": {
                    "date": "2021-07-20T07:53:54Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-20T08:02:54Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Validation of dataclass fields keyword argument",
                "tree": {
                    "sha": "7649c3a6f3f136fd26e16bc980904200959e9acc",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/7649c3a6f3f136fd26e16bc980904200959e9acc"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/adab594e1314b4fdb33b6fb162cf0a1d61a0ad9d",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/adab594e1314b4fdb33b6fb162cf0a1d61a0ad9d",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YWRhYjU5NGUxMzE0YjRmZGIzM2I2ZmIxNjJjZjBhMWQ2MWEwYWQ5ZA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/e071f5de4c2e3fda8ad1c2540299c3d1a238f7c5",
                    "sha": "e071f5de4c2e3fda8ad1c2540299c3d1a238f7c5",
                    "url": "https://api.github.com/repos/cython/cython/commits/e071f5de4c2e3fda8ad1c2540299c3d1a238f7c5"
                }
            ],
            "sha": "adab594e1314b4fdb33b6fb162cf0a1d61a0ad9d",
            "url": "https://api.github.com/repos/cython/cython/commits/adab594e1314b4fdb33b6fb162cf0a1d61a0ad9d"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/1ee3580ac47f5564083fecfacc3c5e0cdcf14aa4/comments",
            "commit": {
                "author": {
                    "date": "2021-07-20T08:05:02Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-20T08:05:02Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'master' into xxx",
                "tree": {
                    "sha": "9ff92d84076330fb15b5b78c339097821d0a02ac",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/9ff92d84076330fb15b5b78c339097821d0a02ac"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/1ee3580ac47f5564083fecfacc3c5e0cdcf14aa4",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/1ee3580ac47f5564083fecfacc3c5e0cdcf14aa4",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MWVlMzU4MGFjNDdmNTU2NDA4M2ZlY2ZhY2MzYzVlMGNkY2YxNGFhNA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/adab594e1314b4fdb33b6fb162cf0a1d61a0ad9d",
                    "sha": "adab594e1314b4fdb33b6fb162cf0a1d61a0ad9d",
                    "url": "https://api.github.com/repos/cython/cython/commits/adab594e1314b4fdb33b6fb162cf0a1d61a0ad9d"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/8552e3d3ffe9fe4f3f8dab82119ed839990dadda",
                    "sha": "8552e3d3ffe9fe4f3f8dab82119ed839990dadda",
                    "url": "https://api.github.com/repos/cython/cython/commits/8552e3d3ffe9fe4f3f8dab82119ed839990dadda"
                }
            ],
            "sha": "1ee3580ac47f5564083fecfacc3c5e0cdcf14aa4",
            "url": "https://api.github.com/repos/cython/cython/commits/1ee3580ac47f5564083fecfacc3c5e0cdcf14aa4"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/9612788cb327c91c2e34f383c6f349cbac1f6eea/comments",
            "commit": {
                "author": {
                    "date": "2021-07-20T08:06:34Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-20T08:06:34Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Corrected version in CHANGES.txt\n\n(probably shouldn't have added this...)",
                "tree": {
                    "sha": "545fe9ac90c588ed5e2c1439685fd2a08d2805ff",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/545fe9ac90c588ed5e2c1439685fd2a08d2805ff"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/9612788cb327c91c2e34f383c6f349cbac1f6eea",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/9612788cb327c91c2e34f383c6f349cbac1f6eea",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OTYxMjc4OGNiMzI3YzkxYzJlMzRmMzgzYzZmMzQ5Y2JhYzFmNmVlYQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/1ee3580ac47f5564083fecfacc3c5e0cdcf14aa4",
                    "sha": "1ee3580ac47f5564083fecfacc3c5e0cdcf14aa4",
                    "url": "https://api.github.com/repos/cython/cython/commits/1ee3580ac47f5564083fecfacc3c5e0cdcf14aa4"
                }
            ],
            "sha": "9612788cb327c91c2e34f383c6f349cbac1f6eea",
            "url": "https://api.github.com/repos/cython/cython/commits/9612788cb327c91c2e34f383c6f349cbac1f6eea"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/8698bbfbf2ec09f95d769906f744fec0572d05e2/comments",
            "commit": {
                "author": {
                    "date": "2021-07-20T16:42:57Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-20T16:42:57Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Mainly comments about CPython implementation",
                "tree": {
                    "sha": "112767d1fff46f1cabcf177859dc2a3bf0051382",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/112767d1fff46f1cabcf177859dc2a3bf0051382"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/8698bbfbf2ec09f95d769906f744fec0572d05e2",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/8698bbfbf2ec09f95d769906f744fec0572d05e2",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ODY5OGJiZmJmMmVjMDlmOTVkNzY5OTA2Zjc0NGZlYzA1NzJkMDVlMg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/9612788cb327c91c2e34f383c6f349cbac1f6eea",
                    "sha": "9612788cb327c91c2e34f383c6f349cbac1f6eea",
                    "url": "https://api.github.com/repos/cython/cython/commits/9612788cb327c91c2e34f383c6f349cbac1f6eea"
                }
            ],
            "sha": "8698bbfbf2ec09f95d769906f744fec0572d05e2",
            "url": "https://api.github.com/repos/cython/cython/commits/8698bbfbf2ec09f95d769906f744fec0572d05e2"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/4ded017c70987620d7a93c3ef9f453b2f0bda8d6/comments",
            "commit": {
                "author": {
                    "date": "2021-07-20T16:46:20Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-20T16:46:20Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "614b55ed0cdb6b2303a940cb9cafa7d6ff37bdd7",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/614b55ed0cdb6b2303a940cb9cafa7d6ff37bdd7"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/4ded017c70987620d7a93c3ef9f453b2f0bda8d6",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/4ded017c70987620d7a93c3ef9f453b2f0bda8d6",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NGRlZDAxN2M3MDk4NzYyMGQ3YTkzYzNlZjlmNDUzYjJmMGJkYThkNg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/8698bbfbf2ec09f95d769906f744fec0572d05e2",
                    "sha": "8698bbfbf2ec09f95d769906f744fec0572d05e2",
                    "url": "https://api.github.com/repos/cython/cython/commits/8698bbfbf2ec09f95d769906f744fec0572d05e2"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/d833d432e56937f488d2d1f8b9f5ca8eebed4a21",
                    "sha": "d833d432e56937f488d2d1f8b9f5ca8eebed4a21",
                    "url": "https://api.github.com/repos/cython/cython/commits/d833d432e56937f488d2d1f8b9f5ca8eebed4a21"
                }
            ],
            "sha": "4ded017c70987620d7a93c3ef9f453b2f0bda8d6",
            "url": "https://api.github.com/repos/cython/cython/commits/4ded017c70987620d7a93c3ef9f453b2f0bda8d6"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/bc9e9dfa6c3c81f5fa507772674f0f81405a8b38/comments",
            "commit": {
                "author": {
                    "date": "2021-07-20T17:25:00Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-20T17:25:00Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Remove getattr",
                "tree": {
                    "sha": "0cc8a492e17da950a5e97939b56429b73caed15b",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/0cc8a492e17da950a5e97939b56429b73caed15b"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/bc9e9dfa6c3c81f5fa507772674f0f81405a8b38",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/bc9e9dfa6c3c81f5fa507772674f0f81405a8b38",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YmM5ZTlkZmE2YzNjODFmNWZhNTA3NzcyNjc0ZjBmODE0MDVhOGIzOA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/4ded017c70987620d7a93c3ef9f453b2f0bda8d6",
                    "sha": "4ded017c70987620d7a93c3ef9f453b2f0bda8d6",
                    "url": "https://api.github.com/repos/cython/cython/commits/4ded017c70987620d7a93c3ef9f453b2f0bda8d6"
                }
            ],
            "sha": "bc9e9dfa6c3c81f5fa507772674f0f81405a8b38",
            "url": "https://api.github.com/repos/cython/cython/commits/bc9e9dfa6c3c81f5fa507772674f0f81405a8b38"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/6cb0582a3b8f2f54ca503f0dfd2c5c0191fbaeb6/comments",
            "commit": {
                "author": {
                    "date": "2021-07-20T20:59:58Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-20T20:59:58Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Kill stray pdb",
                "tree": {
                    "sha": "ccfaa33b66d1132a035bf9b74d24ab9258681735",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/ccfaa33b66d1132a035bf9b74d24ab9258681735"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/6cb0582a3b8f2f54ca503f0dfd2c5c0191fbaeb6",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/6cb0582a3b8f2f54ca503f0dfd2c5c0191fbaeb6",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6NmNiMDU4MmEzYjhmMmY1NGNhNTAzZjBkZmQyYzVjMDE5MWZiYWViNg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/bc9e9dfa6c3c81f5fa507772674f0f81405a8b38",
                    "sha": "bc9e9dfa6c3c81f5fa507772674f0f81405a8b38",
                    "url": "https://api.github.com/repos/cython/cython/commits/bc9e9dfa6c3c81f5fa507772674f0f81405a8b38"
                }
            ],
            "sha": "6cb0582a3b8f2f54ca503f0dfd2c5c0191fbaeb6",
            "url": "https://api.github.com/repos/cython/cython/commits/6cb0582a3b8f2f54ca503f0dfd2c5c0191fbaeb6"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/bf075c02ee01e1ddd1c30e26530cc46edff0bc15/comments",
            "commit": {
                "author": {
                    "date": "2021-07-21T06:48:06Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-21T06:48:06Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "More changes from review",
                "tree": {
                    "sha": "d677492a69f2905ab5770c6902d86633365a6034",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/d677492a69f2905ab5770c6902d86633365a6034"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/bf075c02ee01e1ddd1c30e26530cc46edff0bc15",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/bf075c02ee01e1ddd1c30e26530cc46edff0bc15",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6YmYwNzVjMDJlZTAxZTFkZGQxYzMwZTI2NTMwY2M0NmVkZmYwYmMxNQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/6cb0582a3b8f2f54ca503f0dfd2c5c0191fbaeb6",
                    "sha": "6cb0582a3b8f2f54ca503f0dfd2c5c0191fbaeb6",
                    "url": "https://api.github.com/repos/cython/cython/commits/6cb0582a3b8f2f54ca503f0dfd2c5c0191fbaeb6"
                }
            ],
            "sha": "bf075c02ee01e1ddd1c30e26530cc46edff0bc15",
            "url": "https://api.github.com/repos/cython/cython/commits/bf075c02ee01e1ddd1c30e26530cc46edff0bc15"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/9da9b10fdc655e806ae7a2dfea21a81e75900598/comments",
            "commit": {
                "author": {
                    "date": "2021-07-21T07:07:00Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-07-21T07:07:00Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "A few small formatting changes",
                "tree": {
                    "sha": "da96de17090e24f232dc010cb2ffd1cbbd870003",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/da96de17090e24f232dc010cb2ffd1cbbd870003"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/9da9b10fdc655e806ae7a2dfea21a81e75900598",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/9da9b10fdc655e806ae7a2dfea21a81e75900598",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OWRhOWIxMGZkYzY1NWU4MDZhZTdhMmRmZWEyMWE4MWU3NTkwMDU5OA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/bf075c02ee01e1ddd1c30e26530cc46edff0bc15",
                    "sha": "bf075c02ee01e1ddd1c30e26530cc46edff0bc15",
                    "url": "https://api.github.com/repos/cython/cython/commits/bf075c02ee01e1ddd1c30e26530cc46edff0bc15"
                }
            ],
            "sha": "9da9b10fdc655e806ae7a2dfea21a81e75900598",
            "url": "https://api.github.com/repos/cython/cython/commits/9da9b10fdc655e806ae7a2dfea21a81e75900598"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/967c3b61446eeba4df8871f5001d322cb4e0a243/comments",
            "commit": {
                "author": {
                    "date": "2021-08-05T21:02:23Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-08-05T21:02:23Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Small formatting updates and clarifying comments",
                "tree": {
                    "sha": "243b428ee98a2f37aacdc738d658660648e9de61",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/243b428ee98a2f37aacdc738d658660648e9de61"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/967c3b61446eeba4df8871f5001d322cb4e0a243",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/967c3b61446eeba4df8871f5001d322cb4e0a243",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OTY3YzNiNjE0NDZlZWJhNGRmODg3MWY1MDAxZDMyMmNiNGUwYTI0Mw==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/9da9b10fdc655e806ae7a2dfea21a81e75900598",
                    "sha": "9da9b10fdc655e806ae7a2dfea21a81e75900598",
                    "url": "https://api.github.com/repos/cython/cython/commits/9da9b10fdc655e806ae7a2dfea21a81e75900598"
                }
            ],
            "sha": "967c3b61446eeba4df8871f5001d322cb4e0a243",
            "url": "https://api.github.com/repos/cython/cython/commits/967c3b61446eeba4df8871f5001d322cb4e0a243"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/2188079f231cd25e81e0b96bffc4efdc77d80727/comments",
            "commit": {
                "author": {
                    "date": "2021-08-06T18:04:26Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-08-06T18:04:26Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Apply suggestions from code review\n\nCo-authored-by: Bluenix <bluenixdev@gmail.com>",
                "tree": {
                    "sha": "2240e090d2f8642f1b2dbe450b185f472eec9f22",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/2240e090d2f8642f1b2dbe450b185f472eec9f22"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/2188079f231cd25e81e0b96bffc4efdc77d80727",
                "verification": {
                    "payload": "tree 2240e090d2f8642f1b2dbe450b185f472eec9f22\nparent 967c3b61446eeba4df8871f5001d322cb4e0a243\nauthor da-woods <dw-git@d-woods.co.uk> 1628273066 +0100\ncommitter GitHub <noreply@github.com> 1628273066 +0100\n\nApply suggestions from code review\n\nCo-authored-by: Bluenix <bluenixdev@gmail.com>",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhDXmqCRBK7hj4Ov3rIwAAc04IABvdLpxHMYkJKiNRL2j0KiDe\n+KKMkQf09V4BAobTpAOsDDVWg1RnCq6KtWSdrftDTtvduqdo++3O/GfOJGDjEhZY\nuunPFBOHM+dGnnkCGDol5nLgGUa5/KFg2uQ/OSBeM9JQ7trO0mHdt8L4AquUDYKo\nI2o1zJOwdjpxt2ci5gM3YRUybWlzkX1+3RI9XcON9E+WIiQO3Vtdmw/P0UUFD0ZL\nuxBdUvjHftXAHM5DU7tZqFuruzlidWq5FGN++gCpmVRktev5toa6uhXwgg+aamzQ\nEVSfwj21ZQao/45w8zRefDYQlKOX6Ne0EO5FuPvFH447YtgEq8pvbedmikJFC8Y=\n=Ozbx\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/2188079f231cd25e81e0b96bffc4efdc77d80727",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MjE4ODA3OWYyMzFjZDI1ZTgxZTBiOTZiZmZjNGVmZGM3N2Q4MDcyNw==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/967c3b61446eeba4df8871f5001d322cb4e0a243",
                    "sha": "967c3b61446eeba4df8871f5001d322cb4e0a243",
                    "url": "https://api.github.com/repos/cython/cython/commits/967c3b61446eeba4df8871f5001d322cb4e0a243"
                }
            ],
            "sha": "2188079f231cd25e81e0b96bffc4efdc77d80727",
            "url": "https://api.github.com/repos/cython/cython/commits/2188079f231cd25e81e0b96bffc4efdc77d80727"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/0245526b349e313858e4faf4e3099fe4095917c2/comments",
            "commit": {
                "author": {
                    "date": "2021-08-06T18:07:29Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-08-06T18:07:29Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "More suggestions taken from review",
                "tree": {
                    "sha": "52b80136ed5b899b652382a2c5a5c9c04d773ae6",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/52b80136ed5b899b652382a2c5a5c9c04d773ae6"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/0245526b349e313858e4faf4e3099fe4095917c2",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/0245526b349e313858e4faf4e3099fe4095917c2",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MDI0NTUyNmIzNDllMzEzODU4ZTRmYWY0ZTMwOTlmZTQwOTU5MTdjMg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/2188079f231cd25e81e0b96bffc4efdc77d80727",
                    "sha": "2188079f231cd25e81e0b96bffc4efdc77d80727",
                    "url": "https://api.github.com/repos/cython/cython/commits/2188079f231cd25e81e0b96bffc4efdc77d80727"
                }
            ],
            "sha": "0245526b349e313858e4faf4e3099fe4095917c2",
            "url": "https://api.github.com/repos/cython/cython/commits/0245526b349e313858e4faf4e3099fe4095917c2"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/f8ceecf5d6a8a59ea3e0c71b6603f10ab936a568/comments",
            "commit": {
                "author": {
                    "date": "2021-08-06T19:09:14Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-08-06T19:14:27Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fix tests and update error messages to match CPython",
                "tree": {
                    "sha": "0b5f69e54b20a05cf8138a29dbdee792e8ab4553",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/0b5f69e54b20a05cf8138a29dbdee792e8ab4553"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/f8ceecf5d6a8a59ea3e0c71b6603f10ab936a568",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/f8ceecf5d6a8a59ea3e0c71b6603f10ab936a568",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZjhjZWVjZjVkNmE4YTU5ZWEzZTBjNzFiNjYwM2YxMGFiOTM2YTU2OA==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/0245526b349e313858e4faf4e3099fe4095917c2",
                    "sha": "0245526b349e313858e4faf4e3099fe4095917c2",
                    "url": "https://api.github.com/repos/cython/cython/commits/0245526b349e313858e4faf4e3099fe4095917c2"
                }
            ],
            "sha": "f8ceecf5d6a8a59ea3e0c71b6603f10ab936a568",
            "url": "https://api.github.com/repos/cython/cython/commits/f8ceecf5d6a8a59ea3e0c71b6603f10ab936a568"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/f1bb70402ec523316c64574b89d9dfbe522a636b/comments",
            "commit": {
                "author": {
                    "date": "2021-08-06T19:23:03Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-08-06T19:23:03Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Updated documentation\n\nto make it clear that cython dataclasses must be extension types",
                "tree": {
                    "sha": "b34441d88a30f3189c47ed85871bb87b589ce266",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/b34441d88a30f3189c47ed85871bb87b589ce266"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/f1bb70402ec523316c64574b89d9dfbe522a636b",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/f1bb70402ec523316c64574b89d9dfbe522a636b",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZjFiYjcwNDAyZWM1MjMzMTZjNjQ1NzRiODlkOWRmYmU1MjJhNjM2Yg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/f8ceecf5d6a8a59ea3e0c71b6603f10ab936a568",
                    "sha": "f8ceecf5d6a8a59ea3e0c71b6603f10ab936a568",
                    "url": "https://api.github.com/repos/cython/cython/commits/f8ceecf5d6a8a59ea3e0c71b6603f10ab936a568"
                }
            ],
            "sha": "f1bb70402ec523316c64574b89d9dfbe522a636b",
            "url": "https://api.github.com/repos/cython/cython/commits/f1bb70402ec523316c64574b89d9dfbe522a636b"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/8b6c998c56013dab6178f795a5adbfbb34955f4b/comments",
            "commit": {
                "author": {
                    "date": "2021-08-10T21:37:28Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-08-10T21:37:28Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "4063240d7b088ed91b3c1c134617d1c034778931",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/4063240d7b088ed91b3c1c134617d1c034778931"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/8b6c998c56013dab6178f795a5adbfbb34955f4b",
                "verification": {
                    "payload": "tree 4063240d7b088ed91b3c1c134617d1c034778931\nparent f1bb70402ec523316c64574b89d9dfbe522a636b\nparent 8af0271186cc642436306274564986888d5e64c8\nauthor da-woods <dw-git@d-woods.co.uk> 1628631448 +0100\ncommitter GitHub <noreply@github.com> 1628631448 +0100\n\nMerge branch 'master' into dataclass",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhEvGYCRBK7hj4Ov3rIwAA19sIAJsGghavanNQjp06SakS4WrF\ntJIX0HI41NQN2ibj5hmUQKKFKVvAMmJFcy2B8PuNpSp9pFHeZ5y6vl0tGNLEVoeb\nde7+TYtt7DVlmcuDLU2UGLn6cy7nDjQdI2d41m4ug4vVDXvpcQqWCElAzjt1aGi1\n5629OcrlaL4II564pHia82NbmP0jJh5prvn5oteOo3Z9Kmh8SiIDEGtmzS0MF4J5\nyvNC3rc8iNCwYTR/kLvRb6aG97mfNQTraOr3Z21+8PoIKZwqNYQT7AXlq2t5S86X\n41SvlDs+0vzTW4a7hWC5y++kdqxPEahS+YuNgK11RswEc7ZupAAA1eKezlkx5Mg=\n=Y9cp\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6OGI2Yzk5OGM1NjAxM2RhYjYxNzhmNzk1YTVhZGJmYmIzNDk1NWY0Yg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/f1bb70402ec523316c64574b89d9dfbe522a636b",
                    "sha": "f1bb70402ec523316c64574b89d9dfbe522a636b",
                    "url": "https://api.github.com/repos/cython/cython/commits/f1bb70402ec523316c64574b89d9dfbe522a636b"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/8af0271186cc642436306274564986888d5e64c8",
                    "sha": "8af0271186cc642436306274564986888d5e64c8",
                    "url": "https://api.github.com/repos/cython/cython/commits/8af0271186cc642436306274564986888d5e64c8"
                }
            ],
            "sha": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
            "url": "https://api.github.com/repos/cython/cython/commits/8b6c998c56013dab6178f795a5adbfbb34955f4b"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/e32be2cbc663e556b10a8b98551181d2af5a03f1/comments",
            "commit": {
                "author": {
                    "date": "2021-08-16T12:00:47Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-08-16T12:00:47Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Apply formatting suggestions from review\n\nCo-authored-by: Bluenix <bluenixdev@gmail.com>",
                "tree": {
                    "sha": "26938c55294f5c00453c27d5fcadf6f5314181e5",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/26938c55294f5c00453c27d5fcadf6f5314181e5"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/e32be2cbc663e556b10a8b98551181d2af5a03f1",
                "verification": {
                    "payload": "tree 26938c55294f5c00453c27d5fcadf6f5314181e5\nparent 8b6c998c56013dab6178f795a5adbfbb34955f4b\nauthor da-woods <dw-git@d-woods.co.uk> 1629115247 +0100\ncommitter GitHub <noreply@github.com> 1629115247 +0100\n\nApply formatting suggestions from review\n\nCo-authored-by: Bluenix <bluenixdev@gmail.com>",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhGlNvCRBK7hj4Ov3rIwAAul8IAEL+jiU7w+wgQv4Zn3kcUGtG\nhlnzDBpyn3q2bYhkQN+FpVqX5+Z9ukWeWqZaOJJMrCAOn+wJ4hVh4TvXEW8yNLIg\nHX5zeE03Yd52o2zR4o3Muv9lBdsU9FTaD1BtEgvKhWs/qhz4s5QzlYXMlqByPmjz\neLKi+TEvL23MYDSvYeY/VBHl//rzI6sUGHgqkx9sE4fkhaqr8HxZ9mRexk85X1tm\n0f+H6XqgSxxBz9nlvUtakQ9CDzrachAIz74Nbthq/3hL/dxagemMJVAqilijb8Ex\nGiYHwQDmkmX3XL1OMKoezNCNW5lUrvfMdxdD3soSbX3nUiTLXISRDmEt73ShViw=\n=yi8g\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/e32be2cbc663e556b10a8b98551181d2af5a03f1",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6ZTMyYmUyY2JjNjYzZTU1NmIxMGE4Yjk4NTUxMTgxZDJhZjVhMDNmMQ==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/8b6c998c56013dab6178f795a5adbfbb34955f4b",
                    "sha": "8b6c998c56013dab6178f795a5adbfbb34955f4b",
                    "url": "https://api.github.com/repos/cython/cython/commits/8b6c998c56013dab6178f795a5adbfbb34955f4b"
                }
            ],
            "sha": "e32be2cbc663e556b10a8b98551181d2af5a03f1",
            "url": "https://api.github.com/repos/cython/cython/commits/e32be2cbc663e556b10a8b98551181d2af5a03f1"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/04cf437fe48333937646cbda04c45c640ae7dd5f/comments",
            "commit": {
                "author": {
                    "date": "2021-08-16T12:11:26Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-08-16T12:34:24Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Change some naming and refactor a loop",
                "tree": {
                    "sha": "cc446e179dadbe1dd3ba156a5202370b6cf5f0ad",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/cc446e179dadbe1dd3ba156a5202370b6cf5f0ad"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/04cf437fe48333937646cbda04c45c640ae7dd5f",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/04cf437fe48333937646cbda04c45c640ae7dd5f",
            "node_id": "MDY6Q29tbWl0MzUzMjE5Njc6MDRjZjQzN2ZlNDgzMzM5Mzc2NDZjYmRhMDRjNDVjNjQwYWU3ZGQ1Zg==",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/e32be2cbc663e556b10a8b98551181d2af5a03f1",
                    "sha": "e32be2cbc663e556b10a8b98551181d2af5a03f1",
                    "url": "https://api.github.com/repos/cython/cython/commits/e32be2cbc663e556b10a8b98551181d2af5a03f1"
                }
            ],
            "sha": "04cf437fe48333937646cbda04c45c640ae7dd5f",
            "url": "https://api.github.com/repos/cython/cython/commits/04cf437fe48333937646cbda04c45c640ae7dd5f"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/bc469d6544c23e8e55b04cf6c305016ca5329a04/comments",
            "commit": {
                "author": {
                    "date": "2021-10-23T12:54:58Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-10-23T12:54:58Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "Merge branch 'master' into dataclass",
                "tree": {
                    "sha": "4c9ae1929206df529d32bdb5a00c23f6ca1cbbff",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/4c9ae1929206df529d32bdb5a00c23f6ca1cbbff"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/bc469d6544c23e8e55b04cf6c305016ca5329a04",
                "verification": {
                    "payload": "tree 4c9ae1929206df529d32bdb5a00c23f6ca1cbbff\nparent 04cf437fe48333937646cbda04c45c640ae7dd5f\nparent c25c87d71107e634162302f7f61a119eff539a48\nauthor da-woods <dw-git@d-woods.co.uk> 1634993698 +0100\ncommitter GitHub <noreply@github.com> 1634993698 +0100\n\nMerge branch 'master' into dataclass",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhdAYiCRBK7hj4Ov3rIwAA8NcIAF/KrnWRyc0/1eWpj/+NmKG4\nmjZFr4P578kR/AkePrmtMY7sUwaYNXY8ogAjAtfzvKF59L2AyUrX9z7VWWwfeRkI\nE7JU8wwS9OH4px9Td4kbMhNQ563u+Ba6SF3ZyaPZ3CAk46HeKvm3X0teEt66fh1t\nmAcfGtPwbUmHDeFy4fcdCTA8uzMTy8dJT/KQGM6ByHkTn5QsJb+bsKubafi064hc\nSoJ1kE+qg1ooESKIZ/SGKECjH1TIIT9ZOovqaC6CeFLZDVk/OnDK9FTvDIhv1Six\n+farnvvZPpflyKHLTHLhMcSAITu7D+sYkI0rpxfUh1grypsmfHr6Vao+HfG1qpI=\n=oWSs\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/bc469d6544c23e8e55b04cf6c305016ca5329a04",
            "node_id": "C_kwDOAhr4b9oAKGJjNDY5ZDY1NDRjMjNlOGU1NWIwNGNmNmMzMDUwMTZjYTUzMjlhMDQ",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/04cf437fe48333937646cbda04c45c640ae7dd5f",
                    "sha": "04cf437fe48333937646cbda04c45c640ae7dd5f",
                    "url": "https://api.github.com/repos/cython/cython/commits/04cf437fe48333937646cbda04c45c640ae7dd5f"
                },
                {
                    "html_url": "https://github.com/cython/cython/commit/c25c87d71107e634162302f7f61a119eff539a48",
                    "sha": "c25c87d71107e634162302f7f61a119eff539a48",
                    "url": "https://api.github.com/repos/cython/cython/commits/c25c87d71107e634162302f7f61a119eff539a48"
                }
            ],
            "sha": "bc469d6544c23e8e55b04cf6c305016ca5329a04",
            "url": "https://api.github.com/repos/cython/cython/commits/bc469d6544c23e8e55b04cf6c305016ca5329a04"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/a9b6b8583d091c324d23cd69e2de1176e97851e1/comments",
            "commit": {
                "author": {
                    "date": "2021-12-05T17:22:26Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-12-05T17:22:26Z",
                    "email": "noreply@github.com",
                    "name": "GitHub"
                },
                "message": "MappingProxyType spelling\n\nCo-authored-by: Cosimo Lupo <cosimo@anthrotype.com>",
                "tree": {
                    "sha": "f6aeaba7ad8e092c31d554ab8e49ba551d0c42e6",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/f6aeaba7ad8e092c31d554ab8e49ba551d0c42e6"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/a9b6b8583d091c324d23cd69e2de1176e97851e1",
                "verification": {
                    "payload": "tree f6aeaba7ad8e092c31d554ab8e49ba551d0c42e6\nparent bc469d6544c23e8e55b04cf6c305016ca5329a04\nauthor da-woods <dw-git@d-woods.co.uk> 1638724946 +0000\ncommitter GitHub <noreply@github.com> 1638724946 +0000\n\nMappingProxyType spelling\n\nCo-authored-by: Cosimo Lupo <cosimo@anthrotype.com>",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhrPVTCRBK7hj4Ov3rIwAA7BoIAAwmTcY0bP6k+twULWddpW/Y\nktJnN9UwP2VqWup48E0LmOWmGqKit+wNjR5SZwNSzVEeVsQeufYTbQzpVT+R3Hue\nkB9AX0Sbk316h7xb3p+HMuCDq9shduy4qZG08YRWDZ9AqT/p9/+oPagevQDEo1LM\n1A0GZZ+WMJupsSrunkdj1tUVwKFAPZs2/MhOWbvOtRN5/Qs5kRuhU53yFIUsn1we\no200eanNLcrZrr5TNLSnYbW1pNwXnHy3Y5FYIajJIu3p584+JLZRmBufywag5JW6\nhw6ZVmY3gqYCSRV4Vxwx9COuIxDtFvNhQkI/BkpuGrMAIT9+eBPGBF5YSqttS2o=\n=P10W\n-----END PGP SIGNATURE-----\n",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
                "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
                "followers_url": "https://api.github.com/users/web-flow/followers",
                "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
                "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/web-flow",
                "id": 19864447,
                "login": "web-flow",
                "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
                "organizations_url": "https://api.github.com/users/web-flow/orgs",
                "received_events_url": "https://api.github.com/users/web-flow/received_events",
                "repos_url": "https://api.github.com/users/web-flow/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/web-flow"
            },
            "html_url": "https://github.com/cython/cython/commit/a9b6b8583d091c324d23cd69e2de1176e97851e1",
            "node_id": "C_kwDOAhr4b9oAKGE5YjZiODU4M2QwOTFjMzI0ZDIzY2Q2OWUyZGUxMTc2ZTk3ODUxZTE",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/bc469d6544c23e8e55b04cf6c305016ca5329a04",
                    "sha": "bc469d6544c23e8e55b04cf6c305016ca5329a04",
                    "url": "https://api.github.com/repos/cython/cython/commits/bc469d6544c23e8e55b04cf6c305016ca5329a04"
                }
            ],
            "sha": "a9b6b8583d091c324d23cd69e2de1176e97851e1",
            "url": "https://api.github.com/repos/cython/cython/commits/a9b6b8583d091c324d23cd69e2de1176e97851e1"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/4663f0a1b1c25493988c94c3af06f82a7cd1475f/comments",
            "commit": {
                "author": {
                    "date": "2021-12-05T17:26:46Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-12-05T17:26:46Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Remove change to \"CHANGES.rst\"\n\nit's difficult to keep up to date",
                "tree": {
                    "sha": "7a138d370e4f0358a7d15624da3ba2bb8469f18c",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/7a138d370e4f0358a7d15624da3ba2bb8469f18c"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/4663f0a1b1c25493988c94c3af06f82a7cd1475f",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/4663f0a1b1c25493988c94c3af06f82a7cd1475f",
            "node_id": "C_kwDOAhr4b9oAKDQ2NjNmMGExYjFjMjU0OTM5ODhjOTRjM2FmMDZmODJhN2NkMTQ3NWY",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/a9b6b8583d091c324d23cd69e2de1176e97851e1",
                    "sha": "a9b6b8583d091c324d23cd69e2de1176e97851e1",
                    "url": "https://api.github.com/repos/cython/cython/commits/a9b6b8583d091c324d23cd69e2de1176e97851e1"
                }
            ],
            "sha": "4663f0a1b1c25493988c94c3af06f82a7cd1475f",
            "url": "https://api.github.com/repos/cython/cython/commits/4663f0a1b1c25493988c94c3af06f82a7cd1475f"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/4ad3a87b732037070bdc7d723cac2aee3aeb5a4f/comments",
            "commit": {
                "author": {
                    "date": "2021-12-05T18:12:38Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-12-05T18:12:38Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Set _field_type from dataclasses module\n\nimproves introspection",
                "tree": {
                    "sha": "1886ebaf41ecabb4e155c3929f9ad9d76014a79c",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/1886ebaf41ecabb4e155c3929f9ad9d76014a79c"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/4ad3a87b732037070bdc7d723cac2aee3aeb5a4f",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/4ad3a87b732037070bdc7d723cac2aee3aeb5a4f",
            "node_id": "C_kwDOAhr4b9oAKDRhZDNhODdiNzMyMDM3MDcwYmRjN2Q3MjNjYWMyYWVlM2FlYjVhNGY",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/4663f0a1b1c25493988c94c3af06f82a7cd1475f",
                    "sha": "4663f0a1b1c25493988c94c3af06f82a7cd1475f",
                    "url": "https://api.github.com/repos/cython/cython/commits/4663f0a1b1c25493988c94c3af06f82a7cd1475f"
                }
            ],
            "sha": "4ad3a87b732037070bdc7d723cac2aee3aeb5a4f",
            "url": "https://api.github.com/repos/cython/cython/commits/4ad3a87b732037070bdc7d723cac2aee3aeb5a4f"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/488283bd46034f88f768725b248466d668f4b819/comments",
            "commit": {
                "author": {
                    "date": "2021-12-05T18:19:28Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-12-05T18:19:28Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Move AttributeNodes inside the loop\n\nI'm nervous about sharing nodes in multiple places",
                "tree": {
                    "sha": "515b33cbefe13e72e48619e28e166a4c3c33a124",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/515b33cbefe13e72e48619e28e166a4c3c33a124"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/488283bd46034f88f768725b248466d668f4b819",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/488283bd46034f88f768725b248466d668f4b819",
            "node_id": "C_kwDOAhr4b9oAKDQ4ODI4M2JkNDYwMzRmODhmNzY4NzI1YjI0ODQ2NmQ2NjhmNGI4MTk",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/4ad3a87b732037070bdc7d723cac2aee3aeb5a4f",
                    "sha": "4ad3a87b732037070bdc7d723cac2aee3aeb5a4f",
                    "url": "https://api.github.com/repos/cython/cython/commits/4ad3a87b732037070bdc7d723cac2aee3aeb5a4f"
                }
            ],
            "sha": "488283bd46034f88f768725b248466d668f4b819",
            "url": "https://api.github.com/repos/cython/cython/commits/488283bd46034f88f768725b248466d668f4b819"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/4bd240299657d1ba2d71caf3fc8319d5ed332937/comments",
            "commit": {
                "author": {
                    "date": "2021-12-06T18:46:40Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-12-06T18:46:40Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Fix generated __repr__",
                "tree": {
                    "sha": "ba611efb6ac3c7db64f7320e433de3074fa3f2dd",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/ba611efb6ac3c7db64f7320e433de3074fa3f2dd"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/4bd240299657d1ba2d71caf3fc8319d5ed332937",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/4bd240299657d1ba2d71caf3fc8319d5ed332937",
            "node_id": "C_kwDOAhr4b9oAKDRiZDI0MDI5OTY1N2QxYmEyZDcxY2FmM2ZjODMxOWQ1ZWQzMzI5Mzc",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/488283bd46034f88f768725b248466d668f4b819",
                    "sha": "488283bd46034f88f768725b248466d668f4b819",
                    "url": "https://api.github.com/repos/cython/cython/commits/488283bd46034f88f768725b248466d668f4b819"
                }
            ],
            "sha": "4bd240299657d1ba2d71caf3fc8319d5ed332937",
            "url": "https://api.github.com/repos/cython/cython/commits/4bd240299657d1ba2d71caf3fc8319d5ed332937"
        },
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "comments_url": "https://api.github.com/repos/cython/cython/commits/a25b746532149f254ca28b4ef1567ea230d967aa/comments",
            "commit": {
                "author": {
                    "date": "2021-12-12T11:42:27Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2021-12-12T11:42:27Z",
                    "email": "dw-git@d-woods.co.uk",
                    "name": "da-woods"
                },
                "message": "Take field.type from annotation",
                "tree": {
                    "sha": "daf32d6d2612cd1a00db900c8266aaedda302540",
                    "url": "https://api.github.com/repos/cython/cython/git/trees/daf32d6d2612cd1a00db900c8266aaedda302540"
                },
                "url": "https://api.github.com/repos/cython/cython/git/commits/a25b746532149f254ca28b4ef1567ea230d967aa",
                "verification": {
                    "payload": null,
                    "reason": "unsigned",
                    "signature": null,
                    "verified": false
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "html_url": "https://github.com/cython/cython/commit/a25b746532149f254ca28b4ef1567ea230d967aa",
            "node_id": "C_kwDOAhr4b9oAKGEyNWI3NDY1MzIxNDlmMjU0Y2EyOGI0ZWYxNTY3ZWEyMzBkOTY3YWE",
            "parents": [
                {
                    "html_url": "https://github.com/cython/cython/commit/4bd240299657d1ba2d71caf3fc8319d5ed332937",
                    "sha": "4bd240299657d1ba2d71caf3fc8319d5ed332937",
                    "url": "https://api.github.com/repos/cython/cython/commits/4bd240299657d1ba2d71caf3fc8319d5ed332937"
                }
            ],
            "sha": "a25b746532149f254ca28b4ef1567ea230d967aa",
            "url": "https://api.github.com/repos/cython/cython/commits/a25b746532149f254ca28b4ef1567ea230d967aa"
        }
    ],
    "commits_url": "https://api.github.com/repos/cython/cython/pulls/3400/commits",
    "created_at": "2020-03-07T22:19:14Z",
    "diff_url": "https://github.com/cython/cython/pull/3400.diff",
    "draft": false,
    "head": {
        "label": "da-woods:dataclass",
        "ref": "dataclass",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/da-woods/cython/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/da-woods/cython/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/da-woods/cython/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/da-woods/cython/branches{/branch}",
            "clone_url": "https://github.com/da-woods/cython.git",
            "collaborators_url": "https://api.github.com/repos/da-woods/cython/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/da-woods/cython/comments{/number}",
            "commits_url": "https://api.github.com/repos/da-woods/cython/commits{/sha}",
            "compare_url": "https://api.github.com/repos/da-woods/cython/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/da-woods/cython/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/da-woods/cython/contributors",
            "created_at": "2015-05-09T08:55:00Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/da-woods/cython/deployments",
            "description": "A Python to C compiler",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/da-woods/cython/downloads",
            "events_url": "https://api.github.com/repos/da-woods/cython/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/da-woods/cython/forks",
            "full_name": "da-woods/cython",
            "git_commits_url": "https://api.github.com/repos/da-woods/cython/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/da-woods/cython/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/da-woods/cython/git/tags{/sha}",
            "git_url": "git://github.com/da-woods/cython.git",
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "http://cython.org",
            "hooks_url": "https://api.github.com/repos/da-woods/cython/hooks",
            "html_url": "https://github.com/da-woods/cython",
            "id": 35321967,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/da-woods/cython/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/da-woods/cython/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/da-woods/cython/issues{/number}",
            "keys_url": "https://api.github.com/repos/da-woods/cython/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/da-woods/cython/labels{/name}",
            "language": "Python",
            "languages_url": "https://api.github.com/repos/da-woods/cython/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/da-woods/cython/merges",
            "milestones_url": "https://api.github.com/repos/da-woods/cython/milestones{/number}",
            "mirror_url": null,
            "name": "cython",
            "node_id": "MDEwOlJlcG9zaXRvcnkzNTMyMTk2Nw==",
            "notifications_url": "https://api.github.com/repos/da-woods/cython/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/da-woods/cython/pulls{/number}",
            "pushed_at": "2021-12-31T14:42:31Z",
            "releases_url": "https://api.github.com/repos/da-woods/cython/releases{/id}",
            "size": 65543,
            "ssh_url": "git@github.com:da-woods/cython.git",
            "stargazers_count": 2,
            "stargazers_url": "https://api.github.com/repos/da-woods/cython/stargazers",
            "statuses_url": "https://api.github.com/repos/da-woods/cython/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/da-woods/cython/subscribers",
            "subscription_url": "https://api.github.com/repos/da-woods/cython/subscription",
            "svn_url": "https://github.com/da-woods/cython",
            "tags_url": "https://api.github.com/repos/da-woods/cython/tags",
            "teams_url": "https://api.github.com/repos/da-woods/cython/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/da-woods/cython/git/trees{/sha}",
            "updated_at": "2021-09-15T16:26:05Z",
            "url": "https://api.github.com/repos/da-woods/cython",
            "visibility": "public",
            "watchers": 2,
            "watchers_count": 2
        },
        "sha": "a25b746532149f254ca28b4ef1567ea230d967aa",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
            "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
            "followers_url": "https://api.github.com/users/da-woods/followers",
            "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
            "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/da-woods",
            "id": 10536947,
            "login": "da-woods",
            "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
            "organizations_url": "https://api.github.com/users/da-woods/orgs",
            "received_events_url": "https://api.github.com/users/da-woods/received_events",
            "repos_url": "https://api.github.com/users/da-woods/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/da-woods"
        }
    },
    "html_url": "https://github.com/cython/cython/pull/3400",
    "id": 385199483,
    "issue_url": "https://api.github.com/repos/cython/cython/issues/3400",
    "labels": [
        {
            "color": "c2e0c6",
            "default": false,
            "description": null,
            "id": 414805463,
            "name": "feature",
            "node_id": "MDU6TGFiZWw0MTQ4MDU0NjM=",
            "url": "https://api.github.com/repos/cython/cython/labels/feature"
        },
        {
            "color": "444444",
            "default": false,
            "description": null,
            "id": 425559948,
            "name": "Cython Language Feature",
            "node_id": "MDU6TGFiZWw0MjU1NTk5NDg=",
            "url": "https://api.github.com/repos/cython/cython/labels/Cython%20Language%20Feature"
        }
    ],
    "locked": false,
    "merge_commit_sha": "74d7d1968cad2a66d653d31572f8a35a516121d3",
    "merged_at": null,
    "milestone": {
        "closed_at": null,
        "closed_issues": 544,
        "created_at": "2018-08-18T06:33:08Z",
        "creator": {
            "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
            "events_url": "https://api.github.com/users/scoder/events{/privacy}",
            "followers_url": "https://api.github.com/users/scoder/followers",
            "following_url": "https://api.github.com/users/scoder/following{/other_user}",
            "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/scoder",
            "id": 491659,
            "login": "scoder",
            "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
            "organizations_url": "https://api.github.com/users/scoder/orgs",
            "received_events_url": "https://api.github.com/users/scoder/received_events",
            "repos_url": "https://api.github.com/users/scoder/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/scoder"
        },
        "description": "Goals:\r\n– New version scheme: 3.x instead of 0.x.\r\n– Change default `language_level` from `2` to `3`.\r\n– Change default for `binding` directive from `False` to `True`.\r\n– Fix some Python compatibility issues (if possible, allowing for breaking changes).\r\n",
        "due_on": null,
        "html_url": "https://github.com/cython/cython/milestone/58",
        "id": 3580387,
        "labels_url": "https://api.github.com/repos/cython/cython/milestones/58/labels",
        "node_id": "MDk6TWlsZXN0b25lMzU4MDM4Nw==",
        "number": 58,
        "open_issues": 33,
        "state": "open",
        "title": "3.0",
        "updated_at": "2022-01-05T16:26:52Z",
        "url": "https://api.github.com/repos/cython/cython/milestones/58"
    },
    "node_id": "MDExOlB1bGxSZXF1ZXN0Mzg1MTk5NDgz",
    "number": 3400,
    "patch_url": "https://github.com/cython/cython/pull/3400.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/cython/cython/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/cython/cython/pulls/3400/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/cython/cython/statuses/a25b746532149f254ca28b4ef1567ea230d967aa",
    "title": "cdef dataclasses",
    "updated_at": "2022-01-05T21:32:11Z",
    "url": "https://api.github.com/repos/cython/cython/pulls/3400",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
        "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
        "followers_url": "https://api.github.com/users/da-woods/followers",
        "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
        "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/da-woods",
        "id": 10536947,
        "login": "da-woods",
        "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
        "organizations_url": "https://api.github.com/users/da-woods/orgs",
        "received_events_url": "https://api.github.com/users/da-woods/received_events",
        "repos_url": "https://api.github.com/users/da-woods/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/da-woods"
    }
}