{
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "NONE",
    "body": "### Is your feature request related to a problem? Please describe.\n\nThis is a follow-up to the issue https://github.com/cython/cython/issues/6676 and discusses optimizations to the function `__Pyx_ParseOptionalKeywords`\n\nBasically I'm trying to optimize item instance creation in particular, but more cases are affected.\n\nI open this issue to have a place for the discussion around this improvement.\n\nBasically here is my current understanding of the topic:\n\n## Two call conventions\nTwo call conventions are [used](https://docs.python.org/3/c-api/call.html).\n- tp_call: a tuple (args) and a dict (kwargs) is passed. `__init__` and `__cinit__` always use this convention.\n- vectorcall: a tuple (args + kwargs values) and a tuple (kwnames keys) is passed. This is the convention used by default (because it is better for speed).\n\n## Parameter validation\nThe callee has some validation to perform.\n\n- If kwargs is a dict it must ensures the keys are unicode (or subclasses). It can be done either by iterating on each key and checking if they are unicode, or calling `PyArg_ValidateKeywordArguments`, which will have a fast path if it finds that the dict knows it only contains unicodes.\n- No validation is needed on kwargs and kwnames for duplicate entries\n- Validation is needed to check the kwargs and kwnames entries do not duplicate a positional parameters (args).\n\nThe current strategy is to validate only if not all keyword arguments are used. In other words, when **kwargs is an argument of the input function, it will always have this validation.\n\n## Parameter association\n\nIn order to associate fast kwargs keys / kwnames, Cython currently relies on interned strings, which are strings which will always get the same PyObject for the same content (subclasses of str excluded). This enables to perform direct equality test on the PyObject pointer. Cython thus iterates over the names to find if one points to the same PyObject.\n\nIn the case where the keyword is not found, using this fast test, a slower path uses string comparison routines. The string size is used, and then comfirmed using a complete string comparison.\n\n## The performance issue with the current approach\n\nIf **kwargs is not used, and assuming the typical call will not have errors, and will use unicode kwarg keys, the matching should be very fast, and duplicate entry validation is skipped.\n\nOn the other hand, when **kwargs is used for the function input, in other words there are keywords in kwnames/kwargs that are not present in the argument list, the current Cython code underperforms because:\n- Duplicate parameter validation is performed, and for each keywords that should end up in **kwargs, multiple tests, up to a complete string comparison are performed against the parameter names.\n- The new kwargs is built from scratch, inserting one by one the keys.\n\nOptimizing **kwargs is important because it is often used for functions such as `__cinit__` and `__init__` when doing subclassing. This directly impacts the speed of item creation.\n\n## How could speed be improved ?\n\nConsidering the case without **kwargs should be pretty good already, let's discuss only the case with **kwargs.\n\nOne key aspect is how to validate fast that there are no duplicated entries.\n\nFor parameter association, the interned string test enables almost always to find an exact match. But since it leads to some false negatives, it cannot be used to exclude duplication. We need instead some strategy that has no false negatives but may have false positives, then completed with an equality check in case of assumed match.\n\nRemains a few options:\n- Using the string size (current Cython strategy if CYTHON_ASSUME_SAFE_SIZE is set)\n- Using the string hash (which seems to be sizeof(void*) for CPython), and is cached for each string.\n- Reverse the loop and instead check for each positional parameter if they are in the keyword list. That's what CPython (getargs.c) seems to be doing. This enables to use the dict API to check the presence of the item.\n\nThe second aspect to improve speed is how to build the **kwargs as fast as possible.\n\nWhen using the vectorcall method (kwnames), there doesn't seem to be another way than just iterating and inserting in a new dict the arguments.\n\nHowever for the tp_call convention (which cover `__init__` and `__cinit__` which may have **kwargs), other alternatives are possible:\n- When **kwargs contains exactly the same keys as what was given for the call (all other arguments were passed in *args), then one could copy it, or pass it as is. I suspect in most cases it could be passed as is, but not all (for instance I suspect `__cinit__` calls share the same **kwargs). Duplicating the dict however should be faster than iterating on the keys are inserting in the new dict, as it has a fast path.\nIn https://github.com/cython/cython/issues/6676 I experimented exactly that\n```cpp\n    if (!*first_kw_arg && !kwds_is_tuple && kwds && kwds2) {\n        // Check dict is unicode\n        if (!PyArg_ValidateKeywordArguments(kwds)) goto bad; // Python already sets the error\n        // Check for duplications\n        name = argnames;\n        while (*name) {\n            int check = PyDict_Contains(kwds, **name);\n            if (check < 0 && unlikely(PyErr_Occurred())) goto bad;\n            if (check == 1) goto arg_passed_twice;\n            name++;\n        }\n        // Fast copy\n        if (PyDict_Update(kwds2, kwds) < 0)\n           goto bad;\n        return 0;\n    }\n```\n\nThis code, to be inserted at the top of `__Pyx_ParseOptionalKeywords` gave me visible speedups in item creation on some of my benchmarks for my library [DearCyGui](https://github.com/DearCyGui/DearCyGui/). I can get up to +40% speed when creating in a loop `dcg.Button` with 10 keyword arguments.\n\n- When some values of positional arguments are missing, instead of iterating on the kwargs, one could use `PyDict_GetItem` to fetch them, then (after duplicating if needed the dict) remove them. Both operations can actually be done in one call using `PyDict_Pop`.\n\nHowever this strategy might not be always be the best. If there are many positional arguments to find (and few extra keywords), iterating on the keywords, and building the new dict with remaining keywords might prove a better strategy.\n\n\n## My current position\n\nKeep the case without **kwargs as is. Else\n\n### vectorcall convention\n\n- Argument matching: same as now\n- Validation: I would suggest to use the hash instead of the string length. To skip calls to CPython, it would be more efficient to compute the hashes when the module is imported, and store them. Similarly the loop can be modified to retrieve once the hash from CPython for each kwnames. While I believe hash would be more reliable, these same optimizations can be done too for length, and thus skip repeated function calls.\n- Building the kwargs: same as now\n\n### tp_call convention\n\nWhen all positional arguments are already filled (no keyword to remove):\n- Argument matching: None\n- Validation: if many enough keywords relative to the number of positional arguments, use `PyDict_Contains` for each positional argument. If few keywords relative to the number of positional arguments, `PyDict_iter` + checking hashes of each positional argument, doing complete equality check if needed.\n- Building the kwargs: `PyDict_Update`. When the target dict is new (which is the case here), a quick path is implemented (similar to `PyDict_Copy`).\n\nWhen there are few positional arguments to retrieve among the keywords, and many keywords:\n- Argument matching: `PyDict_Pop` (on duplicated kwargs if needed)\n- Validation: depending on the number of positional parameters, same situation as above\n- Building the kwargs: the resulting dict after the `PyDict_Pop` operations\n\nWhen there are many positional arguments to retrieve among the keywords, and few expected remaining keys:\n- Argument matching: Same as current code, with `PyDict_Iter`\n- Validation: same as vectorcall\n- Building the kwargs: same as vectorcall\n\nFinally when **kwargs is unused (one use case is implementing `__cinit__`, but using only a subset of the arguments), building the **kwargs could be skipped, but this skipping logic should be done in a separate function.\n\n\nAs this is a complex topic, I may have some mistakes in my analysis, so please correct me if you find any issue and I will update the text with a mention.\n\n## Side note\n\nAs it seemed the CPython code makes use a PyUnicode functions a lot, I wanted to see if it was really completly handling string subclasses.:\n```python\ndef test(a, b, c):\n    print(a, b, c)\n\nclass hou(str):\n    def __hash__(self):\n        return hash(\"a\")\n    def __str__(self):\n        return \"hello\"\n\nkwargs = {\n    \"a\": 0,\n    hou(\"b\"): 1,\n    hou(\"c\"): 2\n}\ntest(**kwargs)\nprint(\"b\" == hou(\"b\"))\nprint(\"b\" == str(hou(\"b\")))\nprint(hash(\"b\") == hash(hou(\"b\")))\nprint(\"b\" in kwargs)\n```\nOutput is 0, 1, 2 True False False False (python 3.13)\n\nGiven this result, well... looks like hash and dict ownership are not enough ?\n\n```python\nimport operator\noperator.call(test, (), **kwargs)\n\nTypeError: test() got multiple values for argument 'a'\n```\nwell I guess CPython is not consistent in its handling of strings between vectorcall and tp_call.\n\n=> EDIT: Solved. removing () fixes the issue and the behaviour is consistent.\n\nI would suggest to not mind too much about string subclasses and use hash if we want to.\n\n### Describe the solution you'd like.\n\n_No response_\n\n### Describe alternatives you've considered.\n\n_No response_\n\n### Additional context\n\n_No response_",
    "closed_at": "2025-03-07T19:56:01Z",
    "closed_by": {
        "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
        "events_url": "https://api.github.com/users/scoder/events{/privacy}",
        "followers_url": "https://api.github.com/users/scoder/followers",
        "following_url": "https://api.github.com/users/scoder/following{/other_user}",
        "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/scoder",
        "id": 491659,
        "login": "scoder",
        "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
        "organizations_url": "https://api.github.com/users/scoder/orgs",
        "received_events_url": "https://api.github.com/users/scoder/received_events",
        "repos_url": "https://api.github.com/users/scoder/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/scoder",
        "user_view_type": "public"
    },
    "comment_data": [
        {
            "author_association": "MEMBER",
            "body": "Quick comment regarding hash usage: the assumption is that the string keys in keyword argument dicts are almost always interned strings and thus hit the fast path that compares by identity. I wouldn't expect much from speeding up the fall back string comparisons that only happen for non interned strings.\n",
            "created_at": "2025-02-18T21:32:20Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2666973253",
            "id": 2666973253,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6e9shF",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2666973253/reactions"
            },
            "updated_at": "2025-02-18T21:32:20Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2666973253",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> Quick comment regarding hash usage: the assumption is that the string keys in keyword argument dicts are almost always interned strings and thus hit the fast path that compares by identity. I wouldn't expect much from speeding up the fall back string comparisons that only happen for non interned strings.\n\nWhen all keyword arguments are matched with an argument, I would expect the same. However when you explicitly accept **kwargs as input to your function, and indeed additional arguments are given to the function, then this path hits several times.\n\nLet's imagine this function:\n```python\ndef f(a, b, c, d, **kwargs)\n```\n\nIf I call `f(0, 1, 2, 3, e=4, f=5, h=6)`, then all the combinations (a, e), (a, f) (a, h), (b, e), etc will be checked by `PyUnicode_Compare` with the current code. Using hashes for the comparison would avoid the calls.\n",
            "created_at": "2025-02-18T21:45:30Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2666996028",
            "id": 2666996028,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6e9yE8",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2666996028/reactions"
            },
            "updated_at": "2025-02-18T21:45:30Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2666996028",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2546609?v=4",
                "events_url": "https://api.github.com/users/axeldavy/events{/privacy}",
                "followers_url": "https://api.github.com/users/axeldavy/followers",
                "following_url": "https://api.github.com/users/axeldavy/following{/other_user}",
                "gists_url": "https://api.github.com/users/axeldavy/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/axeldavy",
                "id": 2546609,
                "login": "axeldavy",
                "node_id": "MDQ6VXNlcjI1NDY2MDk=",
                "organizations_url": "https://api.github.com/users/axeldavy/orgs",
                "received_events_url": "https://api.github.com/users/axeldavy/received_events",
                "repos_url": "https://api.github.com/users/axeldavy/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/axeldavy/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/axeldavy/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/axeldavy",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I think the point with interning is that: \n\n* If you've manually written `f(0, 1, 2, 3, e=4, f=5, h=6)` in some code somewhere, that's probably caused `e`, `f` and `h` to be interned (because they're compile-time constants in some module).\n* You're probably feeding them to some other function where they are named args, so they're probably interned because of that.\n* Otherwise they're probably looked up in `kwds` with some known string constants (which probably means they're interned)\n* In your toy example, they're length-1 alphanumeric strings, which are interned anyway. \n\nSo it's fairly rare (but not completely impossible) to be using truly dynamic strings as keyword memes.",
            "created_at": "2025-02-18T23:18:17Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2667140167",
            "id": 2667140167,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6e-VRH",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2667140167/reactions"
            },
            "updated_at": "2025-02-18T23:18:17Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2667140167",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Here is a little example:\n\n```python\nimport time\nimport dearcygui as dcg\nimport threading\nimport gc\ngc.disable()\n\ndef f1(a, b, c, d, **kwargs):\n    return\n\ndef f2(a, b, c, d, e, f, g, h, **kwargs):\n    return\n\ndef f3(a, b, c, d, e, f, g, h, i, j, l, m, **kwargs):\n    return\n\nkwargs1 = {}\nkwargs2 = {\"s\": 0, \"t\":0, \"u\":0, \"v\": 0, \"w\": 0, \"x\": 0, \"y\": 0, \"z\": 0}\nkwargs = kwargs1\n\nt1 = time.perf_counter()\nfor _ in range(10000):\n    f1(0, 0, 0, 0, **kwargs)\n    f1(0, 0, 0, 0, **kwargs)\n    f1(0, 0, 0, 0, **kwargs)\n    f1(0, 0, 0, 0, **kwargs)\n    f1(0, 0, 0, 0, **kwargs)\nt2 = time.perf_counter()\nfor _ in range(10000):\n    f2(0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\n    f2(0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\n    f2(0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\n    f2(0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\n    f2(0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\nt3 = time.perf_counter()\nfor _ in range(10000):\n    f3(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\n    f3(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\n    f3(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\n    f3(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\n    f3(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, **kwargs)\nt4 = time.perf_counter()\n\nprint(f\"f1: {1000*(t2-t1)} ms\")\nprint(f\"f2: {1000*(t3-t2)} ms\")\nprint(f\"f3: {1000*(t4-t3)} ms\")\n```\n\nI I use `kwargs = kwargs1`, I get:\n```\nPython interpreter:\nf1: 20.57334100004482 ms\nf2: 20.903512000018054 ms\nf3: 21.52993099991818 ms\nCython:\nf1: 16.97707900007117 ms\nf2: 17.27912000001197 ms\nf3: 17.690614000002824 ms\n```\nNow with `kwargs = kwargs2`:\n```\nPython interpreter:\nf1: 150.65472100002353 ms\nf2: 244.9776070000098 ms\nf3: 337.43621299993265 ms\nCython:\nf1: 158.18723000006685 ms\nf2: 251.41331299994363 ms\nf3: 326.2803249999706 ms\n```\n\nAs you can see, the fact that the strings are interned or not does not impact the speed of the keyword duplication checking code. (Note the fact the Python interpreter doesn't do much better is not an excuse :-) )\n\nLet's include for reference the keyword parsing code:\n```cpp\n/* ParseKeywords */\nstatic int __Pyx_ParseOptionalKeywords(\n    PyObject *kwds,\n    PyObject *const *kwvalues,\n    PyObject **argnames[],\n    PyObject *kwds2,\n    PyObject *values[],\n    Py_ssize_t num_pos_args,\n    const char* function_name)\n{\n    PyObject *key = 0, *value = 0;\n    Py_ssize_t pos = 0;\n    PyObject*** name;\n    PyObject*** first_kw_arg = argnames + num_pos_args;\n    int kwds_is_tuple = CYTHON_METH_FASTCALL && likely(PyTuple_Check(kwds));\n    while (1) {\n        Py_XDECREF(key); key = NULL;\n        Py_XDECREF(value); value = NULL;\n        if (kwds_is_tuple) {\n            Py_ssize_t size;\n#if CYTHON_ASSUME_SAFE_SIZE\n            size = PyTuple_GET_SIZE(kwds);\n#else\n            size = PyTuple_Size(kwds);\n            if (size < 0) goto bad;\n#endif\n            if (pos >= size) break;\n#if CYTHON_AVOID_BORROWED_REFS\n            key = __Pyx_PySequence_ITEM(kwds, pos);\n            if (!key) goto bad;\n#elif CYTHON_ASSUME_SAFE_MACROS\n            key = PyTuple_GET_ITEM(kwds, pos);\n#else\n            key = PyTuple_GetItem(kwds, pos);\n            if (!key) goto bad;\n#endif\n            value = kwvalues[pos];\n            pos++;\n        }\n        else\n        {\n            if (!PyDict_Next(kwds, &pos, &key, &value)) break;\n#if CYTHON_AVOID_BORROWED_REFS\n            Py_INCREF(key);\n#endif\n        }\n        name = first_kw_arg;\n        while (*name && (**name != key)) name++;\n        if (*name) {\n            values[name-argnames] = value;\n#if CYTHON_AVOID_BORROWED_REFS\n            Py_INCREF(value);\n            Py_DECREF(key);\n#endif\n            key = NULL;\n            value = NULL;\n            continue;\n        }\n#if !CYTHON_AVOID_BORROWED_REFS\n        Py_INCREF(key);\n#endif\n        Py_INCREF(value);\n        name = first_kw_arg;\n        if (likely(PyUnicode_Check(key))) {\n            while (*name) {\n                int cmp = (\n                #if CYTHON_ASSUME_SAFE_SIZE\n                    (PyUnicode_GET_LENGTH(**name) != PyUnicode_GET_LENGTH(key)) ? 1 :\n                #endif\n                    PyUnicode_Compare(**name, key)\n                );\n                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;\n                if (cmp == 0) {\n                    values[name-argnames] = value;\n#if CYTHON_AVOID_BORROWED_REFS\n                    value = NULL;\n#endif\n                    break;\n                }\n                name++;\n            }\n            if (*name) continue;\n            else {\n                PyObject*** argname = argnames;\n                while (argname != first_kw_arg) {\n                    int cmp = (**argname == key) ? 0 :\n                    #if CYTHON_ASSUME_SAFE_SIZE\n                        (PyUnicode_GET_LENGTH(**argname) != PyUnicode_GET_LENGTH(key)) ? 1 :\n                    #endif\n                        PyUnicode_Compare(**argname, key);\n                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;\n                    if (cmp == 0) goto arg_passed_twice;\n                    argname++;\n                }\n            }\n        } else\n            goto invalid_keyword_type;\n        if (kwds2) {\n            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;\n        } else {\n            goto invalid_keyword;\n        }\n    }\n    Py_XDECREF(key);\n    Py_XDECREF(value);\n    return 0;\narg_passed_twice:\n    __Pyx_RaiseDoubleKeywordsError(function_name, key);\n    goto bad;\ninvalid_keyword_type:\n    PyErr_Format(PyExc_TypeError,\n        \"%.200s() keywords must be strings\", function_name);\n    goto bad;\ninvalid_keyword:\n    PyErr_Format(PyExc_TypeError,\n        \"%s() got an unexpected keyword argument '%U'\",\n        function_name, key);\nbad:\n    Py_XDECREF(key);\n    Py_XDECREF(value);\n    return -1;\n}\n```\nAs you can see in the keyword duplication checking part, the test is:\n```\n                int cmp = (**argname == key) ? 0 :\n                    #if CYTHON_ASSUME_SAFE_SIZE\n                        (PyUnicode_GET_LENGTH(**argname) != PyUnicode_GET_LENGTH(key)) ? 1 :\n                    #endif\n                        PyUnicode_Compare(**argname, key);\n```\nThe fact that the strings are interned doesn't change that the first equality test fails, and thus we get the other parts of the test.",
            "created_at": "2025-02-19T07:09:57Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2667692680",
            "id": 2667692680,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6fAcKI",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2667692680/reactions"
            },
            "updated_at": "2025-02-19T07:09:57Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2667692680",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2546609?v=4",
                "events_url": "https://api.github.com/users/axeldavy/events{/privacy}",
                "followers_url": "https://api.github.com/users/axeldavy/followers",
                "following_url": "https://api.github.com/users/axeldavy/following{/other_user}",
                "gists_url": "https://api.github.com/users/axeldavy/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/axeldavy",
                "id": 2546609,
                "login": "axeldavy",
                "node_id": "MDQ6VXNlcjI1NDY2MDk=",
                "organizations_url": "https://api.github.com/users/axeldavy/orgs",
                "received_events_url": "https://api.github.com/users/axeldavy/received_events",
                "repos_url": "https://api.github.com/users/axeldavy/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/axeldavy/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/axeldavy/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/axeldavy",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I moved the benchmarking code into a function to eliminate useless overhead and got this with Python 3.12:\n```\nkwargs1 - Cython:\nf1: 2.0222100138198584 ms\nf2: 2.5181209784932435 ms\nf3: 2.3760879994370043 ms\n\nkwargs1 - Python:\nf1: 2.997796982526779 ms\nf2: 3.2965060090646148 ms\nf3: 3.7921319890301675 ms\n\nkwargs2 - Cython:\nf1: 31.21866300352849 ms\nf2: 41.543947998434305 ms\nf3: 52.85455100238323 ms\n\nkwargs2 - Python:\nf1: 35.062206006841734 ms\nf2: 43.13900199485943 ms\nf3: 55.39255900657736 ms\n```\nHowever, your code constructs a particularly bad case. It's rare that all keyword arguments of a function have length 1 and compare lexically after the declared argument names. In realistic code, the length will usually differ considerably, thus eliminating most of the string comparisons, and distinct ordering ranges should also be rare.\n\nThat said, ~we can certainly use the same trick as for the comparison against declared arguments and separate the pointer check from the comparison.~\nEDIT: Misthink. We're expecting the names to *not* exist before, thus to compare unequal to all names we're testing. That's the issue here. Thus, a quick hash test would probably help since we can also quite safely assume all hash values to be unequal.\nEDIT2: I think using the string hash is probably ok – iff we're sure we have an exact str type as key. If it's a subtype, calculating the hash value might fail (it probably won't but it might). And even that's only assuming CPython-specific behaviour.\n\nI also noticed that we're calling `PyErr_Occurred()` a lot due to the ambiguity of the negative `PyUnicode_Compare()` return value. But at least in CPython, the call cannot fail, according to the implementation:\nhttps://github.com/python/cpython/blob/1b6bef8086e46e189cb9c4e46ac2945bc7848ed6/Objects/unicodeobject.c#L11314-L11328\nhttps://github.com/python/cpython/blob/1b6bef8086e46e189cb9c4e46ac2945bc7848ed6/Objects/unicodeobject.c#L11166-L11280\nWe can probably avoid that check, even though it's slightly risky.",
            "created_at": "2025-02-19T10:20:38Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2668188720",
            "id": 2668188720,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6fCVQw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2668188720/reactions"
            },
            "updated_at": "2025-02-19T10:47:51Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2668188720",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I added a hash value check (CPython-only) in https://github.com/cython/cython/pull/6684",
            "created_at": "2025-02-19T16:04:48Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2669090024",
            "id": 2669090024,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6fFxTo",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2669090024/reactions"
            },
            "updated_at": "2025-02-19T16:04:48Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2669090024",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Great improvement! Would it be beneficial as well to cache the unicode\r\nlength ? To avoid the overhead of function calls.\r\n\r\nLe mer. 19 févr. 2025, 17:05, scoder ***@***.***> a écrit :\r\n\r\n> I added a hash value check (CPython-only) in #6684\r\n> <https://github.com/cython/cython/pull/6684>\r\n>\r\n> —\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cython/cython/issues/6683#issuecomment-2669090024>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AATNXMILWGMFRXK5L7YALUT2QSTTNAVCNFSM6AAAAABXMRTTV2VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDMNRZGA4TAMBSGQ>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n> [image: scoder]*scoder* left a comment (cython/cython#6683)\r\n> <https://github.com/cython/cython/issues/6683#issuecomment-2669090024>\r\n>\r\n> I added a hash value check (CPython-only) in #6684\r\n> <https://github.com/cython/cython/pull/6684>\r\n>\r\n> —\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cython/cython/issues/6683#issuecomment-2669090024>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AATNXMILWGMFRXK5L7YALUT2QSTTNAVCNFSM6AAAAABXMRTTV2VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDMNRZGA4TAMBSGQ>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n",
            "created_at": "2025-02-19T17:09:05Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2669256871",
            "id": 2669256871,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6fGaCn",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2669256871/reactions"
            },
            "updated_at": "2025-02-19T17:09:05Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2669256871",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2546609?v=4",
                "events_url": "https://api.github.com/users/axeldavy/events{/privacy}",
                "followers_url": "https://api.github.com/users/axeldavy/followers",
                "following_url": "https://api.github.com/users/axeldavy/following{/other_user}",
                "gists_url": "https://api.github.com/users/axeldavy/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/axeldavy",
                "id": 2546609,
                "login": "axeldavy",
                "node_id": "MDQ6VXNlcjI1NDY2MDk=",
                "organizations_url": "https://api.github.com/users/axeldavy/orgs",
                "received_events_url": "https://api.github.com/users/axeldavy/received_events",
                "repos_url": "https://api.github.com/users/axeldavy/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/axeldavy/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/axeldavy/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/axeldavy",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "The pull requests #6684 indeed helps a lot the demo case above, but I don't get as much a speed-up as I was seeing with my test a few comments above for instance creation.\n\nOne can devise a similar benchmark to previously, but tuned to item creation\n```cython\ncdef class f1:\n    def __init__(self, a, b, c, d, **kwargs):\n        return\n\ncdef class f2:\n    def __init__(self, a, b, c, d, e, f, g, h, **kwargs):\n        return\n\ncdef class f3:\n    def __init__(self, a, b, c, d, e, f, g, h, i, j, l, m, **kwargs):\n        return\n```\nEDIT: replaced `class` by `cdef class`\n\nHere is an proposed way to improve that path:\n```cpp\nstatic int __Pyx_ParseOptionalKeywords(\n    PyObject *kwds,\n    PyObject *const *kwvalues,\n    PyObject **argnames[],\n    PyObject *kwds2,\n    PyObject *values[],\n    Py_ssize_t num_pos_args,\n    const char* function_name)\n{\n    PyObject *key = 0, *value = 0;\n    Py_ssize_t pos = 0;\n    PyObject*** name;\n    PyObject*** first_kw_arg = argnames + num_pos_args;\n    int kwds_is_tuple = CYTHON_METH_FASTCALL && likely(PyTuple_Check(kwds));\n\n    if (!kwds_is_tuple && kwds && kwds2) {\n        // Check dict is unicode\n        if (!PyArg_ValidateKeywordArguments(kwds)) goto bad; // Python already sets the error\n        // Check for duplications\n        name = argnames;\n        while (*name && name != first_kw_arg) {\n            int check = PyDict_Contains(kwds, **name);\n            if (check < 0 && unlikely(PyErr_Occurred())) goto bad;\n            if (check == 1) goto arg_passed_twice;\n            name++;\n        }\n        // Fast copy\n        if (PyDict_Update(kwds2, kwds) < 0)\n           goto bad;\n        // We can keep the copy as is\n        if (!*first_kw_arg)\n            return 0;\n        // Retrieve items and remove them\n        name = first_kw_arg;\n        while (*name) {\n            int found;\n            value = NULL;\n#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030d00A2 || defined(PyDict_Pop)\n            found = PyDict_Pop(kwds2, **name, &value);\n            if (unlikely(found < 0  && PyErr_Occurred())) goto bad;\n            if (found) {\n                values[name-argnames] = value;\n            }\n#else\n            found = PyDict_GetItemRef(kwds2, **name, &value);\n            if (unlikely(found < 0 && PyErr_Occurred())) goto bad;\n            if (found == 1) {\n                values[name-argnames] = value;\n                if (PyDict_DelItem(kwds2, **name) < 0) goto bad;\n            }\n#endif\n            name++;\n        }\n        return 0;\n    }\n\n    while (1) {\n        // clean up key and value when the loop is \"continued\"\n        Py_XDECREF(key); key = NULL;\n        Py_XDECREF(value); value = NULL;\n        [...]\n```\n",
            "created_at": "2025-02-19T21:42:31Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2669825263",
            "id": 2669825263,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6fIkzv",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2669825263/reactions"
            },
            "updated_at": "2025-02-19T21:52:00Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2669825263",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2546609?v=4",
                "events_url": "https://api.github.com/users/axeldavy/events{/privacy}",
                "followers_url": "https://api.github.com/users/axeldavy/followers",
                "following_url": "https://api.github.com/users/axeldavy/following{/other_user}",
                "gists_url": "https://api.github.com/users/axeldavy/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/axeldavy",
                "id": 2546609,
                "login": "axeldavy",
                "node_id": "MDQ6VXNlcjI1NDY2MDk=",
                "organizations_url": "https://api.github.com/users/axeldavy/orgs",
                "received_events_url": "https://api.github.com/users/axeldavy/received_events",
                "repos_url": "https://api.github.com/users/axeldavy/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/axeldavy/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/axeldavy/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/axeldavy",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> instance creation\n\nI came up with an implementation. What's missing now is the case `kwds != NULL && kwds2 == NULL`. That's probably not as efficient as the others yet.",
            "created_at": "2025-02-20T10:26:03Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2671077286",
            "id": 2671077286,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6fNWem",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2671077286/reactions"
            },
            "updated_at": "2025-02-20T10:26:03Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2671077286",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > instance creation\n> \n> I came up with an implementation. What's missing now is the case `kwds != NULL && kwds2 == NULL`. That's probably not as efficient as the others yet.\n\nThat's really great ! 👍 \n\nNow if we were to go even further, here is the original use case I had when I opened #6676:\n```\ncdef class A:\n    def __init__(self, *args, k1=1, k2=2, k3=3):\n        return\n\n    def __cinit__(self, p1, *args, **kwargs):\n        return\n\ncdef class B(A):\n    def __init__(self, *args, k5=5, **kwargs):\n        A.__init__(self, *args, **kwargs)\n\n    def __cinit__(self, p1, p2, *args, **kwargs):\n        return\n\nB(0, 1, k1=6, k2=7, k4=9, k5=1)\n```\n\nHere the `__cinit__` needs to access some parameters (thus cannot just be `__cinit__(self)` ), but they still need to declare `*args` and `**kwargs` to not raise an error when more parameters are present.\n\nThe code should run must faster with the changes, but we still end up with many dict copies:\n- 1 copy is done in A's `__cinit__`, which calls __Pyx_ParseOptionalKeywords\n- 1 copy is done in B's `__cinit__` (same reason)\n- 2 copy is done in B's `__init__`. 1 during argument parsing (the new copy then pop scheme of `__Pyx_ParseOptionalKeywords`) and 1  when it calls `A.__init__` (it sends a copy).\n- 1 copy is done in A's `__init__` (same reason as B for argument parsing)\n\nThus 5 copies, yet in this example None are needed. I don't know how much a copy costs in practice, but it would be a subsequent avenue to improve performance.",
            "created_at": "2025-02-20T13:29:56Z",
            "html_url": "https://github.com/cython/cython/issues/6683#issuecomment-2671507921",
            "id": 2671507921,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/6683",
            "node_id": "IC_kwDOABDGAc6fO_nR",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/cython/cython/issues/comments/2671507921/reactions"
            },
            "updated_at": "2025-02-20T13:29:56Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/2671507921",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2546609?v=4",
                "events_url": "https://api.github.com/users/axeldavy/events{/privacy}",
                "followers_url": "https://api.github.com/users/axeldavy/followers",
                "following_url": "https://api.github.com/users/axeldavy/following{/other_user}",
                "gists_url": "https://api.github.com/users/axeldavy/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/axeldavy",
                "id": 2546609,
                "login": "axeldavy",
                "node_id": "MDQ6VXNlcjI1NDY2MDk=",
                "organizations_url": "https://api.github.com/users/axeldavy/orgs",
                "received_events_url": "https://api.github.com/users/axeldavy/received_events",
                "repos_url": "https://api.github.com/users/axeldavy/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/axeldavy/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/axeldavy/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/axeldavy",
                "user_view_type": "public"
            }
        }
    ],
    "comments": 10,
    "comments_url": "https://api.github.com/repos/cython/cython/issues/6683/comments",
    "created_at": "2025-02-18T20:34:17Z",
    "event_data": [
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder",
                "user_view_type": "public"
            },
            "commit_id": "934ea152880048673974ddd2133a5c0dd416cc70",
            "commit_url": "https://api.github.com/repos/scoder/cython/commits/934ea152880048673974ddd2133a5c0dd416cc70",
            "created_at": "2025-02-19T11:46:21Z",
            "event": "referenced",
            "id": 16364247230,
            "node_id": "REFE_lADOABDGAc6qkD6jzwAAAAPPYpi-",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/16364247230"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder",
                "user_view_type": "public"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2025-03-07T19:56:01Z",
            "event": "closed",
            "id": 16637194686,
            "node_id": "CE_lADOABDGAc6qkD6jzwAAAAPfp3G-",
            "performed_via_github_app": null,
            "state_reason": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/16637194686"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder",
                "user_view_type": "public"
            },
            "commit_id": "41a48b56b22affccdff25d1aad886731c7277d8a",
            "commit_url": "https://api.github.com/repos/cython/cython/commits/41a48b56b22affccdff25d1aad886731c7277d8a",
            "created_at": "2025-03-07T19:56:01Z",
            "event": "closed",
            "id": 16637194711,
            "node_id": "CE_lADOABDGAc6qkD6jzwAAAAPfp3HX",
            "performed_via_github_app": null,
            "state_reason": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/16637194711"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5138957?v=4",
                "events_url": "https://api.github.com/users/jollaitbot/events{/privacy}",
                "followers_url": "https://api.github.com/users/jollaitbot/followers",
                "following_url": "https://api.github.com/users/jollaitbot/following{/other_user}",
                "gists_url": "https://api.github.com/users/jollaitbot/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/jollaitbot",
                "id": 5138957,
                "login": "jollaitbot",
                "node_id": "MDQ6VXNlcjUxMzg5NTc=",
                "organizations_url": "https://api.github.com/users/jollaitbot/orgs",
                "received_events_url": "https://api.github.com/users/jollaitbot/received_events",
                "repos_url": "https://api.github.com/users/jollaitbot/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/jollaitbot/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/jollaitbot/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/jollaitbot",
                "user_view_type": "public"
            },
            "commit_id": "41a48b56b22affccdff25d1aad886731c7277d8a",
            "commit_url": "https://api.github.com/repos/sailfishos-mirror/python-cython/commits/41a48b56b22affccdff25d1aad886731c7277d8a",
            "created_at": "2025-03-08T00:18:42Z",
            "event": "referenced",
            "id": 16639444552,
            "node_id": "REFE_lADOABDGAc6qkD6jzwAAAAPfycZI",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/16639444552"
        }
    ],
    "events_url": "https://api.github.com/repos/cython/cython/issues/6683/events",
    "html_url": "https://github.com/cython/cython/issues/6683",
    "id": 2861579939,
    "labels": [],
    "labels_url": "https://api.github.com/repos/cython/cython/issues/6683/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "I_kwDOABDGAc6qkD6j",
    "number": 6683,
    "performed_via_github_app": null,
    "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/cython/cython/issues/6683/reactions"
    },
    "repository_url": "https://api.github.com/repos/cython/cython",
    "state": "closed",
    "state_reason": "completed",
    "sub_issues_summary": {
        "completed": 0,
        "percent_completed": 0,
        "total": 0
    },
    "timeline_url": "https://api.github.com/repos/cython/cython/issues/6683/timeline",
    "title": "[ENH] Improving argument parsing when using **kwargs",
    "updated_at": "2025-03-07T19:56:01Z",
    "url": "https://api.github.com/repos/cython/cython/issues/6683",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/2546609?v=4",
        "events_url": "https://api.github.com/users/axeldavy/events{/privacy}",
        "followers_url": "https://api.github.com/users/axeldavy/followers",
        "following_url": "https://api.github.com/users/axeldavy/following{/other_user}",
        "gists_url": "https://api.github.com/users/axeldavy/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/axeldavy",
        "id": 2546609,
        "login": "axeldavy",
        "node_id": "MDQ6VXNlcjI1NDY2MDk=",
        "organizations_url": "https://api.github.com/users/axeldavy/orgs",
        "received_events_url": "https://api.github.com/users/axeldavy/received_events",
        "repos_url": "https://api.github.com/users/axeldavy/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/axeldavy/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/axeldavy/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/axeldavy",
        "user_view_type": "public"
    }
}