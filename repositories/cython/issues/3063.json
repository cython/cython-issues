{
    "assignee": null,
    "assignees": [],
    "author_association": "NONE",
    "body": "Given an input:\r\n```\r\nfor entry in my_cpp_function():\r\n    entry.foo()\r\n```\r\nSeems to generate a C++ code like (assuming my_cpp_function return a `vector[Foo]`):\r\n```\r\nFoo entry;\r\nstd::vector<Foo>* vec;\r\n\r\nauto it = vec->begin();\r\nwhile(it != vec->end()) {\r\n     entry = *it;\r\n     it++;\r\n}\r\n```\r\nIn general, this works but makes a copy of entry and assumes that `Foo` is default constructable.\r\nIs there a way to get Cython to creating entry as reference to `Foo`?\r\n\r\nI have tried:\r\n```\r\nfor entry& in my_cpp_function():\r\n    entry.foo()\r\n```\r\nbut this is invalid syntax.\r\n\r\nHere is a complete minimal example:\r\n\r\ntest.h\r\n```\r\n#include <vector>\r\n#include <iostream>\r\n\r\nstruct Foo {\r\n        int a;\r\n\r\n        Foo(int a) : a(a) {}\r\n        void foo() { std::cout << \"Foo \" << a << std::endl; }\r\n};\r\n\r\nstd::vector<Foo> get_foo_vec() {\r\n        return { Foo(1), Foo(2) };\r\n}\r\n\r\nvoid dummy() {\r\n        for (Foo& bla : get_foo_vec()) {\r\n                bla.foo();\r\n        }\r\n}\r\n```\r\ntest.pxd\r\n```\r\nfrom libcpp.vector cimport vector\r\n\r\ncdef extern from \"test.h\":\r\n    cdef cppclass Foo:\r\n        void foo()\r\n    vector[Foo] get_foo_vec()\r\n```\r\ntest.pyx\r\n```\r\ncimport test\r\n\r\ndef iterate():\r\n    for entry in get_foo_vec():\r\n        entry.foo()\r\n```\r\nCompilation with:\r\n```\r\ncython test.pyx -o test_pyx.cpp -Wextra --cplus -3\r\ng++ -I/usr/include/python3.7m test_pyx.cpp\r\n```\r\nError:\r\n```\r\ntest_pyx.cpp: In function 'PyObject* __pyx_pf_4test_iterate(PyObject*)':\r\ntest_pyx.cpp:1069:7: error: no matching function for call to 'Foo::Foo()'\r\n   Foo __pyx_v_entry;\r\n```",
    "closed_at": null,
    "comment_data": [
        {
            "author_association": "NONE",
            "body": "There is a little mistake in `test.pyx`. You need to either change import to `from test cimport get_foo_vec` or use `test.get_foo_vec`. Your point is valid regardless of that though.\r\n\r\nI had similar issues, yet I couldn't find a convenient way to use references from cython. Closest workaround I could come up with was replacing `for .. in` with `while`.\r\n\r\nWith pointer:\r\n\r\n```cy\r\n# distutils: language = c++                                                                                                                                                                                        \r\n                                                                                                                                                                                                                   \r\nfrom cython.operator cimport dereference as deref, preincrement as preinc                                                                                                                                          \r\ncimport test                                                                                                                                                                                                       \r\n                                                                                                                                                                                                                   \r\ncdef vector[test.Foo] vec = test.get_foo_vec()\r\ncdef vector[test.Foo].iterator it = vec.begin()\r\ncdef Foo* elm\r\nwhile it != vec.end():\r\n    elm = &deref(it)  # elm = &*it\r\n    elm.foo()         # elm->foo()\r\n    preinc(it)        # ++it\r\n```\r\n\r\nWith a helper function:\r\n```cy\r\ncdef inline void process_foo(Foo& obj):\r\n    obj.foo()\r\n\r\nwhile it != vec.end():\r\n    process_foo(deref(it))\r\n    preinc(it)\r\n```\r\n\r\nOf course, neither solves underlying issues, the hard requirement for default constructor and/or declaring variables at the top of the function. Both examples are just workarounds for these restrictions. I agree it would be wonderful if default constructor requirement were to be removed. Ideally, this could be achieved by declaring variables when they are first used. AFAICS, cython has been designed with C language conventions in mind, so it may not be trivial to remove these restrictions without serious refactorization specifically for producing C++.",
            "created_at": "2019-08-01T14:25:35Z",
            "html_url": "https://github.com/cython/cython/issues/3063#issuecomment-517310726",
            "id": 517310726,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3063",
            "node_id": "MDEyOklzc3VlQ29tbWVudDUxNzMxMDcyNg==",
            "updated_at": "2019-08-01T14:28:19Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/517310726",
            "user": {
                "avatar_url": "https://avatars0.githubusercontent.com/u/13993759?v=4",
                "events_url": "https://api.github.com/users/ozars/events{/privacy}",
                "followers_url": "https://api.github.com/users/ozars/followers",
                "following_url": "https://api.github.com/users/ozars/following{/other_user}",
                "gists_url": "https://api.github.com/users/ozars/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ozars",
                "id": 13993759,
                "login": "ozars",
                "node_id": "MDQ6VXNlcjEzOTkzNzU5",
                "organizations_url": "https://api.github.com/users/ozars/orgs",
                "received_events_url": "https://api.github.com/users/ozars/received_events",
                "repos_url": "https://api.github.com/users/ozars/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ozars/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ozars/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ozars"
            }
        }
    ],
    "comments": 1,
    "comments_url": "https://api.github.com/repos/cython/cython/issues/3063/comments",
    "created_at": "2019-07-31T12:51:08Z",
    "event_data": [],
    "events_url": "https://api.github.com/repos/cython/cython/issues/3063/events",
    "html_url": "https://github.com/cython/cython/issues/3063",
    "id": 475126227,
    "labels": [],
    "labels_url": "https://api.github.com/repos/cython/cython/issues/3063/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "MDU6SXNzdWU0NzUxMjYyMjc=",
    "number": 3063,
    "repository_url": "https://api.github.com/repos/cython/cython",
    "state": "open",
    "title": "Support for references in for loop?",
    "updated_at": "2019-08-01T14:28:19Z",
    "url": "https://api.github.com/repos/cython/cython/issues/3063",
    "user": {
        "avatar_url": "https://avatars3.githubusercontent.com/u/32870336?v=4",
        "events_url": "https://api.github.com/users/gerion0/events{/privacy}",
        "followers_url": "https://api.github.com/users/gerion0/followers",
        "following_url": "https://api.github.com/users/gerion0/following{/other_user}",
        "gists_url": "https://api.github.com/users/gerion0/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/gerion0",
        "id": 32870336,
        "login": "gerion0",
        "node_id": "MDQ6VXNlcjMyODcwMzM2",
        "organizations_url": "https://api.github.com/users/gerion0/orgs",
        "received_events_url": "https://api.github.com/users/gerion0/received_events",
        "repos_url": "https://api.github.com/users/gerion0/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/gerion0/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/gerion0/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/gerion0"
    }
}