{
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "NONE",
    "body": "<!--\r\n**Note:**\r\n- Do not use the bug and feature tracker for support requests. Use the `cython-users` mailing list instead.\r\n- Did you search for similar issues already? Please do, it helps to save us precious time that we otherwise could not invest into development.\r\n- Did you try the latest master branch or pre-release? It might already have what you want to report. Also see the [Changelog](https://github.com/cython/cython/blob/master/CHANGES.rst) regarding recent changes.\r\n-->\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\n\r\nCython has TCO support due to compiling to C, but it is incomplete due to a slight snag in how it does reference counting.\r\n\r\n```cython\r\ncdef int loop_tail(s, int i, int nearTo):\r\n    if i < nearTo: return loop_tail(s+0,i+1,nearTo)\r\n    else: return s\r\ncpdef int sequence_tailrec(int fron, int nearTo):\r\n    return loop_tail(0,fron,nearTo)\r\n```\r\n\r\nThe issue is that `s + 0` creates a new object that only deallocates after the return. Here is the generated C code.\r\n\r\n```cpp\r\nstatic int __pyx_f_7tailrec_loop_tail(PyObject *__pyx_v_s, int __pyx_v_i, int __pyx_v_nearTo) {\r\n  int __pyx_r;\r\n  __Pyx_RefNannyDeclarations\r\n  int __pyx_t_1;\r\n  PyObject *__pyx_t_2 = NULL;\r\n  int __pyx_t_3;\r\n  int __pyx_lineno = 0;\r\n  const char *__pyx_filename = NULL;\r\n  int __pyx_clineno = 0;\r\n  __Pyx_RefNannySetupContext(\"loop_tail\", 0);\r\n\r\n  /* \"tailrec.pyx\":2\r\n * cdef int loop_tail(s, int i, int nearTo):\r\n *     if i < nearTo: return loop_tail(s+0,i+1,nearTo)             # <<<<<<<<<<<<<<\r\n *     else: return s\r\n * cpdef int sequence_tailrec(int fron, int nearTo):\r\n */\r\n  __pyx_t_1 = ((__pyx_v_i < __pyx_v_nearTo) != 0);\r\n  if (__pyx_t_1) {\r\n    __pyx_t_2 = __Pyx_PyInt_AddObjC(__pyx_v_s, __pyx_int_0, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error)\r\n    __Pyx_GOTREF(__pyx_t_2);\r\n    __pyx_r = __pyx_f_7tailrec_loop_tail(__pyx_t_2, (__pyx_v_i + 1), __pyx_v_nearTo);\r\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\r\n    goto __pyx_L0;\r\n  }\r\n\r\n  /* \"tailrec.pyx\":3\r\n * cdef int loop_tail(s, int i, int nearTo):\r\n *     if i < nearTo: return loop_tail(s+0,i+1,nearTo)\r\n *     else: return s             # <<<<<<<<<<<<<<\r\n * cpdef int sequence_tailrec(int fron, int nearTo):\r\n *     return loop_tail(0,fron,nearTo)\r\n */\r\n  /*else*/ {\r\n    __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_s); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 3, __pyx_L1_error)\r\n    __pyx_r = __pyx_t_3;\r\n    goto __pyx_L0;\r\n  }\r\n\r\n  /* \"tailrec.pyx\":1\r\n * cdef int loop_tail(s, int i, int nearTo):             # <<<<<<<<<<<<<<\r\n *     if i < nearTo: return loop_tail(s+0,i+1,nearTo)\r\n *     else: return s\r\n */\r\n\r\n  /* function exit code */\r\n  __pyx_L1_error:;\r\n  __Pyx_XDECREF(__pyx_t_2);\r\n  __Pyx_WriteUnraisable(\"tailrec.loop_tail\", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);\r\n  __pyx_r = 0;\r\n  __pyx_L0:;\r\n  __Pyx_RefNannyFinishContext();\r\n  return __pyx_r;\r\n}\r\n```\r\n\r\nThe problem in particular is...\r\n\r\n```cpp\r\n     __pyx_r = __pyx_f_7tailrec_loop_tail(__pyx_t_2, (__pyx_v_i + 1), __pyx_v_nearTo);\r\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\r\n```\r\n\r\nThat second line where it decrements the reference after function return is not something the MSVC compiler can optimize out.\r\n\r\n**Describe the solution you'd like**\r\nIn order to enable full TCO, Cython would need an alternative to the `cdef` method statement that has different ref counting semantics to the regular one. The new-style methods should be required to decref their method arguments on return, rather than just their local bindings.\r\n\r\nFor regular method calls not in the tail position that means that the object references would have to be incremented in advance in anticipation to get the equivalent behavior to the regular ones.\r\n\r\n**Additional context**\r\n```cython\r\ncdef int loop_tail(int s, int i, int nearTo):\r\n    if i < nearTo: return loop_tail(s+i,i+1,nearTo)\r\n    else: return s\r\ncpdef int sequence_tailrec(int fron, int nearTo):\r\n    return loop_tail(0,fron,nearTo)\r\n```\r\n\r\n```py\r\nimport pyximport\r\npyximport.install(language_level=3)\r\nimport tailrec\r\nprint(tailrec.sequence_tailrec(0,2_000_000_000))\r\n```\r\n\r\nOn the int example it takes it a second to run to completion and print a number. Whereas if it overflows, it aborts without printing anything. \r\n\r\nOn the object example I use `s+0` instead of `s+i` to eliminate the possibility of the overflow happening due to Python's unbounded ints.",
    "closed_at": null,
    "comment_data": [
        {
            "author_association": "MEMBER",
            "body": "You are asking for tail call optimisation after (probably) just creating a new Python object, allocating memory for it and initialising it?\r\nI doubt that you would see any difference whatsoever in the runtime if that C level optimisation was applied to your code.",
            "created_at": "2021-02-09T17:13:40Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-776096701",
            "id": 776096701,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NjA5NjcwMQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-09T17:13:40Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/776096701",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "author_association": "NONE",
            "body": "> I doubt that you would see any difference whatsoever in the runtime if that C level optimisation was applied to your code.\r\n\r\nDo you mean to say that on the toy example the performance will be dominated by the memory allocation? If that is so, I understand that. If TCO worked though, the program would not stack overflow regardless of the number of iterations.\r\n\r\n> You are asking for tail call optimisation after (probably) just creating a new Python object, allocating memory for it and initialising it?\r\n\r\nI am pointing out that any new objects passed in a tail call effectively block TCO because they need to be decref'd after the method returns. For TCO to work, the method call needs to be the last and not followed by a decref.\r\n\r\nFor this to be the case, Cython needs an alternative construct to the usual `cdef` methods. This is what I am asking for.\r\n\r\nIf I were doing a C backend I could fulfil all of the requirements on the Spiral wishlist for it. I could do the same with Cython if I were to compile objects to pointers and do ref counting manually, but I do not know how to deal with exceptions. Exceptions would leave pointers hanging. So I have no choice, but to make a request.",
            "created_at": "2021-02-10T10:36:32Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-776614106",
            "id": 776614106,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NjYxNDEwNg==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-10T10:39:12Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/776614106",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I understand that the C stack limit can become an issue here, so yes, there is a case for TCO.\r\n\r\nJust asking, but you are working on a code generator, right? Can't you explicitly generate a loop instead? (I understand that there might be scoping issues involved.)\r\n\r\nDid you try changing the C code directly to see if your proposed generated code solves the issue for you?\r\n\r\nCould you also try out (manually) if generating two functions, one that behaves as before and one that calls the first and decrefs the input arguments, achieves the desired optimisation if they call each other recursively? This could be done internally without adding new syntax.\r\n\r\nAlso, did you try it with different C compilers? I'd like to avoid adding a language feature (which would probably stick around forever) for something that is a limitation of a specific C compiler (which might be lifted in a future version).",
            "created_at": "2021-02-11T11:47:18Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-777392774",
            "id": 777392774,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NzM5Mjc3NA==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-11T11:47:18Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/777392774",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "author_association": "NONE",
            "body": "> Just asking, but you are working on a code generator, right?\r\n\r\n[Spiral](https://github.com/mrakgr/The-Spiral-Language#the-spiral-language) is a fully fledged functional programming language. You can get it as an VS Code extension if you are interested. It has first class function, union types, pattern matching, type inference. The whole functional package and never before seen extras like join points.\r\n\r\n> Can't you explicitly generate a loop instead? (I understand that there might be scoping issues involved.)\r\n\r\nSpiral does support while loops, but it does not support imperative features like break, continue and return so they are less flexible. It also does not support stack pointers. So when I do mutable variables, they are heap allocated instead as objects. For that reason, I'd like to avoid using while. Back in 2018 when I worked on the old Spiral, the only reason I put it in is because the Cuda compiler was buggy and produced outright wrong code on calls that returned tuples.\r\n\r\nIn a functional language TCO is useful as it provides an efficient way getting the equivalent functionality. It is easy to emulate nested loops, breaks and continues via tail calls. For simple loops, they are a way of avoiding allocating a heap mutable object. Once I got used to programming this way, I found that this style is safer as well.\r\n\r\nSpiral does support macros, so imperative features like break, continue and return could be done using them. It would be hacky though.\r\n\r\nLooking at it more deeply though, suppose the question you've asked is - why not have Spiral convert the tail calls into a loop instead of leaving it to the C compiler?\r\n\r\nI've never really thought about it. I do not know much about TCO myself, but I don't think that it is possible to compile arbitrary tail calls into regular structured programming constructs. For simple ones it might be doable, but TCO is something that really should be left to the C compiler in my view. There are some techniques to get around the lack of TCO on platforms like the JVM. They are inefficient though as they involve using heap allocated stacks and closures. If the C compiler did not support TCO and I had to do it, I'd instead opt to compile to Assembly instead. Of course, this would be much harder than compiling to C.\r\n\r\n> Could you also try out (manually) if generating two functions, one that behaves as before and one that calls the first and decrefs the input arguments, achieves the desired optimization if they call each other recursively?\r\n\r\nIt is worth a try. I'll make some time to do it later. \r\n\r\n> This could be done internally without adding new syntax.\r\n\r\nOk, I see a [guide here](https://github.com/cython/cython/wiki/refcounting). I'll have to spend some time thinking about this, I do not understand how Cython's ref counting works in its entirety yet. I understand incref and decref, but that nanny and the other operations is not something I've looked into yet. Are there any more docs on this?\r\n\r\nRelated to this, I did try one thing.\r\n\r\n```cython\r\ncdef int loop_tail(int s, int i, int nearTo) except *:\r\n    if i < nearTo: return loop_tail(s+i,i+1,nearTo)\r\n    else: return s\r\ncpdef int sequence_tailrec(int fron, int nearTo) except *:\r\n    return loop_tail(0,fron,nearTo)\r\n```\r\n\r\nAdding `except *` to this breaks TCO. It is easy to see why that is. Because a check needs to be done after a call, that means the call itself cannot be done in the tail end position in the compiled code. I am going to have to add a compiler option and have the user decide whether he wants proper exceptions or TCO.\r\n\r\n> Also, did you try it with different C compilers? I'd like to avoid adding a language feature (which would probably stick around forever) for something that is a limitation of a specific C compiler (which might be lifted in a future version).\r\n\r\nNo, I did not. Only with MSVC. But I'd be very impressed if GCC or Clang end up being capable of this because it would require fundamentally changing the semantics of the compiled method.\r\n\r\nThe transformations MSVC are actually pretty impressive already because the function call in the compiled code does not at all happen in tail position. But the compiler can see that the bind to an intermediate and the goto jump are superfluous and is capable of optimizing them away.\r\n\r\nEven without doing the tests you've inquired about, I am certain of the TCO breakage's cause, but I'd be interested to find out if modern C compilers are capable of optimizing all kinds of tail calling functions rather then just this simple one here.",
            "created_at": "2021-02-11T14:58:01Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-777535085",
            "id": 777535085,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NzUzNTA4NQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-11T14:58:51Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/777535085",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        }
    ],
    "comments": 4,
    "comments_url": "https://api.github.com/repos/cython/cython/issues/3999/comments",
    "created_at": "2021-02-05T17:21:15Z",
    "event_data": [
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-11T11:48:08Z",
            "event": "renamed",
            "id": 4319412454,
            "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50NDMxOTQxMjQ1NA==",
            "performed_via_github_app": null,
            "rename": {
                "from": "[ENH] Ownership passing for full tall call optimization in cdef methods",
                "to": "[ENH] Temporary Python arguments prevent tail call optimization in cdef methods"
            },
            "url": "https://api.github.com/repos/cython/cython/issues/events/4319412454"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-11T11:48:22Z",
            "event": "renamed",
            "id": 4319413449,
            "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50NDMxOTQxMzQ0OQ==",
            "performed_via_github_app": null,
            "rename": {
                "from": "[ENH] Temporary Python arguments prevent tail call optimization in cdef methods",
                "to": "[ENH] Temporary Python arguments prevent tail call optimization in cdef functions"
            },
            "url": "https://api.github.com/repos/cython/cython/issues/events/4319413449"
        }
    ],
    "events_url": "https://api.github.com/repos/cython/cython/issues/3999/events",
    "html_url": "https://github.com/cython/cython/issues/3999",
    "id": 802339291,
    "labels": [],
    "labels_url": "https://api.github.com/repos/cython/cython/issues/3999/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "MDU6SXNzdWU4MDIzMzkyOTE=",
    "number": 3999,
    "performed_via_github_app": null,
    "repository_url": "https://api.github.com/repos/cython/cython",
    "state": "open",
    "title": "[ENH] Temporary Python arguments prevent tail call optimization in cdef functions",
    "updated_at": "2021-02-11T14:58:51Z",
    "url": "https://api.github.com/repos/cython/cython/issues/3999",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
        "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
        "followers_url": "https://api.github.com/users/mrakgr/followers",
        "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
        "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/mrakgr",
        "id": 6266635,
        "login": "mrakgr",
        "node_id": "MDQ6VXNlcjYyNjY2MzU=",
        "organizations_url": "https://api.github.com/users/mrakgr/orgs",
        "received_events_url": "https://api.github.com/users/mrakgr/received_events",
        "repos_url": "https://api.github.com/users/mrakgr/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/mrakgr"
    }
}