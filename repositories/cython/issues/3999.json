{
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "NONE",
    "body": "<!--\r\n**Note:**\r\n- Do not use the bug and feature tracker for support requests. Use the `cython-users` mailing list instead.\r\n- Did you search for similar issues already? Please do, it helps to save us precious time that we otherwise could not invest into development.\r\n- Did you try the latest master branch or pre-release? It might already have what you want to report. Also see the [Changelog](https://github.com/cython/cython/blob/master/CHANGES.rst) regarding recent changes.\r\n-->\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\n\r\nCython has TCO support due to compiling to C, but it is incomplete due to a slight snag in how it does reference counting.\r\n\r\n```cython\r\ncdef int loop_tail(s, int i, int nearTo):\r\n    if i < nearTo: return loop_tail(s+0,i+1,nearTo)\r\n    else: return s\r\ncpdef int sequence_tailrec(int fron, int nearTo):\r\n    return loop_tail(0,fron,nearTo)\r\n```\r\n\r\nThe issue is that `s + 0` creates a new object that only deallocates after the return. Here is the generated C code.\r\n\r\n```cpp\r\nstatic int __pyx_f_7tailrec_loop_tail(PyObject *__pyx_v_s, int __pyx_v_i, int __pyx_v_nearTo) {\r\n  int __pyx_r;\r\n  __Pyx_RefNannyDeclarations\r\n  int __pyx_t_1;\r\n  PyObject *__pyx_t_2 = NULL;\r\n  int __pyx_t_3;\r\n  int __pyx_lineno = 0;\r\n  const char *__pyx_filename = NULL;\r\n  int __pyx_clineno = 0;\r\n  __Pyx_RefNannySetupContext(\"loop_tail\", 0);\r\n\r\n  /* \"tailrec.pyx\":2\r\n * cdef int loop_tail(s, int i, int nearTo):\r\n *     if i < nearTo: return loop_tail(s+0,i+1,nearTo)             # <<<<<<<<<<<<<<\r\n *     else: return s\r\n * cpdef int sequence_tailrec(int fron, int nearTo):\r\n */\r\n  __pyx_t_1 = ((__pyx_v_i < __pyx_v_nearTo) != 0);\r\n  if (__pyx_t_1) {\r\n    __pyx_t_2 = __Pyx_PyInt_AddObjC(__pyx_v_s, __pyx_int_0, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error)\r\n    __Pyx_GOTREF(__pyx_t_2);\r\n    __pyx_r = __pyx_f_7tailrec_loop_tail(__pyx_t_2, (__pyx_v_i + 1), __pyx_v_nearTo);\r\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\r\n    goto __pyx_L0;\r\n  }\r\n\r\n  /* \"tailrec.pyx\":3\r\n * cdef int loop_tail(s, int i, int nearTo):\r\n *     if i < nearTo: return loop_tail(s+0,i+1,nearTo)\r\n *     else: return s             # <<<<<<<<<<<<<<\r\n * cpdef int sequence_tailrec(int fron, int nearTo):\r\n *     return loop_tail(0,fron,nearTo)\r\n */\r\n  /*else*/ {\r\n    __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_s); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 3, __pyx_L1_error)\r\n    __pyx_r = __pyx_t_3;\r\n    goto __pyx_L0;\r\n  }\r\n\r\n  /* \"tailrec.pyx\":1\r\n * cdef int loop_tail(s, int i, int nearTo):             # <<<<<<<<<<<<<<\r\n *     if i < nearTo: return loop_tail(s+0,i+1,nearTo)\r\n *     else: return s\r\n */\r\n\r\n  /* function exit code */\r\n  __pyx_L1_error:;\r\n  __Pyx_XDECREF(__pyx_t_2);\r\n  __Pyx_WriteUnraisable(\"tailrec.loop_tail\", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);\r\n  __pyx_r = 0;\r\n  __pyx_L0:;\r\n  __Pyx_RefNannyFinishContext();\r\n  return __pyx_r;\r\n}\r\n```\r\n\r\nThe problem in particular is...\r\n\r\n```cpp\r\n     __pyx_r = __pyx_f_7tailrec_loop_tail(__pyx_t_2, (__pyx_v_i + 1), __pyx_v_nearTo);\r\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\r\n```\r\n\r\nThat second line where it decrements the reference after function return is not something the MSVC compiler can optimize out.\r\n\r\n**Describe the solution you'd like**\r\nIn order to enable full TCO, Cython would need an alternative to the `cdef` method statement that has different ref counting semantics to the regular one. The new-style methods should be required to decref their method arguments on return, rather than just their local bindings.\r\n\r\nFor regular method calls not in the tail position that means that the object references would have to be incremented in advance in anticipation to get the equivalent behavior to the regular ones.\r\n\r\n**Additional context**\r\n```cython\r\ncdef int loop_tail(int s, int i, int nearTo):\r\n    if i < nearTo: return loop_tail(s+i,i+1,nearTo)\r\n    else: return s\r\ncpdef int sequence_tailrec(int fron, int nearTo):\r\n    return loop_tail(0,fron,nearTo)\r\n```\r\n\r\n```py\r\nimport pyximport\r\npyximport.install(language_level=3)\r\nimport tailrec\r\nprint(tailrec.sequence_tailrec(0,2_000_000_000))\r\n```\r\n\r\nOn the int example it takes it a second to run to completion and print a number. Whereas if it overflows, it aborts without printing anything. \r\n\r\nOn the object example I use `s+0` instead of `s+i` to eliminate the possibility of the overflow happening due to Python's unbounded ints.",
    "closed_at": null,
    "comment_data": [
        {
            "author_association": "MEMBER",
            "body": "You are asking for tail call optimisation after (probably) just creating a new Python object, allocating memory for it and initialising it?\r\nI doubt that you would see any difference whatsoever in the runtime if that C level optimisation was applied to your code.",
            "created_at": "2021-02-09T17:13:40Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-776096701",
            "id": 776096701,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NjA5NjcwMQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-09T17:13:40Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/776096701",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "author_association": "NONE",
            "body": "> I doubt that you would see any difference whatsoever in the runtime if that C level optimisation was applied to your code.\r\n\r\nDo you mean to say that on the toy example the performance will be dominated by the memory allocation? If that is so, I understand that. If TCO worked though, the program would not stack overflow regardless of the number of iterations.\r\n\r\n> You are asking for tail call optimisation after (probably) just creating a new Python object, allocating memory for it and initialising it?\r\n\r\nI am pointing out that any new objects passed in a tail call effectively block TCO because they need to be decref'd after the method returns. For TCO to work, the method call needs to be the last and not followed by a decref.\r\n\r\nFor this to be the case, Cython needs an alternative construct to the usual `cdef` methods. This is what I am asking for.\r\n\r\nIf I were doing a C backend I could fulfil all of the requirements on the Spiral wishlist for it. I could do the same with Cython if I were to compile objects to pointers and do ref counting manually, but I do not know how to deal with exceptions. Exceptions would leave pointers hanging. So I have no choice, but to make a request.",
            "created_at": "2021-02-10T10:36:32Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-776614106",
            "id": 776614106,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NjYxNDEwNg==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-10T10:39:12Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/776614106",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I understand that the C stack limit can become an issue here, so yes, there is a case for TCO.\r\n\r\nJust asking, but you are working on a code generator, right? Can't you explicitly generate a loop instead? (I understand that there might be scoping issues involved.)\r\n\r\nDid you try changing the C code directly to see if your proposed generated code solves the issue for you?\r\n\r\nCould you also try out (manually) if generating two functions, one that behaves as before and one that calls the first and decrefs the input arguments, achieves the desired optimisation if they call each other recursively? This could be done internally without adding new syntax.\r\n\r\nAlso, did you try it with different C compilers? I'd like to avoid adding a language feature (which would probably stick around forever) for something that is a limitation of a specific C compiler (which might be lifted in a future version).",
            "created_at": "2021-02-11T11:47:18Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-777392774",
            "id": 777392774,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NzM5Mjc3NA==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-11T11:47:18Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/777392774",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "author_association": "NONE",
            "body": "> Just asking, but you are working on a code generator, right?\r\n\r\n[Spiral](https://github.com/mrakgr/The-Spiral-Language#the-spiral-language) is a fully fledged functional programming language. You can get it as an VS Code extension if you are interested. It has first class function, union types, pattern matching, type inference. The whole functional package and never before seen extras like join points.\r\n\r\n> Can't you explicitly generate a loop instead? (I understand that there might be scoping issues involved.)\r\n\r\nSpiral does support while loops, but it does not support imperative features like break, continue and return so they are less flexible. It also does not support stack pointers. So when I do mutable variables, they are heap allocated instead as objects. For that reason, I'd like to avoid using while. Back in 2018 when I worked on the old Spiral, the only reason I put it in is because the Cuda compiler was buggy and produced outright wrong code on calls that returned tuples.\r\n\r\nIn a functional language TCO is useful as it provides an efficient way getting the equivalent functionality. It is easy to emulate nested loops, breaks and continues via tail calls. For simple loops, they are a way of avoiding allocating a heap mutable object. Once I got used to programming this way, I found that this style is safer as well.\r\n\r\nSpiral does support macros, so imperative features like break, continue and return could be done using them. It would be hacky though.\r\n\r\nLooking at it more deeply though, suppose the question you've asked is - why not have Spiral convert the tail calls into a loop instead of leaving it to the C compiler?\r\n\r\nI've never really thought about it. I do not know much about TCO myself, but I don't think that it is possible to compile arbitrary tail calls into regular structured programming constructs. For simple ones it might be doable, but TCO is something that really should be left to the C compiler in my view. There are some techniques to get around the lack of TCO on platforms like the JVM. They are inefficient though as they involve using heap allocated stacks and closures. If the C compiler did not support TCO and I had to do it, I'd instead opt to compile to Assembly instead. Of course, this would be much harder than compiling to C.\r\n\r\n> Could you also try out (manually) if generating two functions, one that behaves as before and one that calls the first and decrefs the input arguments, achieves the desired optimization if they call each other recursively?\r\n\r\nIt is worth a try. I'll make some time to do it later. \r\n\r\n> This could be done internally without adding new syntax.\r\n\r\nOk, I see a [guide here](https://github.com/cython/cython/wiki/refcounting). I'll have to spend some time thinking about this, I do not understand how Cython's ref counting works in its entirety yet. I understand incref and decref, but that nanny and the other operations is not something I've looked into yet. Are there any more docs on this?\r\n\r\nRelated to this, I did try one thing.\r\n\r\n```cython\r\ncdef int loop_tail(int s, int i, int nearTo) except *:\r\n    if i < nearTo: return loop_tail(s+i,i+1,nearTo)\r\n    else: return s\r\ncpdef int sequence_tailrec(int fron, int nearTo) except *:\r\n    return loop_tail(0,fron,nearTo)\r\n```\r\n\r\nAdding `except *` to this breaks TCO. It is easy to see why that is. Because a check needs to be done after a call, that means the call itself cannot be done in the tail end position in the compiled code. I am going to have to add a compiler option and have the user decide whether he wants proper exceptions or TCO.\r\n\r\n> Also, did you try it with different C compilers? I'd like to avoid adding a language feature (which would probably stick around forever) for something that is a limitation of a specific C compiler (which might be lifted in a future version).\r\n\r\nNo, I did not. Only with MSVC. But I'd be very impressed if GCC or Clang end up being capable of this because it would require fundamentally changing the semantics of the compiled method.\r\n\r\nThe transformations MSVC are actually pretty impressive already because the function call in the compiled code does not at all happen in tail position. But the compiler can see that the bind to an intermediate and the goto jump are superfluous and is capable of optimizing them away.\r\n\r\nEven without doing the tests you've inquired about, I am certain of the TCO breakage's cause, but I'd be interested to find out if modern C compilers are capable of optimizing all kinds of tail calling functions rather then just this simple one here.",
            "created_at": "2021-02-11T14:58:01Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-777535085",
            "id": 777535085,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NzUzNTA4NQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-11T14:58:51Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/777535085",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Don't bother with the refnanny. It's not used outside of our test suite. You can just move the recursive call and the `DECREF` around.",
            "created_at": "2021-02-11T16:02:05Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-777602231",
            "id": 777602231,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3NzYwMjIzMQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-11T16:02:05Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/777602231",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "author_association": "NONE",
            "body": "```cython\r\nfrom cpython.ref cimport PyObject, Py_INCREF, Py_DECREF, Py_CLEAR, Py_XDECREF, Py_XINCREF\r\n\r\ncdef int loop_tail(s, int i, int nearTo):\r\n    if i < nearTo: \r\n        n = s + i\r\n        Py_DECREF(s)\r\n        return loop_tail(n,i+1,nearTo)\r\n    else: \r\n        # This is not correct and could push the ref count to 0. \r\n        # I need a succinct way of decrefing if the ref count is greater than 1 here.\r\n        # I know that I could use sys.getrefcount, but that would be inefficient and the temporaries introduced by it could ruin TCO.\r\n        Py_DECREF(s) \r\n        return s\r\ncpdef int sequence_tailrec(int fron, int nearTo):\r\n    s = 0\r\n    Py_INCREF(s)\r\n    return loop_tail(0,fron,nearTo)\r\n```\r\n\r\nOk, I have the `Py_DECREF(s)` in the right place. But I do not know how to suppress the compiler from generating the code to decref `n` on the function exit. How should that be done? I know that `del` can suppress it, but `Py_DECREF` cannot.",
            "created_at": "2021-02-12T15:00:05Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-778245981",
            "id": 778245981,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODI0NTk4MQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-12T15:00:05Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/778245981",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "NONE",
            "body": "Though I am sure about what is breaking TCO, I've been thinking about the `Py_DECREF(s)` in the else branch. Originally, I meant to write the above as...\r\n\r\n```\r\ncdef int loop_tail(s, int i, int nearTo):\r\n    if i < nearTo: \r\n        n = s + i\r\n        Py_DECREF(s)\r\n        return loop_tail(n,i+1,nearTo)\r\n    else: return s\r\n```\r\n\r\nThen I realized it would not work, so I made the only fix that made sense which would be to decref if the ref count is greater than 1. But I am not sure whether that rule is sound either. The rule apply that kind of decref if the var is in an return statement and is a function arg seems like a huge hack. I do not know if it would be sound if applied more broadly rather than just on this toy example.\r\n\r\nI think it should work, but it would be wiser to try it out for a while until I am sure.\r\n\r\nAssuming you can show me how to suppress the compiler from decrefing on its own and how to do decref if greater than 1 efficiently, I'll actually have everything I need to implement what I need.\r\n\r\nI do not actually need an alternative `cdef` statement to make TCO work, but the above two simple features instead. An alternative statement would just be there for interop with regular Cython code which does not incref the arguments before making the call. And even that actually isn't a problem since random code in the wild would not be calling Spiral's unnamed join points. Actual interop points could be compiled to have the usual semantics.",
            "created_at": "2021-02-13T15:20:17Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-778633189",
            "id": 778633189,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODYzMzE4OQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-13T15:20:17Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/778633189",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "COLLABORATOR",
            "body": "> Assuming you can show me how to suppress the compiler from decrefing on its own\r\n\r\nTo stop Cython from generating it's own reference counting code you use variables of type `PyObject*`. You can cast these to and from Cython's `object` (e.g. `x = <PyObject*>some_function_call()`. The C representation is the same, but Cython doesn't interfere with `PyObject*` variables.\r\n\r\n> and how to do decref if greater than 1 efficiently\r\n\r\nI don't think there's a built-in way of doing this. You probably just need to write an short (inline?) `cdef` function that does `if Py_REFCNT(o) > 1: Py_DECREF(o)`",
            "created_at": "2021-02-13T15:43:49Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-778635840",
            "id": 778635840,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODYzNTg0MA==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-13T15:43:49Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/778635840",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "author_association": "NONE",
            "body": "```py\r\ndef f():\r\n    x = \"object\"\r\n    # No incref due to it being in tail position.\r\n    # Ref count of x: 1.\r\n    g(x)\r\ndef g(x):\r\n    a = 1,x\r\n    # Ref count of x: 2\r\n    b = 2,x\r\n    # Ref count of x: 3\r\n    decrefIfGtThan1(x)\r\n    # Ref count of x: 2\r\n    return a,b,x\r\na,b,x = f()\r\ndel a; del b\r\n# Ref count of x: 0\r\n# And yet it is still bound.\r\n```\r\n\r\nI figured out a counter example and here it is. There is a way to make this work, and that would be to shallow copy `x` before returning it in `g`. But I am uncomfortable with this approach due to its high churn. I am thinking ahead to how I would do ref counting in a potential C backend, and I am seeing that a copying rule would cause whole arrays to be duplicated before being disposed. Then to get around that flaw I'd have to design such an object structure to hold only the ref count and the pointer to the actual object. But then all object accesses would need to go through two layers of indirection rather than one.\r\n\r\nThis problem pales in comparison to the fact that shallow copying would only work for native memory and would not work with Python's side effecting disposal. Even if one object gets shallow copied before a return in order to make the ref count valid that still mean GPU memory would get released and file handles would get closed in the other.\r\n\r\nHow nasty. The current rules of Cython are much cleaner in comparison even if they block TCO.\r\n\r\nI am considering closing this issue, but I'll linger on it for a while longer. I'll try asking around, but I am not hopeful about finding a solution to this.",
            "created_at": "2021-02-13T16:20:50Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-778640370",
            "id": 778640370,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODY0MDM3MA==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-13T16:20:50Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/778640370",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "NONE",
            "body": "I've figured out how this should work. As it turns out, my initial idea of just returning `s` in the else branch without refdecing was the right way to go.\r\n\r\nI am going to give a proof in pseudocode. F# is used as a language just to highlight the text. Sorry that I am making you read all this.\r\n\r\n```fs\r\nlet decref s : unit = failwith \"decrements the reference count\"\r\nlet incref s : unit = failwith \"increments the reference count\"\r\nlet assert_reference_count obj (count : int) : unit = failwith \"asserts the reference count\"\r\n\r\nlet rec loop_tail s i nearTo =\r\n    if i < nearTo then\r\n        let n = s + 0\r\n        assert_reference_count n 1\r\n        decref(s)\r\n        loop_tail n (i+1) nearTo\r\n    else\r\n        s\r\n\r\nlet test_loop_tail_false () =\r\n    // Unlike in Python, because they are immutable the bindings do not affect the reference count.\r\n    let s : int = 0 // Pretend int is an object here. \r\n    assert_reference_count s 1\r\n\r\n    incref s\r\n    let a = loop_tail s 0 0 // Returns s\r\n    assert_reference_count s 2\r\n    assert_reference_count a 2\r\n\r\n    incref s\r\n    let b = loop_tail s 0 0 // Returns s\r\n    assert_reference_count s 3\r\n    assert_reference_count a 3\r\n    assert_reference_count b 3\r\n\r\n    incref s\r\n    let c = loop_tail s 0 0 // Returns s. Since all of these are the same object, their reference counts are the same.\r\n    assert_reference_count s 4\r\n    assert_reference_count a 4\r\n    assert_reference_count b 4\r\n    assert_reference_count c 4\r\n\r\n    // Exits the function. Decrefs s,a,b,c.\r\n    decref s\r\n    assert_reference_count s 3\r\n    assert_reference_count a 3\r\n    assert_reference_count b 3\r\n    assert_reference_count c 3\r\n\r\n    decref a\r\n    assert_reference_count s 2\r\n    assert_reference_count a 2\r\n    assert_reference_count b 2\r\n    assert_reference_count c 2\r\n\r\n    decref b\r\n    assert_reference_count s 1\r\n    assert_reference_count a 1\r\n    assert_reference_count b 1\r\n    assert_reference_count c 1\r\n\r\n    decref c\r\n    assert_reference_count s 0\r\n    assert_reference_count a 0\r\n    assert_reference_count b 0\r\n    assert_reference_count c 0\r\n\r\nlet test_loop_tail_true () =\r\n    // Unlike in Python, because they are immutable the bindings do not affect the reference count.\r\n    let s : int = 0 // Pretend int is an object here.\r\n    assert_reference_count s 1\r\n\r\n    incref s\r\n    let a = loop_tail s 0 1 // Visits the true branch once. Decrefs s and return the new object.\r\n    assert_reference_count s 1\r\n    assert_reference_count a 1\r\n\r\n    incref s\r\n    let b = loop_tail s 0 1 // Visits the true branch once. Decrefs s and return the new object.\r\n    assert_reference_count s 1\r\n    assert_reference_count a 1\r\n    assert_reference_count b 1\r\n\r\n    incref s\r\n    let c = loop_tail s 0 1 // Visits the true branch once. Decrefs s and return the new object.\r\n    assert_reference_count s 1\r\n    assert_reference_count a 1\r\n    assert_reference_count b 1\r\n    assert_reference_count c 1\r\n\r\n    // Exits the function. Decrefs s,a,b,c.\r\n    decref s\r\n    assert_reference_count s 0\r\n    assert_reference_count a 1\r\n    assert_reference_count b 1\r\n    assert_reference_count c 1\r\n\r\n    decref a\r\n    assert_reference_count s 0\r\n    assert_reference_count a 0\r\n    assert_reference_count b 1\r\n    assert_reference_count c 1\r\n\r\n    decref b\r\n    assert_reference_count s 0\r\n    assert_reference_count a 0\r\n    assert_reference_count b 0\r\n    assert_reference_count c 1\r\n\r\n    decref c\r\n    assert_reference_count s 0\r\n    assert_reference_count a 0\r\n    assert_reference_count b 0\r\n    assert_reference_count c 0\r\n```\r\n\r\nThis is how the reference counts should go. The important thing is that s,a,b,c are zeroed out the end of the test. I got way too hung up about decrefing the function arguments in the function itself, not realizing that much like for regular locals, freeing them becomes the responsibility of the new owner.\r\n\r\n---\r\n\r\n@da-woods \r\n\r\n```cython\r\nfrom cpython.ref cimport PyObject, Py_INCREF, Py_DECREF, Py_CLEAR, Py_XDECREF, Py_XINCREF\r\ncdef loop_tail(s, int i, int nearTo):\r\n    cdef PyObject * n\r\n    if i < nearTo: \r\n        n = <PyObject *> (s + 0)\r\n        Py_DECREF(s)\r\n        return loop_tail(<object> n,i+1,nearTo)\r\n    else: return s\r\n```\r\n```\r\nfrom cpython.ref cimport PyObject, Py_INCREF, Py_DECREF, Py_CLEAR, Py_XDECREF, Py_XINCREF\r\nimport sys\r\ncdef loop_tail(s, int i, int nearTo):\r\n    cdef PyObject * n\r\n    if i < nearTo:\r\n        n = <PyObject *> (s + 0)\r\n           ^\r\n------------------------------------------------------------\r\n\r\ncython_experiments\\test3\\testm.pyx:6:12: Storing unsafe C derivative of temporary Python reference\r\n```\r\n\r\nWith the proof in mind, hopefully exactly what I want to write should be clear here. Can I get a hand with this? I can't figure out how to write this as I keep getting weird type errors. ",
            "created_at": "2021-02-13T19:22:31Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-778665629",
            "id": 778665629,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODY2NTYyOQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-14T09:34:07Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/778665629",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "COLLABORATOR",
            "body": "To be honest this is more complicated than I remembered. I came up with something like this:\r\n\r\n```\r\nfrom cpython.ref cimport PyObject, Py_DECREF, Py_INCREF\r\n\r\ncdef inline PyObject* getPyObject(object o):\r\n    Py_INCREF(o)  # Cython will always put a decref in on \"o\" so need to counteract it\r\n    return <PyObject*>o\r\n\r\n# In a separate function to keep all Python temp cleanup code out of loop_tail\r\ncdef PyObject* splus0(PyObject* s) except NULL:\r\n    return getPyObject(<object>s+0)\r\n\r\ncdef PyObject* loop_tail(PyObject* s, int i, int nearTo) except NULL:\r\n    cdef PyObject *n\r\n    if i < nearTo:\r\n        n = splus0(s)\r\n        Py_DECREF(<object>s)\r\n        return loop_tail(n, i+1, nearTo)\r\n    else:\r\n        return s\r\n\r\ndef run_loop_tail(s, i, nearTo):\r\n    Py_INCREF(s)\r\n    return <object>loop_tail(<PyObject*>s, i, nearTo)\r\n```\r\n\r\nEven so this gives me something like:\r\n\r\n```\r\nstatic PyObject *__pyx_f_6pyxobj_loop_tail(PyObject *__pyx_v_s, int __pyx_v_i, int __pyx_v_nearTo) {\r\n  PyObject *__pyx_v_n;\r\n  PyObject *__pyx_r;\r\n  __Pyx_RefNannyDeclarations\r\n  int __pyx_t_1;\r\n  PyObject *__pyx_t_2;\r\n  int __pyx_lineno = 0;\r\n  const char *__pyx_filename = NULL;\r\n  int __pyx_clineno = 0;\r\n  __Pyx_RefNannySetupContext(\"loop_tail\", 0);\r\n  __pyx_t_1 = ((__pyx_v_i < __pyx_v_nearTo) != 0);\r\n  if (__pyx_t_1) {\r\n     __pyx_t_2 = __pyx_f_6pyxobj_splus0(__pyx_v_s); if (unlikely(__pyx_t_2 == ((PyObject *)NULL))) __PYX_ERR(0, 13, __pyx_L1_error)\r\n    __pyx_v_n = __pyx_t_2;\r\n    Py_DECREF(((PyObject *)__pyx_v_s));\r\n    __pyx_t_2 = __pyx_f_6pyxobj_loop_tail(__pyx_v_n, (__pyx_v_i + 1), __pyx_v_nearTo); if (unlikely(__pyx_t_2 == ((PyObject *)NULL))) __PYX_ERR(0, 15, __pyx_L1_error)\r\n    __pyx_r = __pyx_t_2;\r\n    goto __pyx_L0;\r\n  }\r\n  /*else*/ {\r\n    __pyx_r = __pyx_v_s;\r\n    goto __pyx_L0;\r\n  }\r\n  __pyx_L1_error:;\r\n  __Pyx_AddTraceback(\"pyxobj.loop_tail\", __pyx_clineno, __pyx_lineno, __pyx_filename);\r\n  __pyx_r = NULL;\r\n  __pyx_L0:;\r\n  __Pyx_RefNannyFinishContext();\r\n  return __pyx_r;\r\n}\r\n```\r\n\r\nWhich doesn't look like the sort of thing that'd be readily tail-call optimized (and if I try it with a large enough `nearTo` then I get a segmentation fault, suggesting it probably isn't optimized).\r\n\r\nHaving tried it I think you'll really struggle to persuade Cython to generate code in the format you want. I don't really know what to suggest.",
            "created_at": "2021-02-13T20:15:33Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-778672258",
            "id": 778672258,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODY3MjI1OA==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-13T20:15:47Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/778672258",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            }
        },
        {
            "author_association": "NONE",
            "body": "@da-woods You got very close to the solution. The reason why it is stack overflowing is because of that `except NULL` in `cdef PyObject* loop_tail(PyObject* s, int i, int nearTo) except NULL:`. That exception check has to come after the return in the generated code, so of course TCO cannot work. When written like `cdef PyObject* loop_tail(PyObject* s, int i, int nearTo):` it should work.",
            "created_at": "2021-02-14T08:38:49Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-778746301",
            "id": 778746301,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODc0NjMwMQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-14T08:38:49Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/778746301",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "NONE",
            "body": "```cython\r\nfrom cpython.ref cimport PyObject, Py_DECREF, Py_INCREF\r\n\r\ncdef inline PyObject* getPyObject(object o):\r\n    Py_INCREF(o)  # Cython will always put a decref in on \"o\" so need to counteract it\r\n    return <PyObject*>o\r\n\r\n# In a separate function to keep all Python temp cleanup code out of loop_tail\r\ncdef PyObject* splus0(PyObject* s) except NULL:\r\n    return getPyObject(<object>s+0)\r\n\r\ncdef PyObject* loop_tail(PyObject* s, int i, int nearTo):\r\n    cdef PyObject *n\r\n    if i < nearTo:\r\n        n = splus0(s)\r\n        Py_DECREF(<object>s)\r\n        return loop_tail(n, i+1, nearTo)\r\n    else:\r\n        return s\r\n\r\ndef run_loop_tail(s, i, nearTo):\r\n    # When in tail-end position, s should not be incref'd.\r\n    return <object>loop_tail(<PyObject*>s, i, nearTo)\r\n\r\ndef main(): return run_loop_tail(0,0,1_000_000_000)\r\n```\r\n\r\nThis works for me, thank you @da-woods . As the comment says, under my ref counting scheme, args should not be incref'd in tail calls.\r\n\r\nThanks to this experience I realized that the way I thought Cython was doing ref counting was not right.\r\n\r\n@scoder You said that...\r\n\r\n> I'd like to avoid adding a language feature (which would probably stick around forever) for something that is a limitation of a specific C compiler (which might be lifted in a future version).\r\n\r\nAs a counter point that this is not a limitation of the C compiler consider the identity function `cdef id(x): return x`.\r\n\r\n```cpp\r\n/* \"testm.pyx\":41\r\n * #     print(sys.getrefcount(s)) # 1\r\n * \r\n * cdef id(x): return x             # <<<<<<<<<<<<<<\r\n * \r\n * def main():\r\n */\r\n\r\nstatic PyObject *__pyx_f_5testm_id(PyObject *__pyx_v_x) {\r\n  PyObject *__pyx_r = NULL;\r\n  __Pyx_RefNannyDeclarations\r\n  __Pyx_RefNannySetupContext(\"id\", 0);\r\n  __Pyx_XDECREF(__pyx_r);\r\n  __Pyx_INCREF(__pyx_v_x);\r\n  __pyx_r = __pyx_v_x;\r\n  goto __pyx_L0;\r\n\r\n  /* function exit code */\r\n  __pyx_L0:;\r\n  __Pyx_XGIVEREF(__pyx_r);\r\n  __Pyx_RefNannyFinishContext();\r\n  return __pyx_r;\r\n}\r\n```\r\n\r\nNote the `__Pyx_INCREF(__pyx_v_x);`. It increfs the argument before returning it.\r\n\r\nIn F#-styled pseudocode, this would be the same as writing.\r\n\r\n```fs\r\nlet id x =\r\n    incref x\r\n    x\r\n```\r\n\r\nUnder my own ref counting proposal this would be done without the `incref`\r\n\r\n```fs\r\nlet id x = x\r\n```\r\n\r\nNow way can one be optimized to be the other. For comparison, here is how the `loop_tail` would be written in pseudocode. This is the scheme Cython uses currently.\r\n\r\n```fs\r\nlet decref s : unit = failwith \"decrements the reference count\"\r\nlet incref s : unit = failwith \"increments the reference count\"\r\nlet assert_reference_count obj (count : int) : unit = failwith \"asserts the reference count\"\r\n\r\nlet rec loop_tail' s i nearTo =\r\n    if i < nearTo then\r\n        let n = s + 0\r\n        assert_reference_count n 1\r\n        let r = loop_tail' n (i+1) nearTo\r\n        decref n\r\n        r\r\n    else\r\n        incref s\r\n        s\r\n\r\nlet test_loop_tail_false () =\r\n    let s : int = 0 // Pretend int is an object here. \r\n    assert_reference_count s 1\r\n\r\n    let a = loop_tail' s 0 0 // Increfs s and returns it\r\n    assert_reference_count s 2\r\n    assert_reference_count a 2\r\n\r\n    let b = loop_tail' s 0 0 // Increfs s and returns it\r\n    assert_reference_count s 3\r\n    assert_reference_count a 3\r\n    assert_reference_count b 3\r\n\r\n    let c = loop_tail' s 0 0 // Increfs s and returns it\r\n    assert_reference_count s 4\r\n    assert_reference_count a 4\r\n    assert_reference_count b 4\r\n    assert_reference_count c 4\r\n\r\n    // Exits the function. Decrefs s,a,b,c.\r\n    decref s\r\n    assert_reference_count s 3\r\n    assert_reference_count a 3\r\n    assert_reference_count b 3\r\n    assert_reference_count c 3\r\n\r\n    decref a\r\n    assert_reference_count s 2\r\n    assert_reference_count a 2\r\n    assert_reference_count b 2\r\n    assert_reference_count c 2\r\n\r\n    decref b\r\n    assert_reference_count s 1\r\n    assert_reference_count a 1\r\n    assert_reference_count b 1\r\n    assert_reference_count c 1\r\n\r\n    decref c\r\n    assert_reference_count s 0\r\n    assert_reference_count a 0\r\n    assert_reference_count b 0\r\n    assert_reference_count c 0\r\n\r\nlet test_loop_tail_true () =\r\n    // Unlike in Python, because they are immutable the bindings do not affect the reference count.\r\n    let s : int = 0 // Pretend int is an object here.\r\n    assert_reference_count s 1\r\n\r\n    let a = loop_tail' s 0 1 // Visits the true branch once creating a new object. Incref's it on the next iteration, and then decrefs it before the return.\r\n    assert_reference_count s 1\r\n    assert_reference_count a 1\r\n\r\n    let b = loop_tail' s 0 1 // Visits the true branch once creating a new object. Incref's it on the next iteration, and then decrefs it before the return.\r\n    assert_reference_count s 1\r\n    assert_reference_count a 1\r\n    assert_reference_count b 1\r\n\r\n    let c = loop_tail' s 0 1 // Visits the true branch once creating a new object. Incref's it on the next iteration, and then decrefs it before the return.\r\n    assert_reference_count s 1\r\n    assert_reference_count a 1\r\n    assert_reference_count b 1\r\n    assert_reference_count c 1\r\n\r\n    // Exits the function. Decrefs s,a,b,c.\r\n    decref s\r\n    assert_reference_count s 0\r\n    assert_reference_count a 1\r\n    assert_reference_count b 1\r\n    assert_reference_count c 1\r\n\r\n    decref a\r\n    assert_reference_count s 0\r\n    assert_reference_count a 0\r\n    assert_reference_count b 1\r\n    assert_reference_count c 1\r\n\r\n    decref b\r\n    assert_reference_count s 0\r\n    assert_reference_count a 0\r\n    assert_reference_count b 0\r\n    assert_reference_count c 1\r\n\r\n    decref c\r\n    assert_reference_count s 0\r\n    assert_reference_count a 0\r\n    assert_reference_count b 0\r\n    assert_reference_count c 0\r\n```\r\n\r\nNot a limitation of the compiler. Hopefully all of this should serve as proof why a different ref counting scheme would need Cython's language support.\r\n\r\nI only figured out last night that the fun args being returned are being incref'd. This is part of the reason why I got confused about my own proposal until I thought it through more in depth. Under my incorrect mental model of the standard scheme, I expected that `def id(x): return x` would just return the arg without changing the ref count.",
            "created_at": "2021-02-14T09:31:04Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-778751945",
            "id": 778751945,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODc1MTk0NQ==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-14T09:34:49Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/778751945",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> I only figured out last night that the fun args being returned are being incref'd\r\n\r\nI don't think I got it. Why is that an issue?",
            "created_at": "2021-02-15T21:10:37Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-779449174",
            "id": 779449174,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3OTQ0OTE3NA==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-15T21:10:37Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/779449174",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            }
        },
        {
            "author_association": "NONE",
            "body": "> I don't think I got it. Why is that an issue?\r\n\r\nIt isn't. It is is just some background info on my thought process. \r\n\r\nAt any rate, hopefully I have made my case for why a different way of doing ref counting would be necessary in order to enable TCO. For myself, I feel that coming to an understanding of ref counting has been a great benefit. I'll probably do a C backend at some point and being able to move beyond manual memory management will be a great gain in capability.",
            "created_at": "2021-02-16T09:35:30Z",
            "html_url": "https://github.com/cython/cython/issues/3999#issuecomment-779708840",
            "id": 779708840,
            "issue_url": "https://api.github.com/repos/cython/cython/issues/3999",
            "node_id": "MDEyOklzc3VlQ29tbWVudDc3OTcwODg0MA==",
            "performed_via_github_app": null,
            "updated_at": "2021-02-16T09:35:30Z",
            "url": "https://api.github.com/repos/cython/cython/issues/comments/779708840",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
                "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrakgr/followers",
                "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrakgr",
                "id": 6266635,
                "login": "mrakgr",
                "node_id": "MDQ6VXNlcjYyNjY2MzU=",
                "organizations_url": "https://api.github.com/users/mrakgr/orgs",
                "received_events_url": "https://api.github.com/users/mrakgr/received_events",
                "repos_url": "https://api.github.com/users/mrakgr/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrakgr"
            }
        }
    ],
    "comments": 15,
    "comments_url": "https://api.github.com/repos/cython/cython/issues/3999/comments",
    "created_at": "2021-02-05T17:21:15Z",
    "event_data": [
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-11T11:48:08Z",
            "event": "renamed",
            "id": 4319412454,
            "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50NDMxOTQxMjQ1NA==",
            "performed_via_github_app": null,
            "rename": {
                "from": "[ENH] Ownership passing for full tall call optimization in cdef methods",
                "to": "[ENH] Temporary Python arguments prevent tail call optimization in cdef methods"
            },
            "url": "https://api.github.com/repos/cython/cython/issues/events/4319412454"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-11T11:48:22Z",
            "event": "renamed",
            "id": 4319413449,
            "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50NDMxOTQxMzQ0OQ==",
            "performed_via_github_app": null,
            "rename": {
                "from": "[ENH] Temporary Python arguments prevent tail call optimization in cdef methods",
                "to": "[ENH] Temporary Python arguments prevent tail call optimization in cdef functions"
            },
            "url": "https://api.github.com/repos/cython/cython/issues/events/4319413449"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5534781?v=4",
                "events_url": "https://api.github.com/users/leofang/events{/privacy}",
                "followers_url": "https://api.github.com/users/leofang/followers",
                "following_url": "https://api.github.com/users/leofang/following{/other_user}",
                "gists_url": "https://api.github.com/users/leofang/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/leofang",
                "id": 5534781,
                "login": "leofang",
                "node_id": "MDQ6VXNlcjU1MzQ3ODE=",
                "organizations_url": "https://api.github.com/users/leofang/orgs",
                "received_events_url": "https://api.github.com/users/leofang/received_events",
                "repos_url": "https://api.github.com/users/leofang/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/leofang/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/leofang/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/leofang"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-12T13:53:42Z",
            "event": "subscribed",
            "id": 4324906162,
            "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQzMjQ5MDYxNjI=",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4324906162"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-13T19:22:31Z",
            "event": "mentioned",
            "id": 4328066533,
            "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDMyODA2NjUzMw==",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4328066533"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-13T19:22:32Z",
            "event": "subscribed",
            "id": 4328066535,
            "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQzMjgwNjY1MzU=",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4328066535"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-14T08:38:49Z",
            "event": "mentioned",
            "id": 4328521065,
            "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDMyODUyMTA2NQ==",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4328521065"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-14T08:38:49Z",
            "event": "subscribed",
            "id": 4328521067,
            "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQzMjg1MjEwNjc=",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4328521067"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-14T09:31:04Z",
            "event": "mentioned",
            "id": 4328555817,
            "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDMyODU1NTgxNw==",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4328555817"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/491659?v=4",
                "events_url": "https://api.github.com/users/scoder/events{/privacy}",
                "followers_url": "https://api.github.com/users/scoder/followers",
                "following_url": "https://api.github.com/users/scoder/following{/other_user}",
                "gists_url": "https://api.github.com/users/scoder/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/scoder",
                "id": 491659,
                "login": "scoder",
                "node_id": "MDQ6VXNlcjQ5MTY1OQ==",
                "organizations_url": "https://api.github.com/users/scoder/orgs",
                "received_events_url": "https://api.github.com/users/scoder/received_events",
                "repos_url": "https://api.github.com/users/scoder/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/scoder/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/scoder/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/scoder"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-14T09:31:04Z",
            "event": "subscribed",
            "id": 4328555821,
            "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQzMjg1NTU4MjE=",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4328555821"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-14T09:31:04Z",
            "event": "mentioned",
            "id": 4328555825,
            "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDMyODU1NTgyNQ==",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4328555825"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10536947?v=4",
                "events_url": "https://api.github.com/users/da-woods/events{/privacy}",
                "followers_url": "https://api.github.com/users/da-woods/followers",
                "following_url": "https://api.github.com/users/da-woods/following{/other_user}",
                "gists_url": "https://api.github.com/users/da-woods/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/da-woods",
                "id": 10536947,
                "login": "da-woods",
                "node_id": "MDQ6VXNlcjEwNTM2OTQ3",
                "organizations_url": "https://api.github.com/users/da-woods/orgs",
                "received_events_url": "https://api.github.com/users/da-woods/received_events",
                "repos_url": "https://api.github.com/users/da-woods/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/da-woods/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/da-woods/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/da-woods"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2021-02-14T09:31:04Z",
            "event": "subscribed",
            "id": 4328555826,
            "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQzMjg1NTU4MjY=",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/cython/cython/issues/events/4328555826"
        }
    ],
    "events_url": "https://api.github.com/repos/cython/cython/issues/3999/events",
    "html_url": "https://github.com/cython/cython/issues/3999",
    "id": 802339291,
    "labels": [],
    "labels_url": "https://api.github.com/repos/cython/cython/issues/3999/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "MDU6SXNzdWU4MDIzMzkyOTE=",
    "number": 3999,
    "performed_via_github_app": null,
    "repository_url": "https://api.github.com/repos/cython/cython",
    "state": "open",
    "title": "[ENH] Temporary Python arguments prevent tail call optimization in cdef functions",
    "updated_at": "2021-02-16T09:35:30Z",
    "url": "https://api.github.com/repos/cython/cython/issues/3999",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/6266635?v=4",
        "events_url": "https://api.github.com/users/mrakgr/events{/privacy}",
        "followers_url": "https://api.github.com/users/mrakgr/followers",
        "following_url": "https://api.github.com/users/mrakgr/following{/other_user}",
        "gists_url": "https://api.github.com/users/mrakgr/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/mrakgr",
        "id": 6266635,
        "login": "mrakgr",
        "node_id": "MDQ6VXNlcjYyNjY2MzU=",
        "organizations_url": "https://api.github.com/users/mrakgr/orgs",
        "received_events_url": "https://api.github.com/users/mrakgr/received_events",
        "repos_url": "https://api.github.com/users/mrakgr/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/mrakgr/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/mrakgr/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/mrakgr"
    }
}